(()=>{"use strict";function e(y,k){false}function i(y,k){return y-k}function s(y,k){return y!==k?y<k?-1:1:0}function n(y,k){return y===k?0:y<k?-1:1}function r(y,k,M){return void 0===k?void 0===M?0:-1:void 0===M?1:y(k,M)}function o(y,k){return r(s,y,k)}function a(y){const k=parseInt(y,16);return Number.isNaN(k)?0:k}function c(y,k,M=!0){const b=y.charCodeAt(k);return b>=(M?48:49)&&b<=57||b>=97&&b<=102}function l(y,k,M){if(0===M)return!1;if(!c(y,k,!1))return!1;for(let b=1;b<M;b++)if(!c(y,k+b))return!1;return!0}var y,k,M,b,E,D,R,X,z,N,Y,O,B,V,U,L,Z,q,jr,Gr,Jr,Kr,so,no,ro,oo,ao,co,uo,po,Io,wo,Fo,ko,bo,Eo;!function(y){y.getLocalId=function(y){if(g(y))return 0;const k=y.length,M=k>12?k-10:2;return a(y.slice(M))},y.getBriefcaseId=function(y){if(g(y))return 0;const k=y.length;return k<=12?0:a(y.slice(2,k-10))},y.fromJSON=function(k){return"string"==typeof k?y.fromString(k):y.invalid},y.fromString=function(k){if("string"!=typeof k)return y.invalid;if(y.isId64(k))return k;const M=(k=k.toLowerCase().trim()).length;if(M<2||"0"!==k[0]||"x"!==k[1])return y.invalid;let b=0,E=0,D=2;return M>12&&(D=M-10,E=a(k.slice(2,D))),b=a(k.slice(D)),i(b,E)};const k=["0000000000","000000000","00000000","0000000","000000","00000","0000","000","00","0",""];function i(M,b){if("number"!=typeof M||"number"!=typeof b)return y.invalid;if(0===(M=Math.floor(M)))return y.invalid;b=Math.floor(b);const E=M.toString(16);return`0x${0===b?E:b.toString(16)+(k[E.length]+E)}`}y.fromLocalAndBriefcaseIds=i;const M=[48,120,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48];function n(y){return y+(y<10?48:87)}function r(y,k,M){let b=0;for(let D=k;D<M;D++)b=(b|(E=y.charCodeAt(D))-(E>=87?87:48)<<(M-D-1<<2))>>>0;var E;return b}function o(k,b){if(0==(k>>>0)+4294967296*(255&b))return y.invalid;const E=M;let D=2;for(let y=7;y>=0;y--){const k=y<<2,M=(b&15<<k)>>>k;(D>2||0!==M)&&(E[D++]=n(M))}for(let y=7;y>=0;y--){const M=y<<2,b=(k&15<<M)>>>M;(D>2||0!==b)&&(E[D++]=n(b))}return E.length!==D&&(E.length=D),String.fromCharCode(...M)}function c(y){if(g(y))return 0;const k=y.length;return r(y,k>10?k-8:2,k)}function h(y){const k=y.length;return k<=10||g(y)?0:r(y,2,k-8)}function*d(y){if("string"==typeof y)yield y;else for(const k of y)yield k}function u(y){return 18===y.length&&y.startsWith("0xffffff")}function f(k){return y.invalid!==k&&y.isId64(k)}function g(k){return y.invalid===k}y.fromUint32Pair=o,y.fromUint32PairObject=function(y){return o(y.lower,y.upper)},y.isValidUint32Pair=function(y,k){return 0!==y||!!(255&k)},y.getUint32Pair=function(y,k){return k||(k={lower:0,upper:0}),k.lower=c(y),k.upper=h(y),k},y.getLowerUint32=c,y.getUpperUint32=h,y.toIdSet=function(y,k=!1){if(y instanceof Set)return k?new Set(y):y;const M=new Set;return"string"==typeof y?M.add(y):Array.isArray(y)&&y.forEach((y=>{"string"==typeof y&&M.add(y)})),M},y.iterator=d,y.iterable=function(y){return{[Symbol.iterator]:()=>d(y)}},y.getFirst=function(k){return"string"==typeof k?k:(Array.isArray(k)?k[0]:k.values().next().value)??y.invalid},y.sizeOf=function(y){return"string"==typeof y?1:Array.isArray(y)?y.length:y.size},y.has=function(y,k){return"string"==typeof y?y===k:Array.isArray(y)?-1!==y.indexOf(k):y.has(k)},y.invalid="0",y.isTransient=u,y.isTransientId64=function(y){return f(y)&&u(y)},y.isId64=function(y){const k=y.length;if(0===k||18<k)return!1;if("0"!==y[0])return!1;if(1===k)return!0;if(2===k||"x"!==y[1])return!1;let M=2;if(k>12){if(M=k-10,!l(y,2,M-2))return!1;for(let b=M;b<k&&48===y.charCodeAt(b);b++)M++;if(M>=k)return!1}return l(y,M,k-M)},y.isValid=function(k){return y.invalid!==k},y.isValidId64=f,y.isInvalid=g,y.Uint32Set=class{constructor(y){this._map=new Map,void 0!==y&&this.addIds(y)}equals(y){if(this===y)return!0;if(this.size!==y.size)return!1;for(const[k,M]of this._map){const b=y._map.get(k);if(!b||M.size!==b.size)return!1;for(const y of M)if(!b.has(y))return!1}return!0}clear(){this._map.clear()}addId(k){this.add(y.getLowerUint32(k),y.getUpperUint32(k))}addIds(k){for(const M of y.iterable(k))this.addId(M)}hasId(k){return this.has(y.getLowerUint32(k),y.getUpperUint32(k))}add(y,k){let M=this._map.get(k);void 0===M&&(M=new Set,this._map.set(k,M)),M.add(y)}deleteId(k){this.delete(y.getLowerUint32(k),y.getUpperUint32(k))}deleteIds(k){for(const M of y.iterable(k))this.deleteId(M)}delete(y,k){const M=this._map.get(k);void 0!==M&&M.delete(y)}has(y,k){const M=this._map.get(k);return void 0!==M&&M.has(y)}hasPair(y){return this.has(y.lower,y.upper)}get isEmpty(){return 0===this._map.size}get size(){let y=0;for(const k of this._map)y+=k[1].size;return y}toId64Array(){const k=[];for(const M of this._map)for(const b of M[1])k.push(y.fromUint32Pair(b,M[0]));return k}toId64Set(){const k=new Set;for(const M of this._map)for(const b of M[1])k.add(y.fromUint32Pair(b,M[0]));return k}forEach(y){for(const k of this._map)for(const M of k[1])y(M,k[0])}},y.Uint32Map=class{constructor(){this._map=new Map}clear(){this._map.clear()}getById(k){return this.get(y.getLowerUint32(k),y.getUpperUint32(k))}setById(k,M){this.set(y.getLowerUint32(k),y.getUpperUint32(k),M)}set(y,k,M){let b=this._map.get(k);void 0===b&&(b=new Map,this._map.set(k,b)),b.set(y,M)}get(y,k){const M=this._map.get(k);return void 0!==M?M.get(y):void 0}get isEmpty(){return 0===this._map.size}get size(){let y=0;for(const k of this._map)y+=k[1].size;return y}forEach(y){for(const k of this._map)for(const M of k[1])y(M[0],k[0],M[1])}}}(y||(y={})),function(y){const k=new RegExp("^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$");function i(y){return k.test(y)}y.empty="00000000-0000-0000-0000-000000000000",y.isGuid=i,y.isV4Guid=function(y){return/^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-4[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$/.test(y)},y.createValue=function(){return"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,(y=>{const k=16*Math.random()|0;return("x"===y?k:3&k|8).toString(16)}))},y.normalize=function(y){const k=y.toLowerCase().trim();if(i(k))return k;const M=k.replace(/-/g,""),b=/^([0-9a-f]{8})([0-9a-f]{4})([0-9a-f]{4})([0-9a-f]{4})([0-9a-f]{12})$/;return b.test(M)?M.replace(b,((y,k,M,b,E,D)=>`${k}-${M}-${b}-${E}-${D}`)):y}}(k||(k={})),function(y){function i(y,k){return y.length!==k.length?y.length<k.length?-1:1:y!==k?y<k?-1:1:0}function*s(y){const k=y[Symbol.iterator]();let M,b=k.next();for(;!b.done;){const y=b.value;b=k.next(),y!==M&&(M=y,yield y)}}function*n(y,k){const M=y[Symbol.iterator](),b=k[Symbol.iterator]();let E,D=M.next(),R=b.next();for(;!D.done||!R.done;){const y=D.done?void 0:D.value,k=R.done?void 0:R.value;if(e(),void 0===y&&void 0===k)break;let X;if(void 0===y)e(),X=k,R=b.next();else if(void 0===k)X=y,D=M.next();else{const E=i(y,k);E<=0?(X=y,D=M.next(),0===E&&(R=b.next())):(X=k,R=b.next())}E!==X&&(E=X,yield X)}}function*r(y,k){const M=y[Symbol.iterator](),b=k[Symbol.iterator]();let E,D=M.next(),R=b.next();for(;!D.done&&!R.done;){const y=D.value;if(D=M.next(),y===E)continue;E=y;let k=R.value,X=i(y,k);for(;X>0;){if(R=b.next(),R.done)return;k=R.value,X=i(y,k)}0===X&&(yield y)}}function*o(y,k){const M=y[Symbol.iterator](),b=k[Symbol.iterator]();let E,D=M.next(),R=b.next();for(;!D.done;){const y=D.value;if(D=M.next(),y===E)continue;if(R.done){yield E=y;continue}let k=R.value,X=i(y,k);for(;X>0&&!R.done;)R=b.next(),R.done?yield E=y:(k=R.value,X=i(y,k));X<0&&(yield E=y)}}y.compare=i,y.sortArray=function(y){return y.sort(((y,k)=>i(y,k))),y},y.areEqualSets=function(y,k){const M=s(y),b=s(k);let E=M.next(),D=b.next();for(;!E.done&&!D.done;){if(0!==i(E.value,D.value))return!1;E=M.next(),D=b.next()}return!(!E.done||!D.done)},y.isEmptySet=function(y){return"string"==typeof y?""===y:!0===y[Symbol.iterator]().next().done},y.unique=function(y){return{[Symbol.iterator]:()=>s(y)}},y.uniqueIterator=s,y.union=function(y,k){return{[Symbol.iterator]:()=>n(y,k)}},y.intersection=function(y,k){return{[Symbol.iterator]:()=>r(y,k)}},y.difference=function(y,k){return{[Symbol.iterator]:()=>o(y,k)}},y.unionIterator=n,y.intersectionIterator=r,y.differenceIterator=o}(M||(M={})),function(k){function i(y){return y>=48&&y<=57||y>=65&&y<=70}function s(y,k){e();const M=`+${y.toString()}`;return k<=1?M:`${M}*${k.toString(16).toUpperCase()}`}function n(y){const k="string"==typeof y?[y]:Array.from(y);return M.sortArray(k),r(k)}function r(y){return o(y)}function o(k){if("string"==typeof k)return k;let M="";const b=new a,E=new a;let D=0;const R=new a,X=new a;for(const z of k){if(!y.isValidId64(z))continue;R.setFromId(z),X.setFromDifference(R,b);const k=b.compare(R);if(0!==k){if(k>0)throw new Error("CompressedId64Set.compressArray requires a sorted array as input");b.copyFrom(R),0===D?(E.copyFrom(X),D=1):X.equals(E)?++D:(M+=s(E,D),E.copyFrom(X),D=1)}}return 0<D&&(M+=s(E,D)),M}k.compressSet=function(y){return n(y)},k.sortAndCompress=n,k.compressArray=r,k.compressIds=o;class a{static assertUint32(y){e(),e(a._base),e(Math.floor(y))}assertConstraints(){a.assertUint32(this.lower),a.assertUint32(this.upper)}constructor(y=0,k=0){this.lower=y,this.upper=k,this.assertConstraints()}compare(y){const k=this.upper-y.upper;return 0===k?this.lower-y.lower:k}equals(y){return 0===this.compare(y)}isLessThan(y){return this.compare(y)<0}isGreaterThan(y){return this.compare(y)>0}get isZero(){return 0===this.lower&&0===this.upper}setFromDifference(y,k){e(k.isGreaterThan(y)),this.lower=y.lower-k.lower,this.upper=y.upper-k.upper,this.lower<0&&(this.lower+=a._base,this.upper-=1)}add(y){let k=y.lower,M=y.upper;k+this.lower>=a._base&&(k-=a._base,M+=1),this.lower+=k,this.upper+=M,this.assertConstraints()}setFromId(k){y.getUint32Pair(k,this)}copyFrom(y){this.lower=y.lower,this.upper=y.upper}toString(){if(0===this.upper)return this.lower.toString(16).toUpperCase();const y=this.upper.toString(16),k=this.lower.toString(16).padStart(8,"0");return e(k.length),`${y}${k}`.toUpperCase()}toId64String(){return y.fromUint32Pair(this.lower,this.upper)}}function*c(y){if(0===y.length)return;if("+"!==y[0])throw new Error("Invalid CompressedId64Set");let k=1;const M=new a;function r(){let M=0,b=0;for(;k<y.length&&b<8;){++b;const E=y.charCodeAt(k);if(!i(E))break;M<<=4,M|=E>=65?E-65+10:E-48,M>>>=0,++k}return M}function o(M){let b=0,E=0;const D=k,R=r(),X=k-D;if(e(),8===X&&k+1<y.length&&i(y.charCodeAt(k+1))){const y=k,M=r(),D=k-y;e();const X=8-D;E=R>>>4*X,b=(M|R-(E<<4*X>>>0)<<4*D>>>0)>>>0}else b=R;M.lower=b,M.upper=E}const b=new a;for(;k<y.length;){let E=1;if(o(b),b.isZero)throw new Error("Invalid CompressedId64Set");if(k<y.length)switch(y[k++]){case"*":if(E=r(),0===E)throw new Error("Invalid CompressedId64Set");if(k!==y.length&&"+"!==y[k++])return;break;case"+":break;default:throw new Error("Invalid CompressedId64Set")}for(let y=0;y<E;y++)M.add(b),yield M.toId64String()}}function l(y){return{[Symbol.iterator]:()=>c(y)}}a._base=4294967296,k.iterator=c,k.iterable=l,k.decompressSet=function(y,k){const M=k??new Set;for(const b of l(y))M.add(b);return M},k.decompressArray=function(y,k){const M=k??[];for(const b of l(y))M.push(b);return M}}(b||(b={})),Symbol.iterator;class W{constructor(y=0,k){this._radians=y,this._degrees=k}clone(){return new W(this._radians,this._degrees)}freeze(){return Object.freeze(this)}static createDegrees(y){return new W(W.degreesToRadians(y),y)}static createRadians(y){return new W(y)}static createSmallAngle(){return new W(Q.smallAngleRadians)}static createInterpolate(y,k,M){return new W(Q.interpolate(y.radians,k,M.radians))}cloneScaled(y){return new W(this.radians*y)}setRadians(y){this._radians=y,this._degrees=void 0}setDegrees(y){this._radians=W.degreesToRadians(y),this._degrees=y}static create360(){return new W(2*Math.PI,360)}static createAtan2(y,k){return new W(Math.atan2(y,k))}setFrom(y){this._radians=y._radians,this._degrees=y._degrees}setFromJSON(y,k){this._radians=k||0,y&&("number"==typeof y?this.setDegrees(y):"number"==typeof y.degrees?this.setDegrees(y.degrees):"number"==typeof y._degrees?this.setDegrees(y._degrees):"number"==typeof y.radians?this.setRadians(y.radians):"number"==typeof y._radians&&this.setRadians(y._radians))}static fromJSON(y,k){const M=new W;return M.setFromJSON(y,k),M}toJSON(){return this.degrees}toJSONRadians(){return{radians:this.radians}}get radians(){return this._radians}get degrees(){return void 0!==this._degrees?this._degrees:W.radiansToDegrees(this._radians)}static degreesToRadians(y){return y*Math.PI/180}static radiansToDegrees(y){if(y<0)return-W.radiansToDegrees(-y);const k=Math.PI;return y<=.25*k?180/k*y:y<.75*k?90+(y-.5*k)/k*180:y<=1.25*k?180+(y-k)/k*180:y<=1.75*k?270+(y-1.5*k)/k*180:360+(y-2*k)/k*180}cos(){return Math.cos(this._radians)}sin(){return Math.sin(this._radians)}tan(){return Math.tan(this._radians)}static isFullCircleRadians(y){return Math.abs(y)>=Q.fullCircleRadiansMinusSmallAngle}static isHalfCircleRadians(y){return Math.abs(Math.abs(y)-Math.PI)<=Q.smallAngleRadians}get isFullCircle(){return W.isFullCircleRadians(this._radians)}get isHalfCircle(){return W.isHalfCircleRadians(this._radians)}static adjustDegrees0To360(y){if(y>=0){const k=360;return y<k?y:y-Math.floor(y/k)*k}return y<0?360-W.adjustDegrees0To360(-y):0}static adjustDegreesSigned180(y){if(Math.abs(y)<=180)return y;if(y>=0){const k=360;return y-(1+Math.floor((y-180)/k))*k}return y<0?-W.adjustDegreesSigned180(-y):0}static adjustRadians0To2Pi(y){if(y>=0){const k=2*Math.PI;return y<k?y:y-Math.floor(y/k)*k}return y<0?2*Math.PI-W.adjustRadians0To2Pi(-y):0}static adjustRadians0ToLessThan2Pi(y){return W.isAlmostEqualRadiansAllowPeriodShift(y,0)&&(y=0),this.adjustRadians0To2Pi(y)}static adjustRadiansMinusPiPlusPi(y){if(Math.abs(y)<=Math.PI)return y;if(y>=0){const k=2*Math.PI;return y-(1+Math.floor((y-Math.PI)/k))*k}return y<0?-W.adjustRadiansMinusPiPlusPi(-y):0}static zero(){return new W(0)}get isExactZero(){return 0===this.radians}get isAlmostZero(){return Math.abs(this.radians)<Q.smallAngleRadians}get isAlmostNorthOrSouthPole(){return W.isHalfCircleRadians(2*this.radians)}static createDegreesAdjustPositive(y){return W.createDegrees(W.adjustDegrees0To360(y))}static createDegreesAdjustSigned180(y){return W.createDegrees(W.adjustDegreesSigned180(y))}static isAlmostEqualRadiansAllowPeriodShift(y,k,M=Q.smallAngleRadians){const b=Math.abs(y-k);if(b<=M)return!0;const E=2*Math.PI;if(Math.abs(b-E)<=M)return!0;const D=b-Math.round(b/E)*E;return Math.abs(D)<=M}isMagnitudeLessThanOrEqual(y){return Math.abs(this.radians)<=Math.abs(y.radians)}isAlmostEqualAllowPeriodShift(y,k=Q.smallAngleRadians){return W.isAlmostEqualRadiansAllowPeriodShift(this._radians,y._radians,k)}static isAlmostEqualRadiansNoPeriodShift(y,k,M=Q.smallAngleRadians){return Math.abs(y-k)<M}isAlmostEqualNoPeriodShift(y,k=Q.smallAngleRadians){return W.isAlmostEqualRadiansNoPeriodShift(this._radians,y._radians,k)}isAlmostEqual(y,k=Q.smallAngleRadians){return this.isAlmostEqualNoPeriodShift(y,k)}static isPerpendicularDotSet(y,k,M){return y>Q.smallMetricDistanceSquared&&k>Q.smallMetricDistanceSquared&&M*M<=Q.smallAngleRadiansSquared*y*k}static trigValuesToHalfAngleTrigValues(y,k){const M=Q.hypotenuseXY(y,k);if(M<Q.smallMetricDistance)return{c:1,s:0,radians:0};{let b,E=0;const D=y/M,R=k/M;return D>=0?(b=Math.sqrt(.5*(1+D)),E=R/(2*b)):(E=R>0?Math.sqrt(.5*(1-D)):-Math.sqrt(.5*(1-D)),b=R/(2*E)),{c:b,s:E,radians:Math.atan2(E,b)}}}static cleanupTrigValue(y,k=Q.smallFloatingPoint){const M=Math.abs(y);if(M<=k)return 0;let b=Math.abs(M-.5);return b<=k?y<0?-.5:.5:(b=Math.abs(M-1),b<=k?y<0?-1:1:y)}static dotProductsToHalfAngleTrigValues(y,k,M,b=!0){const E=y-k,D=2*M;return b&&Math.abs(D)<Q.smallAngleRadians*(Math.abs(y)+Math.abs(k))?{c:1,s:0,radians:0}:W.trigValuesToHalfAngleTrigValues(E,D)}static radiansBetweenVectorsXYZ(y,k,M,b,E,D){const R=y*b+k*E+M*D;return Math.atan2(Q.crossProductMagnitude(y,k,M,b,E,D),R)}static orientedRadiansBetweenVectorsXYZ(y,k,M,b,E,D,R,X,z,N=!1){const Y=y*b+k*E+M*D,O=k*D-M*E,B=M*b-y*D,V=y*E-k*b,U=R*O+X*B+z*V,L=Q.hypotenuseXYZ(O,B,V);return U<0?N?Math.PI+Math.atan2(L,-Y):-Math.atan2(L,Y):Math.atan2(L,Y)}addMultipleOf2PiInPlace(y){void 0!==this._degrees?(this._degrees+=360*y,this._radians=W.degreesToRadians(this._degrees)):this._radians+=y*W.pi2Radians}}W.piOver12Radians=.26179938779914946,W.piOver4Radians=.7853981633974483,W.piOver2Radians=1.5707963267948966,W.piRadians=3.141592653589793,W.pi3Over2Radians=4.71238898038469,W.pi2Radians=6.283185307179586,W.degreesPerRadian=45/W.piOver4Radians,W.radiansPerDegree=W.piOver4Radians/45;class G{set(y=0,k=0){this.x=y,this.y=k}setZero(){this.x=0,this.y=0}constructor(y=0,k=0){this.x=y,this.y=k}setFrom(y){y?(this.x=y.x,this.y=y.y):(this.x=0,this.y=0)}freeze(){return Object.freeze(this)}isAlmostEqual(y,k){return Q.isSameCoordinate(this.x,y.x,k)&&Q.isSameCoordinate(this.y,y.y,k)}isAlmostEqualXY(y,k,M){return Q.isSameCoordinate(this.x,y,M)&&Q.isSameCoordinate(this.y,k,M)}toJSON(){return[this.x,this.y]}toJSONXY(){return{x:this.x,y:this.y}}setFromJSON(y){Array.isArray(y)?this.set(y[0]||0,y[1]||0):y?this.set(y.x||0,y.y||0):this.set(0,0)}distance(y){const k=y.x-this.x,M=y.y-this.y;return Math.sqrt(k*k+M*M)}distanceSquared(y){const k=y.x-this.x,M=y.y-this.y;return k*k+M*M}maxDiff(y){return Math.max(Math.abs(this.x-y.x),Math.abs(this.y-y.y))}at(y){return y<.5?this.x:this.y}setAt(y,k){y<.5?this.x=k:this.y=k}indexOfMaxAbs(){let y=0;const k=Math.abs(this.x);return Math.abs(this.y)>k&&(y=1),y}get isAlmostZero(){return Q.isSmallMetricDistance(this.x)&&Q.isSmallMetricDistance(this.y)}get isZero(){return 0===this.x&&0===this.y}maxAbs(){return Math.max(Math.abs(this.x),Math.abs(this.y))}magnitude(){return Math.sqrt(this.x*this.x+this.y*this.y)}magnitudeSquared(){return this.x*this.x+this.y*this.y}isExactEqual(y){return this.x===y.x&&this.y===y.y}isAlmostEqualMetric(y,k=Q.smallMetricDistance){return this.maxDiff(y)<=k}vectorTo(y,k){return J.create(y.x-this.x,y.y-this.y,k)}unitVectorTo(y,k){return this.vectorTo(y,k).normalize(k)}static crossProductToPoints(y,k,M){return Q.crossProductXYXY(k.x-y.x,k.y-y.y,M.x-y.x,M.y-y.y)}}class H extends G{constructor(y=0,k=0){super(y,k)}clone(y){return H.create(this.x,this.y,y)}static create(y=0,k=0,M){return M?(M.x=y,M.y=k,M):new H(y,k)}static fromJSON(y){const k=new H;return k.setFromJSON(y),k}static createFrom(y,k){return y?H.create(y.x,y.y,k):H.create(0,0,k)}static createZero(y){return H.create(0,0,y)}addForwardLeft(y,k,M,b){const E=M.x,D=M.y;return H.create(this.x+y*E-k*D,this.y+y*D+k*E,b)}forwardLeftInterpolate(y,k,M){const b=M.x-this.x,E=M.y-this.y;return H.create(this.x+y*b-k*E,this.y+y*E+k*b)}interpolate(y,k,M){if(y<=.5)return H.create(this.x+y*(k.x-this.x),this.y+y*(k.y-this.y),M);const b=y-1;return H.create(k.x+b*(k.x-this.x),k.y+b*(k.y-this.y),M)}interpolateXY(y,k,M,b){return H.create(Q.interpolate(this.x,y,M.x),Q.interpolate(this.y,k,M.y),b)}minus(y,k){return H.create(this.x-y.x,this.y-y.y,k)}plus(y,k){return H.create(this.x+y.x,this.y+y.y,k)}plusXY(y=0,k=0,M){return H.create(this.x+y,this.y+k,M)}plusScaled(y,k,M){return H.create(this.x+y.x*k,this.y+y.y*k,M)}plus2Scaled(y,k,M,b,E){return H.create(this.x+y.x*k+M.x*b,this.y+y.y*k+M.y*b,E)}plus3Scaled(y,k,M,b,E,D,R){return H.create(this.x+y.x*k+M.x*b+E.x*D,this.y+y.y*k+M.y*b+E.y*D,R)}scaleInPlace(y){this.x*=y,this.y*=y}dotVectorsToTargets(y,k){return(y.x-this.x)*(k.x-this.x)+(y.y-this.y)*(k.y-this.y)}crossProductToPoints(y,k){const M=y.x-this.x,b=y.y-this.y,E=k.x-this.x;return M*(k.y-this.y)-b*E}fractionOfProjectionToLine(y,k,M=0){const b=y.distanceSquared(k);return b<Q.smallMetricDistanceSquared?M:y.dotVectorsToTargets(k,this)/b}}class J extends G{constructor(y=0,k=0){super(y,k)}clone(y){return J.create(this.x,this.y,y)}static create(y=0,k=0,M){return M?(M.x=y,M.y=k,M):new J(y,k)}static unitX(y=1){return new J(y,0)}static unitY(y=1){return new J(0,y)}static createZero(y){return J.create(0,0,y)}static createFrom(y,k){return y instanceof Float64Array?y.length>=2?J.create(y[0],y[1]):y.length>=1?J.create(y[0],0):J.create(0,0):J.create(y.x,y.y,k)}static fromJSON(y){const k=new J;return k.setFromJSON(y),k}static createPolar(y,k){return J.create(y*k.cos(),y*k.sin())}static createStartEnd(y,k,M){return J.create(k.x-y.x,k.y-y.y,M)}static createOffsetBisector(y,k,M){let b=y.plus(k);if(b=b.normalize(),b){const k=b.dotProduct(y);return b.scale(M,b),b.safeDivideOrNull(k)}}safeDivideOrNull(y,k){if(0!==y)return this.scale(1/y,k)}normalize(y){const k=Q.correctSmallFraction(this.magnitude());return y=y||new J,this.safeDivideOrNull(k,y)}fractionOfProjectionToVector(y,k){const M=y.magnitudeSquared();return M<Q.smallMetricDistanceSquared?k||0:this.dotProduct(y)/M}negate(y){return(y=y||new J).x=-this.x,y.y=-this.y,y}rotate90CCWXY(y){y=y||new J;const k=this.x,M=this.y;return y.x=-M,y.y=k,y}rotate90CWXY(y){y=y||new J;const k=this.x,M=this.y;return y.x=M,y.y=-k,y}unitPerpendicularXY(y){y=y||new J;const k=this.x,M=this.y;y.x=-M,y.y=k;const b=k*k+M*M;if(0!==b){const k=1/Math.sqrt(b);y.x*=k,y.y*=k}return y}rotateXY(y,k){const M=y.sin(),b=y.cos(),E=this.x,D=this.y;return(k=k||new J).x=E*b-D*M,k.y=E*M+D*b,k}interpolate(y,k,M){if(M=M||new J,y<=.5)M.x=this.x+y*(k.x-this.x),M.y=this.y+y*(k.y-this.y);else{const b=y-1;M.x=k.x+b*(k.x-this.x),M.y=k.y+b*(k.y-this.y)}return M}plus(y,k){return(k=k||new J).x=this.x+y.x,k.y=this.y+y.y,k}minus(y,k){return(k=k||new J).x=this.x-y.x,k.y=this.y-y.y,k}plusScaled(y,k,M){return(M=M||new J).x=this.x+y.x*k,M.y=this.y+y.y*k,M}plus2Scaled(y,k,M,b,E){return(E=E||new J).x=this.x+y.x*k+M.x*b,E.y=this.y+y.y*k+M.y*b,E}plus3Scaled(y,k,M,b,E,D,R){return(R=R||new J).x=this.x+y.x*k+M.x*b+E.x*D,R.y=this.y+y.y*k+M.y*b+E.y*D,R}scale(y,k){return(k=k||new J).x=this.x*y,k.y=this.y*y,k}scaleToLength(y,k){const M=Q.correctSmallFraction(this.magnitude());if(0!==M)return this.scale(y/M,k)}dotProduct(y){return this.x*y.x+this.y*y.y}dotProductStartEnd(y,k){return this.x*(k.x-y.x)+this.y*(k.y-y.y)}crossProduct(y){return this.x*y.y-this.y*y.x}radiansTo(y){return Math.atan2(this.crossProduct(y),this.dotProduct(y))}angleTo(y){return W.createRadians(this.radiansTo(y))}isParallelTo(y,k=!1,M=!1,b){const E=b?.radianSquaredTol??Q.smallAngleRadiansSquared,D=b?.distanceSquaredTol??Q.smallMetricDistanceSquared,R=this.magnitudeSquared(),X=y.magnitudeSquared();if(R<D||X<D)return M;if(this.dotProduct(y)<0&&!k)return!1;const z=this.crossProduct(y);return z*z<=E*R*X}isPerpendicularTo(y,k=!1,M){const b=M?.radianSquaredTol??Q.smallAngleRadiansSquared,E=M?.distanceSquaredTol??Q.smallMetricDistanceSquared,D=this.magnitudeSquared(),R=y.magnitudeSquared();if(D<E||R<E)return k;const X=this.dotProduct(y);return X*X<=b*D*R}}!function(y){y[y.XYZ=0]="XYZ",y[y.YZX=1]="YZX",y[y.ZXY=2]="ZXY",y[y.XZY=4]="XZY",y[y.YXZ=5]="YXZ",y[y.ZYX=6]="ZYX"}(E||(E={})),function(y){y[y.X=0]="X",y[y.Y=1]="Y",y[y.Z=2]="Z"}(D||(D={})),function(y){y[y.Top=1]="Top",y[y.Bottom=2]="Bottom",y[y.Left=3]="Left",y[y.Right=4]="Right",y[y.Front=5]="Front",y[y.Back=6]="Back",y[y.Iso=7]="Iso",y[y.RightIso=8]="RightIso"}(R||(R={})),function(y){y[y.Unit=0]="Unit",y[y.LongestRangeDirection=1]="LongestRangeDirection",y[y.NonUniformRangeContainment=2]="NonUniformRangeContainment"}(X||(X={})),function(y){y[y.Unknown=0]="Unknown",y[y.OnPolygonVertex=1]="OnPolygonVertex",y[y.OnPolygonEdgeInterior=2]="OnPolygonEdgeInterior",y[y.InsidePolygon=3]="InsidePolygon",y[y.InsidePolygonProjectsToVertex=4]="InsidePolygonProjectsToVertex",y[y.InsidePolygonProjectsToEdgeInterior=5]="InsidePolygonProjectsToEdgeInterior",y[y.OutsidePolygon=6]="OutsidePolygon",y[y.OutsidePolygonProjectsToVertex=7]="OutsidePolygonProjectsToVertex",y[y.OutsidePolygonProjectsToEdgeInterior=8]="OutsidePolygonProjectsToEdgeInterior"}(z||(z={}));class Q{static isLargeCoordinateResult(y){return y>=this.largeCoordinateResult||y<=-this.largeCoordinateResult}static isHugeCoordinate(y){return Q.isLargeCoordinateResult(y)}static isOdd(y){return!(1&~y)}static correctSmallMetricDistance(y,k=0){return void 0===y||Math.abs(y)<=Q.smallMetricDistance?k:y}static correctSmallFraction(y,k=0){return void 0===y||Math.abs(y)<=Q.smallFraction?k:y}static inverseMetricDistance(y){return Math.abs(y)<=Q.smallMetricDistance?void 0:1/y}static inverseMetricDistanceSquared(y){return Math.abs(y)<=Q.smallMetricDistanceSquared?void 0:1/y}static isSameCoordinate(y,k,M=Q.smallMetricDistance){let b=y-k;return b<0&&(b=-b),b<=M}static isSameCoordinateWithToleranceFactor(y,k,M){return Q.isSameCoordinate(y,k,M*Q.smallMetricDistance)}static isSameCoordinateXY(y,k,M,b,E=Q.smallMetricDistance){let D=M-y;return D<0&&(D=-D),!(D>E)&&(D=b-k,D<0&&(D=-D),D<=E)}static isSameCoordinateSquared(y,k,M=Q.smallMetricDistance){return Math.abs(Math.sqrt(y)-Math.sqrt(k))<=M}static isSamePoint3d(y,k,M=Q.smallMetricDistance){return y.distance(k)<=M}static isSameXYZ(y,k,M=Q.smallMetricDistance){return y.distance(k)<=M}static isSamePoint3dXY(y,k,M=Q.smallMetricDistance){return y.distanceXY(k)<=M}static isSameVector3d(y,k,M=Q.smallMetricDistance){return y.distance(k)<=M}static isSamePoint2d(y,k,M=Q.smallMetricDistance){return y.distance(k)<=M}static isSameVector2d(y,k,M=Q.smallMetricDistance){return y.distance(k)<=M}static lexicalXYLessThan(y,k){return y.x<k.x?-1:y.x>k.x?1:y.y<k.y?-1:y.y>k.y?1:0}static lexicalYXLessThan(y,k){return y.y<k.y?-1:y.y>k.y?1:y.x<k.x?-1:y.x>k.x?1:0}static lexicalXYZLessThan(y,k){return y.x<k.x?-1:y.x>k.x?1:y.y<k.y?-1:y.y>k.y?1:y.z<k.z?-1:y.z>k.z?1:0}static isSmallRelative(y){return Math.abs(y)<=Q.smallFraction}static isSmallAngleRadians(y){return Math.abs(y)<=Q.smallAngleRadians}static isSmallAngleRadiansSquared(y){return Math.abs(y)<=Q.smallAngleRadiansSquared}static isAlmostEqualOptional(y,k,M){if(void 0!==y&&void 0!==k){if(Math.abs(y-k)>M)return!1}else if(void 0!==y||void 0!==k)return!1;return!0}static isAlmostEqualNumber(y,k,M=Q.smallAngleRadians){const b=1+Math.abs(y)+Math.abs(k);return Math.abs(y-k)<=M*b}static isAlmostEqualEitherNumber(y,k,M,b=Q.smallAngleRadians){return this.isAlmostEqualNumber(y,k,b)||this.isAlmostEqualNumber(y,M,b)}static isAlmostEqualXAndY(y,k,M=Q.smallAngleRadians){const b=M*(1+Math.abs(y.x)+Math.abs(k.x)+Math.abs(y.y)+Math.abs(k.y));return Math.abs(y.x-k.x)<=b&&Math.abs(y.y-k.y)<=b}static isDistanceWithinTol(y,k=Q.smallMetricDistance){return Math.abs(y)<=k}static isSmallMetricDistance(y){return Math.abs(y)<=Q.smallMetricDistance}static isSmallMetricDistanceSquared(y){return Math.abs(y)<=Q.smallMetricDistanceSquared}static cyclic3dAxis(y){if(y>=0)return y<3?y:y<6?y-3:y%3;const k=y+3;return k>=0?k:2-(-y-1)%3}static axisIndexToRightHandedAxisOrder(y){return 0===y?E.XYZ:1===y?E.YZX:2===y?E.ZXY:Q.axisIndexToRightHandedAxisOrder(Q.cyclic3dAxis(y))}static maxXYZ(y,k,M){let b=y;return k>b&&(b=k),M>b&&(b=M),b}static minXYZ(y,k,M){let b=y;return k<b&&(b=k),M<b&&(b=M),b}static maxXY(y,k){let M=y;return k>M&&(M=k),M}static minXY(y,k){let M=y;return k<M&&(M=k),M}static maxAbsXYZ(y,k,M){return Q.maxXYZ(Math.abs(y),Math.abs(k),Math.abs(M))}static maxAbsXY(y,k){return Q.maxXY(Math.abs(y),Math.abs(k))}static maxAbsDiff(y,k,M){return Math.max(Math.abs(y-k),Math.abs(y-M))}static split3WaySign(y,k,M,b){return y<0?k:y>0?b:M}static split3Way01(y,k=Q.smallMetricDistance){return y>k?1:y<-k?-1:0}static square(y){return y*y}static hypotenuseXY(y,k){return Math.sqrt(y*y+k*k)}static hypotenuseSquaredXY(y,k){return y*y+k*k}static hypotenuseXYZ(y,k,M){return Math.sqrt(y*y+k*k+M*M)}static hypotenuseSquaredXYZ(y,k,M){return y*y+k*k+M*M}static hypotenuseXYZW(y,k,M,b){return Math.sqrt(y*y+k*k+M*M+b*b)}static hypotenuseSquaredXYZW(y,k,M,b){return y*y+k*k+M*M+b*b}static distanceXYXY(y,k,M,b){return Q.hypotenuseXY(M-y,b-k)}static distanceXYZXYZ(y,k,M,b,E,D){return Q.hypotenuseXYZ(b-y,E-k,D-M)}static tripleProduct(y,k,M,b,E,D,R,X,z){return y*(E*z-D*X)+k*(D*R-b*z)+M*(b*X-E*R)}static determinant4x4(y,k,M,b,E,D,R,X,z,N,Y,O,B,V,U,L){return y*this.tripleProduct(D,R,X,N,Y,O,V,U,L)-E*this.tripleProduct(k,M,b,N,Y,O,V,U,L)+z*this.tripleProduct(k,M,b,D,R,X,V,U,L)-B*this.tripleProduct(k,M,b,D,R,X,N,Y,O)}static tripleProductXYW(y,k,M,b,E,D){return Q.tripleProduct(y.x,M.x,E.x,y.y,M.y,E.y,k,b,D)}static tripleProductPoint4dXYW(y,k,M){return Q.tripleProduct(y.x,k.x,M.x,y.y,k.y,M.y,y.w,k.w,M.w)}static crossProductXYXY(y,k,M,b){return y*b-k*M}static crossProductXYZXYZ(y,k,M,b,E,D,R){return $.create(k*D-M*E,M*b-y*D,y*E-k*b,R)}static crossProductMagnitude(y,k,M,b,E,D){return Q.hypotenuseXYZ(k*D-M*E,M*b-y*D,y*E-k*b)}static dotProductXYXY(y,k,M,b){return y*M+k*b}static dotProductXYZXYZ(y,k,M,b,E,D){return y*b+k*E+M*D}static meanCurvatureOfRadii(y,k){return.5*(this.safeDivideFraction(1,y,0)+this.safeDivideFraction(1,k,0))}static curvatureMagnitude(y,k,M,b,E,D){let R=k*D-M*E,X=R*R;R=M*b-y*D,X+=R*R,R=y*E-k*b,X+=R*R;const z=Math.sqrt(X),N=Math.sqrt(y*y+k*k+M*M),Y=N*N*N;return Y>Q.smallAngleRadians*z?z/Y:0}static clampToStartEnd(y,k,M){return k>M?Q.clampToStartEnd(y,M,k):y<k?k:M<y?M:y}static clamp(y,k,M){return Math.max(k,Math.min(M,y))}static resolveNumber(y,k=0){return void 0!==y?y:k}static resolveValue(y,k){return void 0!==y?y:k}static resolveToUndefined(y,k){return y===k?void 0:y}static interpolate(y,k,M){return k<=.5?y+k*(M-y):M-(1-k)*(M-y)}static interpolateByte(y,k,M,b){return y=y>>>b&255,M=M>>>b&255,(255&Math.floor(y+k*(M-y)))<<b}static interpolateColor(y,k,M){return k=Q.clamp(k,0,1),this.interpolateByte(y,k,M,0)|this.interpolateByte(y,k,M,8)|this.interpolateByte(y,k,M,16)|this.interpolateByte(y,k,M,24)}static axisOrderToAxis(y,k){const M=y<=E.ZXY?y+k:y-E.XZY-k;return Q.cyclic3dAxis(M)}static modulo(y,k){if(k<=0)return 0===k?y:-Q.modulo(-y,-k);if(y>=0){if(y<k)return y;if(y<2*k)return y-k}else if((y+=k)>0)return y;return y-Math.floor(y/k)*k}static defined01(y){return void 0===y?0:1}static conditionalDivideFraction(y,k){if(0!==k)return Math.abs(k)*Q.largeFractionResult>=Math.abs(y)?y/k:void 0}static safeDivideFraction(y,k,M){const b=Q.conditionalDivideFraction(y,k);return void 0!==b?b:M}static conditionalDivideCoordinate(y,k,M=Q.largeCoordinateResult){if(0!==k)return Math.abs(k*M)>=Math.abs(y)?y/k:void 0}static solveTrigForm(y,k,M){const b=k*k+M*M;let E;if(b>0){const D=1/b,R=1-y*y*D;if(R<-Q.smallMetricDistanceSquared)return E;const X=-y*D,z=X*k,N=X*M;if(R<=Q.smallMetricDistanceSquared)E=[J.create(z,N)];else{const y=Math.sqrt(R*D);E=[J.create(z-y*M,N+y*k),J.create(z+y*M,N-y*k)]}}return E}static inverseInterpolate(y,k,M,b,E=0,D){const R=Q.conditionalDivideFraction(E-k,b-k);return void 0!==R?Q.interpolate(y,R,M):D}static inverseInterpolate01(y,k,M=0){return Q.conditionalDivideFraction(M-y,k-y)}static isNumberArray(y,k=0){if(Array.isArray(y)&&y.length>=k){let k;for(k of y)if(!Number.isFinite(k))return!1;return!0}return!1}static isArrayOfNumberArray(y,k,M=0){if(Array.isArray(y)&&y.length>=k){let k;for(k of y)if(!Q.isNumberArray(k,M))return!1;return!0}return!1}static stepCount(y,k,M=1,b=101){if(y<=0)return M;if(y>=(k=Math.abs(k)))return M;const E=Math.floor((k+.999999*y)/y);return E<M?M:E>b?b:E}static isIn01(y,k=!0){return!k||y>=0&&y<=1}static isIn01WithTolerance(y,k){return y+(k=Math.abs(k))>=0&&y-k<=1}static restrictToInterval(y,k,M){return k<=M?y<k?k:y>M?M:y:y<M?M:y>k?k:y}static equalStringNoCase(y,k){return y.toUpperCase()===k.toUpperCase()}static exactEqualNumberArrays(y,k){if(Array.isArray(y)&&0===y.length&&(y=void 0),Array.isArray(k)&&0===k.length&&(k=void 0),void 0===y&&void 0===k)return!0;if(Array.isArray(y)&&Array.isArray(k)){if(y.length!==k.length)return!1;for(let M=0;M<y.length;M++)if(y[M]!==k[M])return!1;return!0}return!1}static almostEqualArrays(y,k,M){if(Array.isArray(y)&&0===y.length&&(y=void 0),Array.isArray(k)&&0===k.length&&(k=void 0),void 0===y&&void 0===k)return!0;if(Array.isArray(y)&&Array.isArray(k)){if(y.length!==k.length)return!1;for(let b=0;b<y.length;b++)if(!M(y[b],k[b]))return!1;return!0}return!1}static almostEqualNumberArrays(y,k,M){if(Array.isArray(y)&&0===y.length&&(y=void 0),Array.isArray(k)&&0===k.length&&(k=void 0),void 0===y&&void 0===k)return!0;if(Array.isArray(y)&&Array.isArray(k)){if(y.length!==k.length)return!1;for(let b=0;b<y.length;b++)if(!M(y[b],k[b]))return!1;return!0}return!1}static areEqualAllowUndefined(y,k,M=!0){return void 0===y&&void 0===k?M:void 0!==y&&void 0!==k&&y===k}static cloneMembers(y){if(void 0===y)return;const k=[];for(const M of y)k.push(M.clone());return k}static cloneArray(y){if(void 0===y)return;const k=[];for(const M of y)k.push(M.clone());return k}}Q.smallMetricDistance=1e-6,Q.smallMetricDistanceSquared=1e-12,Q.smallAngleRadians=1e-12,Q.smallAngleRadiansSquared=1e-24,Q.smallAngleDegrees=57e-12,Q.smallAngleSeconds=2e-7,Q.smallFraction=1e-10,Q.smallFloatingPoint=1e-15,Q.fullCircleRadiansMinusSmallAngle=2*Math.PI-Q.smallAngleRadians,Q.largeFractionResult=1e10,Q.largeCoordinateResult=1e13,Q.hugeCoordinate=1e12,function(y){y.almostEqual=function(y,k,M){return Q.isSameCoordinate(y.x,k.x,M)&&Q.isSameCoordinate(y.y,k.y,M)&&Q.isSameCoordinate(y.z,k.z,M)}}(N||(N={}));class K{set(y=0,k=0,M=0){this.x=y,this.y=k,this.z=M}setZero(){this.x=0,this.y=0,this.z=0}constructor(y=0,k=0,M=0){this.x=y,this.y=k,this.z=M}static isXAndY(y){return void 0!==y.x&&void 0!==y.y}static hasZ(y){return void 0!==y.z}static isXYAndZ(y){return this.isXAndY(y)&&this.hasZ(y)}static isAnyImmediatePointType(y){return j.isXAndY(y)||Q.isNumberArray(y,2)}static accessX(y,k){return void 0!==y.x?y.x:Array.isArray(y)&&y.length>0&&Number.isFinite(y[0])?y[0]:k}static accessY(y,k){return void 0!==y.y?y.y:Array.isArray(y)&&y.length>1&&Number.isFinite(y[1])?y[1]:k}static accessZ(y,k){return void 0!==y.z?y.z:Array.isArray(y)&&y.length>2&&Number.isFinite(y[2])?y[2]:k}setFrom(y){void 0===y?this.setZero():K.isXAndY(y)?(this.x=y.x,this.y=y.y,this.z=K.hasZ(y)?y.z:0):(this.x=y[0],this.y=y[1],this.z=y[2])}setFromPoint3d(y){y?(this.x=y.x,this.y=y.y,this.z=y.z):this.setZero()}setFromVector3d(y){y?(this.x=y.x,this.y=y.y,this.z=y.z):this.setZero()}isAlmostEqual(y,k){return N.almostEqual(this,y,k)}isAlmostEqualXYZ(y,k,M,b){return Q.isSameCoordinate(this.x,y,b)&&Q.isSameCoordinate(this.y,k,b)&&Q.isSameCoordinate(this.z,M,b)}isAlmostEqualPointPlusScaledVector(y,k,M,b){return Q.isSameCoordinate(this.x,y.x+k.x*M,b)&&Q.isSameCoordinate(this.y,y.y+k.y*M,b)&&Q.isSameCoordinate(this.z,y.z+k.z*M,b)}isAlmostEqualXY(y,k){return Q.isSameCoordinate(this.x,y.x,k)&&Q.isSameCoordinate(this.y,y.y,k)}toJSON(){return this.toArray()}toArray(){return[this.x,this.y,this.z]}toJSONXYZ(){return{x:this.x,y:this.y,z:this.z}}toFloat64Array(){return Float64Array.of(this.x,this.y,this.z)}setFromJSON(y){Array.isArray(y)?this.set(y[0]||0,y[1]||0,y[2]||0):y?this.set(y.x||0,y.y||0,y.z||0):this.set(0,0,0)}distance(y){const k=y.x-this.x,M=y.y-this.y,b=y.z-this.z;return Math.sqrt(k*k+M*M+b*b)}distanceSquared(y){const k=y.x-this.x,M=y.y-this.y,b=y.z-this.z;return k*k+M*M+b*b}distanceXY(y){const k=y.x-this.x,M=y.y-this.y;return Math.sqrt(k*k+M*M)}distanceSquaredXY(y){const k=y.x-this.x,M=y.y-this.y;return k*k+M*M}maxDiff(y){return Math.max(Math.abs(this.x-y.x),Math.abs(this.y-y.y),Math.abs(this.z-y.z))}at(y){return y<.5?this.x:y>1.5?this.z:this.y}setAt(y,k){y<.5?this.x=k:y>1.5?this.z=k:this.y=k}indexOfMaxAbs(){let y=0,k=Math.abs(this.x),M=Math.abs(this.y);return M>k&&(y=1,k=M),M=Math.abs(this.z),M>k&&(y=2),y}get isAlmostZero(){return Q.isSmallMetricDistance(this.x)&&Q.isSmallMetricDistance(this.y)&&Q.isSmallMetricDistance(this.z)}get isZero(){return 0===this.x&&0===this.y&&0===this.z}maxAbs(){return Math.max(Math.abs(this.x),Math.abs(this.y),Math.abs(this.z))}magnitude(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}magnitudeSquared(){return this.x*this.x+this.y*this.y+this.z*this.z}magnitudeXY(){return Math.sqrt(this.x*this.x+this.y*this.y)}magnitudeSquaredXY(){return this.x*this.x+this.y*this.y}isExactEqual(y){return this.x===y.x&&this.y===y.y&&this.z===y.z}isAlmostEqualMetric(y){return this.maxDiff(y)<=Q.smallMetricDistance}addInPlace(y){this.x+=y.x,this.y+=y.y,this.z+=y.z}subtractInPlace(y){this.x-=y.x,this.y-=y.y,this.z-=y.z}addScaledInPlace(y,k){this.x+=k*y.x,this.y+=k*y.y,this.z+=k*y.z}scaleInPlace(y){this.x*=y,this.y*=y,this.z*=y}addXYZInPlace(y=0,k=0,M=0){this.x+=y,this.y+=k,this.z+=M}cloneAsPoint3d(){return j.create(this.x,this.y,this.z)}vectorTo(y,k){return $.create(y.x-this.x,y.y-this.y,y.z-this.z,k)}scaledVectorTo(y,k,M){return $.create(k*(y.x-this.x),k*(y.y-this.y),k*(y.z-this.z),M)}unitVectorTo(y,k){return this.vectorTo(y,k).normalize(k)}freeze(){return Object.freeze(this)}static x(y,k=0){return void 0===y?k:Array.isArray(y)?y[0]:void 0!==y.x?y.x:k}static y(y,k=0){return void 0===y?k:Array.isArray(y)?y[1]:void 0!==y.y?y.y:k}static z(y,k=0){return void 0===y?k:Array.isArray(y)?y[2]:void 0!==y.z?y.z:k}}class j extends K{constructor(y=0,k=0,M=0){super(y,k,M)}static fromJSON(y){const k=new j;return k.setFromJSON(y),k}clone(y){return j.create(this.x,this.y,this.z,y)}static create(y=0,k=0,M=0,b){return b?(b.x=y,b.y=k,b.z=M,b):new j(y,k,M)}static createFrom(y,k){if(y instanceof Float64Array){let M=0,b=0,E=0;return y.length>0&&(M=y[0]),y.length>1&&(b=y[1]),y.length>2&&(E=y[2]),j.create(M,b,E,k)}return j.create(y.x,y.y,K.hasZ(y)?y.z:0,k)}static createFromPacked(y,k,M){const b=3*k;if(b>=0&&b+2<y.length)return j.create(y[b],y[b+1],y[b+2],M)}static createFromPackedXYZW(y,k,M){const b=4*k;if(b>=0&&b+3<y.length){const k=y[b+3];if(!Q.isSmallMetricDistance(k)){const E=1/k;return j.create(E*y[b],E*y[b+1],E*y[b+2],M)}}}static createArrayFromPackedXYZ(y){const k=[];for(let M=0;M+2<y.length;M+=3)k.push(new j(y[M],y[M+1],y[M+2]));return k}static createZero(y){return j.create(0,0,0,y)}crossProductToPoints(y,k,M){return $.createCrossProduct(y.x-this.x,y.y-this.y,y.z-this.z,k.x-this.x,k.y-this.y,k.z-this.z,M)}crossProductToPointsMagnitude(y,k){return Q.crossProductMagnitude(y.x-this.x,y.y-this.y,y.z-this.z,k.x-this.x,k.y-this.y,k.z-this.z)}tripleProductToPoints(y,k,M){return Q.tripleProduct(y.x-this.x,y.y-this.y,y.z-this.z,k.x-this.x,k.y-this.y,k.z-this.z,M.x-this.x,M.y-this.y,M.z-this.z)}crossProductToPointsXY(y,k){return Q.crossProductXYXY(y.x-this.x,y.y-this.y,k.x-this.x,k.y-this.y)}interpolate(y,k,M){if(y<=.5)return j.create(this.x+y*(k.x-this.x),this.y+y*(k.y-this.y),this.z+y*(k.z-this.z),M);const b=y-1;return j.create(k.x+b*(k.x-this.x),k.y+b*(k.y-this.y),k.z+b*(k.z-this.z),M)}interpolateXYZ(y,k,M,b,E){return j.create(Q.interpolate(this.x,y,b.x),Q.interpolate(this.y,k,b.y),Q.interpolate(this.z,M,b.z),E)}interpolatePerpendicularXY(y,k,M,b){b=b||new j;const E=k.minus(this);return this.interpolate(y,k,b),b.x-=M*E.y,b.y+=M*E.x,b}minus(y,k){return j.create(this.x-y.x,this.y-y.y,this.z-y.z,k)}plus(y,k){return j.create(this.x+y.x,this.y+y.y,this.z+y.z,k)}plusXYZ(y=0,k=0,M=0,b){return j.create(this.x+y,this.y+k,this.z+M,b)}plusScaled(y,k,M){return j.create(this.x+y.x*k,this.y+y.y*k,this.z+y.z*k,M)}plus2Scaled(y,k,M,b,E){return j.create(this.x+y.x*k+M.x*b,this.y+y.y*k+M.y*b,this.z+y.z*k+M.z*b,E)}plus3Scaled(y,k,M,b,E,D,R){return j.create(this.x+y.x*k+M.x*b+E.x*D,this.y+y.y*k+M.y*b+E.y*D,this.z+y.z*k+M.z*b+E.z*D,R)}static createScale(y,k,M){return j.create(y.x*k,y.y*k,y.z*k,M)}static createAdd2Scaled(y,k,M,b,E){return j.create(y.x*k+M.x*b,y.y*k+M.y*b,y.z*k+M.z*b,E)}static createAdd3Scaled(y,k,M,b,E,D,R){return j.create(y.x*k+M.x*b+E.x*D,y.y*k+M.y*b+E.y*D,y.z*k+M.z*b+E.z*D,R)}dotVectorsToTargets(y,k){return(y.x-this.x)*(k.x-this.x)+(y.y-this.y)*(k.y-this.y)+(y.z-this.z)*(k.z-this.z)}fractionOfProjectionToLine(y,k,M=0){const b=y.distanceSquared(k);return b<Q.smallMetricDistanceSquared?M:y.dotVectorsToTargets(k,this)/b}}class $ extends K{constructor(y=0,k=0,M=0){super(y,k,M)}static createArrayFromPackedXYZ(y){const k=[];for(let M=0;M+2<y.length;M+=3)k.push(new $(y[M],y[M+1],y[M+2]));return k}clone(y){return $.create(this.x,this.y,this.z,y)}static create(y=0,k=0,M=0,b){return b?(b.x=y,b.y=k,b.z=M,b):new $(y,k,M)}static createCrossProduct(y,k,M,b,E,D,R){return $.create(k*D-M*E,M*b-y*D,y*E-k*b,R)}addCrossProductToTargetsInPlace(y,k,M,b,E,D,R,X,z){const N=b-y,Y=E-k,O=D-M,B=R-y,V=X-k,U=z-M;this.x+=Y*U-O*V,this.y+=O*B-N*U,this.z+=N*V-Y*B}static createCrossProductToPoints(y,k,M,b){return $.createCrossProduct(k.x-y.x,k.y-y.y,k.z-y.z,M.x-y.x,M.y-y.y,M.z-y.z,b)}static createUnitCrossProductToPoints(y,k,M,b){return $.createCrossProduct(k.x-y.x,k.y-y.y,k.z-y.z,M.x-y.x,M.y-y.y,M.z-y.z,b).normalize()}static createPolar(y,k,M){return $.create(y*k.cos(),y*k.sin(),M)}static createSpherical(y,k,M){const b=M.cos();return $.create(b*y*k.cos(),b*y*k.sin(),y*M.sin())}static fromJSON(y){const k=new $;return k.setFromJSON(y),k}static createFrom(y,k){if(y instanceof Float64Array){let M=0,b=0,E=0;return y.length>0&&(M=y[0]),y.length>1&&(b=y[1]),y.length>2&&(E=y[2]),$.create(M,b,E,k)}return Array.isArray(y)?$.create(y[0],y[1],y.length>2?y[2]:0):$.create(y.x,y.y,K.hasZ(y)?y.z:0,k)}static createStartEnd(y,k,M){const b=K.accessZ(y,0),E=K.accessZ(k,0)-b;return M?(M.set(k.x-y.x,k.y-y.y,E),M):new $(k.x-y.x,k.y-y.y,E)}static createStartEndXYZXYZ(y,k,M,b,E,D,R){return this.create(b-y,E-k,D-M,R)}static createRotateVectorAroundVector(y,k,M){const b=k.normalize();if(b){const k=b.crossProduct(y);let E,D;return M?(E=M.cos(),D=M.sin()):(E=0,D=1),$.createAdd3Scaled(y,E,k,D,b,b.dotProduct(y)*(1-E))}}setStartEnd(y,k){this.x=k.x-y.x,this.y=k.y-y.y,this.z=k.z-y.z}static createZero(y){return $.create(0,0,0,y)}static unitX(y=1){return new $(y,0,0)}static unitY(y=1){return new $(0,y,0)}static unitZ(y=1){return new $(0,0,y)}safeDivideOrNull(y,k){if(0!==y)return this.scale(1/y,k)}normalizeWithLength(y){const k=this.magnitude(),M=Q.correctSmallFraction(k);return y=y||new $,{v:this.safeDivideOrNull(M,y),mag:k}}normalize(y){return this.normalizeWithLength(y).v}normalizeInPlace(){return void 0!==this.normalizeWithLength(this).v}static createNormalized(y=0,k=0,M=0,b){if(void 0===b?b=$.create(y,k,M):b.set(y,k,M),b.normalizeInPlace())return b}static createNormalizedStartEnd(y,k,M){if((M=$.createStartEnd(y,k,M)).normalizeInPlace())return M}fractionOfProjectionToVector(y,k=0){const M=y.magnitudeSquared();return M<Q.smallMetricDistanceSquared?k:this.dotProduct(y)/M}negate(y){return(y=y||new $).x=-this.x,y.y=-this.y,y.z=-this.z,y}rotate90CCWXY(y){y=y||new $;const k=this.x,M=this.y;return y.x=-M,y.y=k,y.z=this.z,y}rotate90CWXY(y){y=y||new $;const k=this.x,M=this.y;return y.x=M,y.y=-k,y.z=this.z,y}unitPerpendicularXY(y){y=y||new $;const k=this.x,M=this.y;y.x=-M,y.y=k,y.z=0;const b=k*k+M*M;if(0!==b){const k=1/Math.sqrt(b);y.x*=k,y.y*=k}return y}rotateXY(y,k){const M=y.sin(),b=y.cos(),E=this.x,D=this.y;return(k=k||new $).x=E*b-D*M,k.y=E*M+D*b,k.z=this.z,k}rotate90Towards(y,k){const M=this.crossProduct(y).normalize();return M?M.crossProduct(this,k):void 0}rotate90Around(y,k){const M=y.normalize();return M?M.crossProduct(this).plusScaled(M,M.dotProduct(this),k):void 0}interpolate(y,k,M){if(M=M||new $,y<=.5)M.x=this.x+y*(k.x-this.x),M.y=this.y+y*(k.y-this.y),M.z=this.z+y*(k.z-this.z);else{const b=y-1;M.x=k.x+b*(k.x-this.x),M.y=k.y+b*(k.y-this.y),M.z=k.z+b*(k.z-this.z)}return M}plus(y,k){return(k=k||new $).x=this.x+y.x,k.y=this.y+y.y,k.z=this.z+y.z,k}minus(y,k){return(k=k||new $).x=this.x-y.x,k.y=this.y-y.y,k.z=this.z-y.z,k}plusScaled(y,k,M){return(M=M||new $).x=this.x+y.x*k,M.y=this.y+y.y*k,M.z=this.z+y.z*k,M}plus2Scaled(y,k,M,b,E){return(E=E||new $).x=this.x+y.x*k+M.x*b,E.y=this.y+y.y*k+M.y*b,E.z=this.z+y.z*k+M.z*b,E}plus3Scaled(y,k,M,b,E,D,R){return(R=R||new $).x=this.x+y.x*k+M.x*b+E.x*D,R.y=this.y+y.y*k+M.y*b+E.y*D,R.z=this.z+y.z*k+M.z*b+E.z*D,R}static createAdd2Scaled(y,k,M,b,E){return $.create(y.x*k+M.x*b,y.y*k+M.y*b,y.z*k+M.z*b,E)}static createAdd2ScaledXYZ(y,k,M,b,E,D,R,X,z){return $.create(y*b+E*X,k*b+D*X,M*b+R*X,z)}static createAdd3Scaled(y,k,M,b,E,D,R){return $.create(y.x*k+M.x*b+E.x*D,y.y*k+M.y*b+E.y*D,y.z*k+M.z*b+E.z*D,R)}scale(y,k){return(k=k||new $).x=this.x*y,k.y=this.y*y,k.z=this.z*y,k}scaleToLength(y,k){const M=Q.correctSmallFraction(this.magnitude());if(0!==M)return this.scale(y/M,k)}unitCrossProduct(y,k){return this.crossProduct(y,k).normalize(k)}unitCrossProductWithDefault(y,k,M,b,E){const D=this.crossProduct(y,E).normalize(E);return void 0===D?$.create(k,M,b,E):D}normalizeWithDefault(y,k,M,b){return this.normalize(b)||((b=$.create(y,k,M,b)).normalizeInPlace()?b:$.create(1,0,0,b))}tryNormalizeInPlace(y=Q.smallFraction){const k=this.magnitude();return!(k<y||0===k||(this.scaleInPlace(1/k),0))}sizedCrossProduct(y,k,M){if((M=this.crossProduct(y,M)).tryNormalizeInPlace())return M.scaleInPlace(k),M}crossProductMagnitudeSquared(y){const k=this.y*y.z-this.z*y.y,M=this.z*y.x-this.x*y.z,b=this.x*y.y-this.y*y.x;return k*k+M*M+b*b}crossProductMagnitude(y){return Math.sqrt(this.crossProductMagnitudeSquared(y))}dotProduct(y){return this.x*y.x+this.y*y.y+this.z*y.z}static dotProductAsXYAndZ(y,k){return y.x*k.x+y.y*k.y+y.z*k.z}dotProductStartEnd(y,k){return this.x*(k.x-y.x)+this.y*(k.y-y.y)+this.z*(k.z-y.z)}dotProductStart3dEnd4d(y,k){const M=k.w;return this.x*(k.x-y.x*M)+this.y*(k.y-y.y*M)+this.z*(k.z-y.z*M)}crossProductStartEnd(y,k,M){return $.createCrossProduct(this.x,this.y,this.z,k.x-y.x,k.y-y.y,k.z-y.z,M)}crossProductStartEndXY(y,k){return Q.crossProductXYXY(this.x,this.y,k.x-y.x,k.y-y.y)}dotProductStartEndXYZ(y,k,M,b){return this.x*(k-y.x)+this.y*(M-y.y)+this.z*(b-y.z)}dotProductStartEndXY(y,k){return this.x*(k.x-y.x)+this.y*(k.y-y.y)}dotProductStartEndXYZW(y,k,M,b,E){if(Q.isSmallMetricDistance(E))return 0;const D=1/E;return this.x*(D*k-y.x)+this.y*(D*M-y.y)+this.z*(D*b-y.z)}dotProductXY(y){return this.x*y.x+this.y*y.y}dotProductXYZ(y,k,M=0){return this.x*y+this.y*k+this.z*M}tripleProduct(y,k){return Q.tripleProduct(this.x,this.y,this.z,y.x,y.y,y.z,k.x,k.y,k.z)}crossProductXY(y){return this.x*y.y-this.y*y.x}crossProduct(y,k){return $.createCrossProduct(this.x,this.y,this.z,y.x,y.y,y.z,k)}crossProductXYZ(y,k,M,b){return $.createCrossProduct(this.x,this.y,this.z,y,k,M,b)}radiansTo(y){return Math.atan2(this.crossProductMagnitude(y),this.dotProduct(y))}angleTo(y){return W.createRadians(this.radiansTo(y))}angleFromPerpendicular(y){return W.createAtan2(this.dotProduct(y),this.crossProductMagnitude(y))}radiansFromPerpendicular(y){return Math.atan2(this.dotProduct(y),this.crossProductMagnitude(y))}angleToXY(y){return W.createAtan2(this.crossProductXY(y),this.dotProductXY(y))}signedRadiansTo(y,k){const M=this.crossProduct(y),b=Math.atan2(M.magnitude(),this.dotProduct(y));return k.dotProduct(M)<0?-b:b}signedAngleTo(y,k){return W.createRadians(this.signedRadiansTo(y,k))}planarRadiansTo(y,k){const M=k.dotProduct(k);if(0===M)return 0;const b=1/M,E=this.plusScaled(k,-this.dotProduct(k)*b),D=y.plusScaled(k,-y.dotProduct(k)*b);return E.signedRadiansTo(D,k)}planarAngleTo(y,k){return W.createRadians(this.planarRadiansTo(y,k))}smallerUnorientedRadiansTo(y){const k=this.dotProduct(y),M=this.crossProductMagnitude(y);return Math.atan2(Math.abs(M),Math.abs(k))}smallerUnorientedAngleTo(y){return W.createRadians(this.smallerUnorientedRadiansTo(y))}isParallelTo(y,k=!1,M=!1,b){const E=b?.radianSquaredTol??Q.smallAngleRadiansSquared,D=b?.distanceSquaredTol??Q.smallMetricDistanceSquared,R=this.magnitudeSquared(),X=y.magnitudeSquared();return R<D||X<D?M:!(this.dotProduct(y)<0&&!k)&&this.crossProductMagnitudeSquared(y)<=E*R*X}isPerpendicularTo(y,k=!1,M){const b=M?.radianSquaredTol??Q.smallAngleRadiansSquared,E=M?.distanceSquaredTol??Q.smallMetricDistanceSquared,D=this.magnitudeSquared(),R=y.magnitudeSquared();if(D<E||R<E)return k;const X=this.dotProduct(y);return X*X<=b*D*R}}class tt{isPointInPlane(y,k=Q.smallMetricDistance){return Math.abs(this.altitude(y))<=k}classifyAltitude(y,k=Q.smallMetricDistance){return Q.split3Way01(this.altitude(y),k)}classifyAltitudeXYZ(y,k,M,b=Q.smallMetricDistance){return Q.split3Way01(this.altitudeXYZ(y,k,M),b)}getUnitNormal(y){return $.createNormalized(this.normalX(),this.normalY(),this.normalZ(),y)}getAnyPointOnPlane(y){return this.projectPointToPlane(j.create(0,0,0),y)}}class et{constructor(y){this._curIndex=-1,this._collection=y}next(){return++this._curIndex>=this._collection.length?{done:!0}:{value:this._collection.getPoint3dAtUncheckedPointIndex(this._curIndex),done:!1}}[Symbol.iterator](){return this}}class it{vectorIndexXYAndZ(y,k,M){const b=this.vectorXYAndZIndex(k,y,M);return b?.negate(b)}dotProductIndexIndexIndex(y,k,M){if(y<0||y>=this.length||k<0||k>=this.length||M<0||M>=this.length)return;const b=this.getXAtUncheckedPointIndex(y),E=this.getYAtUncheckedPointIndex(y),D=this.getZAtUncheckedPointIndex(y);return(this.getXAtUncheckedPointIndex(k)-b)*(this.getXAtUncheckedPointIndex(M)-b)+(this.getYAtUncheckedPointIndex(k)-E)*(this.getYAtUncheckedPointIndex(M)-E)+(this.getZAtUncheckedPointIndex(k)-D)*(this.getZAtUncheckedPointIndex(M)-D)}dotProductIndexIndexXYAndZ(y,k,M){if(y<0||y>=this.length||k<0||k>=this.length)return;const b=this.getXAtUncheckedPointIndex(y),E=this.getYAtUncheckedPointIndex(y),D=this.getZAtUncheckedPointIndex(y);return(this.getXAtUncheckedPointIndex(k)-b)*(M.x-b)+(this.getYAtUncheckedPointIndex(k)-E)*(M.y-E)+(this.getZAtUncheckedPointIndex(k)-D)*(M.z-D)}crossProductIndexIndexXYAndZ(y,k,M,b){if(y<0||y>=this.length||k<0||k>=this.length)return;const E=this.getXAtUncheckedPointIndex(y),D=this.getYAtUncheckedPointIndex(y),R=this.getZAtUncheckedPointIndex(y);return $.createCrossProduct(this.getXAtUncheckedPointIndex(k)-E,this.getYAtUncheckedPointIndex(k)-D,this.getZAtUncheckedPointIndex(k)-R,M.x-E,M.y-D,M.z-R,b)}distanceSquaredIndexXYAndZ(y,k){if(!(y<0||y>=this.length))return Q.hypotenuseSquaredXYZ(k.x-this.getXAtUncheckedPointIndex(y),k.y-this.getYAtUncheckedPointIndex(y),k.z-this.getZAtUncheckedPointIndex(y))}cyclicIndex(y){return y%this.length}getRange(){const y=ut.createNull(),k=this.length,M=j.create();for(let b=0;b<k;b++)this.getPoint3dAtUncheckedPointIndex(b,M),y.extendPoint(M);return y}findOrderedDuplicates(y=Q.smallMetricDistance){const k=y*y,M=[];if(this.length>1)for(let b=0;b<this.length-1;){let y=b+1;for(;y<this.length;++y){const E=this.distanceSquaredIndexIndex(b,y);if(!(void 0!==E&&E<k))break;M.push(y)}b=y}return M}linearCombination(y,k){const M=Math.min(this.length,y.length),b=k instanceof $?$.createZero(k):j.createZero(k);for(let E=0;E<M;++E)b.x+=y[E]*this.getXAtUncheckedPointIndex(E),b.y+=y[E]*this.getYAtUncheckedPointIndex(E),b.z+=y[E]*this.getZAtUncheckedPointIndex(E);return b}interpolateIndexIndex(y,k,M,b){if(!(y<0||y>=this.length||M<0||M>=this.length))return j.create(Q.interpolate(this.getXAtUncheckedPointIndex(y),k,this.getXAtUncheckedPointIndex(M)),Q.interpolate(this.getYAtUncheckedPointIndex(y),k,this.getYAtUncheckedPointIndex(M)),Q.interpolate(this.getZAtUncheckedPointIndex(y),k,this.getZAtUncheckedPointIndex(M)),b)}get points(){return new et(this)}getArray(){const y=[];for(const k of this.points)y.push(k);return y}front(y){if(0!==this.length)return this.getPoint3dAtUncheckedPointIndex(0,y)}back(y){if(0!==this.length)return this.getPoint3dAtUncheckedPointIndex(this.length-1,y)}almostEqualIndexIndex(y,k,M=Q.smallMetricDistance){if(!(y<0||y>=this.length||k<0||k>=this.length))return Q.isSameCoordinate(this.getXAtUncheckedPointIndex(y),this.getXAtUncheckedPointIndex(k),M)&&Q.isSameCoordinate(this.getYAtUncheckedPointIndex(y),this.getYAtUncheckedPointIndex(k),M)&&Q.isSameCoordinate(this.getZAtUncheckedPointIndex(y),this.getZAtUncheckedPointIndex(k),M)}}class st extends it{}class nt extends st{constructor(y=8,k){super(),this._data=new Float64Array(3*y),this._xyzInUse=0,this._xyzCapacity=y,this._growthFactor=void 0!==k&&k>=1?k:1.5}copyData(y,k,M){let b=void 0!==M?3*M:0;if(b<0&&(b=0),b>=this._data.length)return{count:0,offset:0};let E=void 0!==k?3*k:y.length;return E>0&&(E>y.length&&(E=y.length),b+E>this._data.length&&(E=this._data.length-b),E%3!=0&&(E-=E%3)),E<=0?{count:0,offset:0}:(E===y.length?this._data.set(y,b):y instanceof Float64Array?this._data.set(y.subarray(0,E),b):this._data.set(y.slice(0,E),b),{count:E/3,offset:b/3})}get length(){return this._xyzInUse}set length(y){this.resize(y,!0)}get float64Length(){return 3*this._xyzInUse}float64Data(){return this._data}ensureCapacity(y,k=!0){if(y>this._xyzCapacity){k&&(y*=this._growthFactor);const M=this._data;this._data=new Float64Array(3*y),this.copyData(M,this._xyzInUse),this._xyzCapacity=y}}resize(y,k){y>=0&&y<this._xyzInUse?this._xyzInUse=y:y>this._xyzInUse&&(this.ensureCapacity(y,!1),k&&this._data.fill(0,3*this._xyzInUse),this._xyzInUse=y)}clone(y){return y?(y.length!==this.length&&y.clear(),y.resize(this.length)):y=new nt(this.length),y.copyData(this._data,this.length),y._xyzInUse=this.length,y}static create(y,k){if(k)k.clear();else{const M="number"==typeof y[0]?y.length/3:y.length;k=new nt(M)}return k.pushFrom(y),k}static createArrayOfGrowableXYZArray(y){const k=new at;return ht.streamXYZ(y,k),k.claimArrayOfGrowableXYZArray()}push(y){this.pushXYZ(y.x,y.y,y.z)}pushAll(y){this.ensureCapacity(this._xyzInUse+y.length,!1);for(const k of y)this.push(k)}pushFrom(y){if(y instanceof j)this.pushXYZ(y.x,y.y,y.z);else if(y instanceof nt)this.pushFromGrowableXYZArray(y);else if(y instanceof H)this.pushXYZ(y.x,y.y,0);else if(Q.isNumberArray(y,4)||y instanceof Float64Array){const k=Math.trunc(y.length/3);this.ensureCapacity(this._xyzInUse+k,!1),this.copyData(y,k,this._xyzInUse),this._xyzInUse+=k}else if(Q.isNumberArray(y,3))this.pushXYZ(y[0],y[1],y[2]);else if(Q.isNumberArray(y,2))this.pushXYZ(y[0],y[1],0);else if(Array.isArray(y))for(const k of y)this.pushFrom(k);else if(j.isXYAndZ(y))this.pushXYZ(y.x,y.y,y.z);else if(j.isXAndY(y))this.pushXYZ(y.x,y.y,0);else if(y instanceof it){const k=y.length;this.ensureCapacity(this._xyzInUse+k,!1);for(let M=0;M<k;M++)this.pushXYZ(y.getXAtUncheckedPointIndex(M),y.getYAtUncheckedPointIndex(M),y.getZAtUncheckedPointIndex(M))}}pushWrap(y){if(this._xyzInUse>=y){this.ensureCapacity(this._xyzInUse+y,!1);for(let k=0;k<y;k++){const y=3*k;this.pushXYZ(this._data[y],this._data[y+1],this._data[y+2])}}}pushXYZ(y,k,M){this.ensureCapacity(this._xyzInUse+1);const b=3*this._xyzInUse;this._data[b]=y,this._data[b+1]=k,this._data[b+2]=M,this._xyzInUse++}shiftForward(y){if(y<=0)return;this.ensureCapacity(this._xyzInUse+y);const k=3*y,M=3*this._xyzInUse;this._data.copyWithin(k,0,M),this._xyzInUse+=y}pushFrontXYZ(y,k,M){this.shiftForward(1),this._data[0]=y,this._data[1]=k,this._data[2]=M}pushFront(y){this.pushFrontXYZ(y.x,y.y,y.z)}moveIndexToIndex(y,k){if(this.isIndexValid(y)&&this.isIndexValid(k)){let M=3*y,b=3*k;this._data[b++]=this._data[M++],this._data[b++]=this._data[M++],this._data[b]=this._data[M]}}pop(){this._xyzInUse>0&&this._xyzInUse--}isIndexValid(y){return!(y>=this._xyzInUse||y<0)}clear(){this._xyzInUse=0}getPoint3dAtUncheckedPointIndex(y,k){const M=3*y;return j.create(this._data[M],this._data[M+1],this._data[M+2],k)}getPoint2dAtUncheckedPointIndex(y,k){const M=3*y;return H.create(this._data[M],this._data[M+1],k)}getVector3dAtUncheckedVectorIndex(y,k){const M=3*y;return $.create(this._data[M],this._data[M+1],this._data[M+2],k)}getPoint3dAtCheckedPointIndex(y,k){if(this.isIndexValid(y)){const M=3*y;return j.create(this._data[M],this._data[M+1],this._data[M+2],k)}}getXAtUncheckedPointIndex(y){const k=3*y;return this._data[k]}getYAtUncheckedPointIndex(y){const k=3*y;return this._data[k+1]}getZAtUncheckedPointIndex(y){const k=3*y;return this._data[k+2]}getPoint2dAtCheckedPointIndex(y,k){if(this.isIndexValid(y)){const M=3*y;return H.create(this._data[M],this._data[M+1],k)}}getVector3dAtCheckedVectorIndex(y,k){if(this.isIndexValid(y)){const M=3*y;return $.create(this._data[M],this._data[M+1],this._data[M+2],k)}}transferFromGrowableXYZArray(y,k,M){if(this.isIndexValid(y)&&k.isIndexValid(M)){const b=3*y,E=3*M;return this._data[b]=k._data[E],this._data[b+1]=k._data[E+1],this._data[b+2]=k._data[E+2],!0}return!1}pushFromGrowableXYZArray(y,k){if(void 0===k){const k=y.length;return this.ensureCapacity(this.length+k,!1),this.copyData(y._data,k,this.length),this._xyzInUse+=k,k}if(y.isIndexValid(k)){const M=3*k;return this.pushXYZ(y._data[M],y._data[M+1],y._data[M+2]),1}return 0}setAtCheckedPointIndex(y,k){if(!this.isIndexValid(y))return!1;let M=3*y;return this._data[M++]=k.x,this._data[M++]=k.y,this._data[M]=k.z,!0}setXYZAtCheckedPointIndex(y,k,M,b){if(!this.isIndexValid(y))return!1;let E=3*y;return this._data[E++]=k,this._data[E++]=M,this._data[E]=b,!0}getPoint3dArray(){const y=3*this._xyzInUse,k=[],M=this._data;for(let b=0;b<y;b+=3)k.push(j.create(M[b],M[b+1],M[b+2]));return k}static multiplyTransformInPlace(y,k){if(Array.isArray(k))for(const M of k)M.multiplyTransformInPlace(y);else k.multiplyTransformInPlace(y)}multiplyTransformInPlace(y){const k=this._data,M=this.float64Length,b=y.matrix.coffs,E=y.origin,D=E.x,R=E.y,X=E.z;let z=0,N=0,Y=0;for(let O=0;O+2<=M;O+=3)z=k[O],N=k[O+1],Y=k[O+2],k[O]=b[0]*z+b[1]*N+b[2]*Y+D,k[O+1]=b[3]*z+b[4]*N+b[5]*Y+R,k[O+2]=b[6]*z+b[7]*N+b[8]*Y+X}reverseInPlace(){const y=this.length;let k,M,b;const E=this._data;for(let D=0,R=y-1;D<R;D++,R--)k=3*D,M=3*R,b=E[k],E[k]=E[M],E[M]=b,k++,M++,b=E[k],E[k]=E[M],E[M]=b,k++,M++,b=E[k],E[k]=E[M],E[M]=b}multiplyMatrix3dInPlace(y){const k=this._data,M=this.float64Length,b=y.coffs;let E=0,D=0,R=0;for(let X=0;X+2<=M;X+=3)E=k[X],D=k[X+1],R=k[X+2],k[X]=b[0]*E+b[1]*D+b[2]*R,k[X+1]=b[3]*E+b[4]*D+b[5]*R,k[X+2]=b[6]*E+b[7]*D+b[8]*R}multiplyAndRenormalizeMatrix3dInverseTransposeInPlace(y){const k=this._data,M=this.float64Length;if(!y.computeCachedInverse(!0))return!1;const b=y.inverseCoffs,E=Q.smallFloatingPoint;let D,R,X,z,N,Y=0,O=0,B=0,V=0;for(let U=0;U+2<=M;U+=3)Y=k[U],O=k[U+1],B=k[U+2],D=b[0]*Y+b[3]*O+b[6]*B,R=b[1]*Y+b[4]*O+b[7]*B,X=b[2]*Y+b[5]*O+b[8]*B,N=D*D+R*R+X*X,N<E?(D=Y,R=O,X=B,V++):Math.abs(N-1)>E&&(z=1/Math.sqrt(N),D*=z,R*=z,X*=z),k[U]=D,k[U+1]=R,k[U+2]=X;return 0===V}multiplyMatrix4dAndQuietRenormalizeMatrix4d(y){const k=this._data,M=this.float64Length,b=j.create();for(let E=0;E+2<=M;E+=3)y.multiplyXYZWQuietRenormalize(k[E],k[E+1],k[E+2],1,b),k[E]=b.x,k[E+1]=b.y,k[E+2]=b.z}tryTransformInverseInPlace(y){const k=this._data,M=this.float64Length,b=y.matrix;b.computeCachedInverse(!0);const E=b.inverseCoffs;if(!E)return!1;const D=y.origin,R=D.x,X=D.y,z=D.z;let N=0,Y=0,O=0;for(let B=0;B+2<M;B+=3)N=k[B]-R,Y=k[B+1]-X,O=k[B+2]-z,k[B]=E[0]*N+E[1]*Y+E[2]*O,k[B+1]=E[3]*N+E[4]*Y+E[5]*O,k[B+2]=E[6]*N+E[7]*Y+E[8]*O;return!0}extendRange(y,k){const M=this.float64Length,b=this._data;if(k)for(let E=0;E+2<M;E+=3)y.extendTransformedXYZ(k,b[E],b[E+1],b[E+2]);else for(let E=0;E+2<M;E+=3)y.extendXYZ(b[E],b[E+1],b[E+2])}getRange(y){const k=ut.createNull();return this.extendRange(k,y),k}setRange(y,k){y.setNull(),this.extendRange(y,k)}sumLengths(){let y=0;const k=3*(this._xyzInUse-1),M=this._data;for(let b=0;b<k;b+=3)y+=Q.hypotenuseXYZ(M[b+3]-M[b],M[b+4]-M[b+1],M[b+5]-M[b+2]);return y}scaleInPlace(y){if(this._data){const k=this.float64Length;for(let M=0;M<k;M++)this._data[M]=this._data[M]*y}}isCloseToPlane(y,k=Q.smallMetricDistance){const M=3*this._xyzInUse,b=this._data;for(let E=0;E<M;E+=3)if(Math.abs(y.altitudeXYZ(b[E],b[E+1],b[E+2]))>k)return!1;return!0}forceClosure(y=Q.smallMetricDistance){const k=this.distanceIndexIndex(0,this.length-1);if(void 0===k);else if(k>y)this.pushXYZ(this._data[0],this._data[1],this._data[2]);else if(k>0){const y=this._data.length-3;for(let k=0;k<3;k++)this._data[y+k]=this._data[k]}}interpolate(y,k,M,b){if(this.isIndexValid(y)&&this.isIndexValid(M)){const E=1-k,D=this._data;return y*=3,M*=3,j.create(E*D[y]+k*D[M],E*D[y+1]+k*D[M+1],E*D[y+2]+k*D[M+2],b)}}pushInterpolatedFromGrowableXYZArray(y,k,M,b){if(y.isIndexValid(k)&&y.isIndexValid(b)){const E=1-M,D=y._data;k*=3,b*=3,this.pushXYZ(E*D[k]+M*D[b],E*D[k+1]+M*D[b+1],E*D[k+2]+M*D[b+2])}}areaXY(){let y=0;const k=3*this._xyzInUse;if(k>6){const M=this._data[k-3],b=this._data[k-2];let E=this._data[0]-M,D=this._data[1]-b,R=0,X=0;for(let z=3;z<k;z+=3,E=R,D=X)R=this._data[z]-M,X=this._data[z+1]-b,y+=Q.crossProductXYXY(E,D,R,X)}return.5*y}vectorIndexIndex(y,k,M){if(!this.isIndexValid(y)||!this.isIndexValid(k))return;const b=this._data;return y*=3,k*=3,$.create(b[k]-b[y],b[k+1]-b[y+1],b[k+2]-b[y+2],M)}vectorXYAndZIndex(y,k,M){if(this.isIndexValid(k)){const b=this._data;return k*=3,$.create(b[k]-y.x,b[k+1]-y.y,b[k+2]-y.z,M)}}crossProductIndexIndexIndex(y,k,M,b){if(this.isIndexValid(y)&&this.isIndexValid(k)&&this.isIndexValid(M)){const E=3*y,D=3*k,R=3*M,X=this._data;return Q.crossProductXYZXYZ(X[D]-X[E],X[D+1]-X[E+1],X[D+2]-X[E+2],X[R]-X[E],X[R+1]-X[E+1],X[R+2]-X[E+2],b)}}evaluateUncheckedIndexDotProductXYZ(y,k,M,b){const E=3*y,D=this._data;return D[E]*k+D[E+1]*M+D[E+2]*b}evaluateUncheckedIndexPlaneAltitude(y,k){const M=3*y,b=this._data;return k.altitudeXYZ(b[M],b[M+1],b[M+2])}accumulateCrossProductIndexIndexIndex(y,k,M,b){if(this.isIndexValid(y)&&this.isIndexValid(k)&&this.isIndexValid(M)){const E=3*y,D=3*k,R=3*M,X=this._data;b.addCrossProductToTargetsInPlace(X[E],X[E+1],X[E+2],X[D],X[D+1],X[D+2],X[R],X[R+1],X[R+2])}}accumulateScaledXYZ(y,k,M){if(this.isIndexValid(y)){const b=3*y,E=this._data;M.x+=k*E[b],M.y+=k*E[b+1],M.z+=k*E[b+2]}}crossProductXYAndZIndexIndex(y,k,M,b){if(this.isIndexValid(k)&&this.isIndexValid(M)){const E=3*k,D=3*M,R=this._data;return Q.crossProductXYZXYZ(R[E]-y.x,R[E+1]-y.y,R[E+2]-y.z,R[D]-y.x,R[D+1]-y.y,R[D+2]-y.z,b)}}distanceIndexToPoint(y,k){if(this.isIndexValid(y)){const M=3*y;return Q.hypotenuseXYZ(k.x-this._data[M],k.y-this._data[M+1],k.z-this._data[M+2])}}distanceSquaredIndexIndex(y,k){if(this.isIndexValid(y)&&this.isIndexValid(k)){const M=3*y,b=3*k;return Q.hypotenuseSquaredXYZ(this._data[b]-this._data[M],this._data[b+1]-this._data[M+1],this._data[b+2]-this._data[M+2])}}distanceIndexIndex(y,k){if(this.isIndexValid(y)&&this.isIndexValid(k)){const M=3*y,b=3*k;return Q.hypotenuseXYZ(this._data[b]-this._data[M],this._data[b+1]-this._data[M+1],this._data[b+2]-this._data[M+2])}}static distanceBetweenPointsIn2Arrays(y,k,M,b){if(y.isIndexValid(k)&&M.isIndexValid(b)){const E=3*k,D=3*b;return Q.hypotenuseXYZ(M._data[D]-y._data[E],M._data[D+1]-y._data[E+1],M._data[D+2]-y._data[E+2])}}static isAlmostEqual(y,k){if(y&&k){if(y.length!==k.length)return!1;for(let M=0;M<y.length;M++)if(!y.getPoint3dAtUncheckedPointIndex(M).isAlmostEqual(k.getPoint3dAtUncheckedPointIndex(M)))return!1;return!0}return!y&&!k}sortIndicesLexical(){const y=this._xyzInUse,k=new Uint32Array(y);for(let M=0;M<y;M++)k[M]=M;return k.sort(((y,k)=>this.compareLexicalBlock(y,k))),k}compareLexicalBlock(y,k){let M=0,b=0;for(let E=0;E<3;E++){if(M=this._data[3*y+E],b=this._data[3*k+E],M>b)return 1;if(M<b)return-1}return y-k}component(y,k){return this._data[3*y+k]}addSteppedPoints(y,k,M,b){const E=y._data;let D=3*k;const R=3*y.length;let X=0;for(this.ensureCapacity(this._xyzInUse+b,!1);D>=0&&D+2<R&&X<b;)this.pushXYZ(E[D],E[D+1],E[D+2]),D+=3*M,X++}static distanceRangeBetweenCorrespondingPoints(y,k){const M=y._data,b=k._data,E=Math.min(y.length,k.length);let D,R=0;const X=ft.createNull();for(;R<E;)D=3*R,X.extendX(Q.hypotenuseXYZ(M[D]-b[D],M[D+1]-b[D+1],M[D+2]-b[D+2])),R++;return X}static removeClosure(y,k=Q.smallMetricDistance){for(;y.length>1&&y.distanceIndexIndex(0,y.length-1)<k;)y.pop()}fillLocalXYTriangleFrame(y,k,M,b){if(this.isIndexValid(y)&&this.isIndexValid(k)&&this.isIndexValid(M)){let E=3*y;const D=this._data,R=D[E++],X=D[E++],z=D[E++];E=3*k;const N=D[E++]-R,Y=D[E++]-X,O=D[E++]-z;E=3*M;const B=D[E++]-R,V=D[E++]-X,U=D[E++]-z;return(b=pt.createRowValues(N,B,0,R,Y,V,0,X,O,U,1,z,b)).computeCachedInverse()?b:void 0}}mapComponent(y,k){const M=this._data.length;let b;for(let E=0;E+2<M;E+=3)b=k(this._data[E],this._data[E+1],this._data[E+2]),this._data[E+y]=b}}class rt{startChain(y,k){}handleXYZ(y,k,M){}endChain(y,k){}}class ot extends rt{handleXYZ(y,k,M){void 0!==this._x0&&this.handleXYZXYZ(this._x0,this._y0,this._z0,y,k,M),this._x0=y,this._y0=k,this._z0=M}startChain(y,k){this._x0=this._y0=this._z0=void 0}handleXYZXYZ(y,k,M,b,E,D){}}class at extends rt{startChain(y,k){this._currentData=void 0}handleXYZ(y,k,M){this._currentData||(this._currentData=new nt),this._currentData.pushXYZ(y,k,M)}endChain(y,k){void 0!==this._currentData&&(void 0===this._pointArrays&&(this._pointArrays=[]),this._pointArrays.push(this._currentData),this._currentData=void 0)}claimArrayOfGrowableXYZArray(){const y=this._pointArrays;return this._pointArrays=void 0,y}}class ct extends rt{constructor(){super(...arguments),this._range=ut.createNull()}handleXYZ(y,k,M){this._range||(this._range=ut.createNull()),this._range.extendXYZ(y,k,M)}claimResult(){const y=this._range;return this._range=void 0,y||ut.createNull()}}class lt{constructor(y){this._xyzFunction=y,this._resultStack=[],this._resultStack.push([])}startChain(y,k){this._resultStack.push([])}handleXYZ(y,k,M){this._resultStack[this._resultStack.length-1].push(this._xyzFunction(y,k,M))}endChain(y,k){const M=this._resultStack[this._resultStack.length-1];this._resultStack.pop(),this._resultStack[this._resultStack.length-1].push(M)}claimResult(){const y=this._resultStack[0];return 1===y.length?y[0]:y}}class ht{static streamXYZ(y,k){let M=0;if(Array.isArray(y))if(y.length>0&&j.isAnyImmediatePointType(y[0])){k.startChain(y,!0);for(const b of y){const y=j.accessX(b),E=j.accessY(b),D=j.accessZ(b,0);void 0!==y&&void 0!==E&&k.handleXYZ(y,E,D),M++}k.endChain(y,!0)}else{k.startChain(y,!1);for(const b of y)M+=this.streamXYZ(b,k);k.endChain(y,!1)}else if(y instanceof it){k.startChain(y,!0);const b=ht._workPoint=j.create(0,0,0,ht._workPoint);for(let E=0;E<y.length;E++)y.getPoint3dAtCheckedPointIndex(E,b),M++,k.handleXYZ(b.x,b.y,b.z);k.endChain(y,!0)}return M}}class dt{static npcScaleFactor(y,k){return k<=y?0:1/(k-y)}static isExtremeValue(y){return Math.abs(y)>=dt._EXTREME_POSITIVE}static isExtremePoint3d(y){return dt.isExtremeValue(y.x)||dt.isExtremeValue(y.y)||dt.isExtremeValue(y.z)}static isExtremePoint2d(y){return dt.isExtremeValue(y.x)||dt.isExtremeValue(y.y)}static rangeToRangeAbsoluteDistance(y,k,M,b){return k<y||b<M?dt._EXTREME_POSITIVE:b<y?y-b:b<=k||M<=k?0:M-k}static coordinateToRangeAbsoluteDistance(y,k,M){return M<k?dt._EXTREME_POSITIVE:y<k?k-y:y>M?y-M:0}static multiplyIfPositive(y,k,M=0){return y>0?k*y:M}}dt._EXTREME_POSITIVE=1e200,dt._EXTREME_NEGATIVE=-1e200;class ut extends dt{setNull(){this.low.x=dt._EXTREME_POSITIVE,this.low.y=dt._EXTREME_POSITIVE,this.low.z=dt._EXTREME_POSITIVE,this.high.x=dt._EXTREME_NEGATIVE,this.high.y=dt._EXTREME_NEGATIVE,this.high.z=dt._EXTREME_NEGATIVE}freeze(){return this.low.freeze(),this.high.freeze(),Object.freeze(this)}static toFloat64Array(y){return Float64Array.of(y.low.x,y.low.y,y.low.z,y.high.x,y.high.y,y.high.z)}toFloat64Array(){return ut.toFloat64Array(this)}static fromFloat64Array(y){if(6!==y.length)throw new Error("invalid array");return new this(y[0],y[1],y[2],y[3],y[4],y[5])}static fromArrayBuffer(y){return this.fromFloat64Array(new Float64Array(y))}constructor(y=dt._EXTREME_POSITIVE,k=dt._EXTREME_POSITIVE,M=dt._EXTREME_POSITIVE,b=dt._EXTREME_NEGATIVE,E=dt._EXTREME_NEGATIVE,D=dt._EXTREME_NEGATIVE){super(),this.low=j.create(y,k,M),this.high=j.create(b,E,D)}isAlmostEqual(y,k){return this.low.isAlmostEqual(y.low,k)&&this.high.isAlmostEqual(y.high,k)||this.isNull&&y.isNull}setFrom(y){this.low.setFrom(y.low),this.high.setFrom(y.high)}static createFrom(y,k){return k?(k.setFrom(y),k):this.createXYZXYZOrCorrectToNull(y.low.x,y.low.y,y.low.z,y.high.x,y.high.y,y.high.z,k)}setFromJSON(y){if(!y)return;if(this.setNull(),Array.isArray(y)){const k=j.create();for(const M of y)k.setFromJSON(M),this.extendPoint(k);return}const k=j.fromJSON(y.low),M=j.fromJSON(y.high);dt.isExtremePoint3d(k)||dt.isExtremePoint3d(M)||(this.extendPoint(k),this.extendPoint(M))}toJSON(){return{low:this.low.toJSON(),high:this.high.toJSON()}}static fromJSON(y){const k=new this;return k.setFromJSON(y),k}setDirect(y,k,M,b,E,D,R){this.low.x=y,this.low.y=k,this.low.z=M,this.high.x=b,this.high.y=E,this.high.z=D,R&&(this.low.x>this.high.x||this.low.y>this.high.y||this.low.z>this.high.z)&&this.setNull()}clone(y){return(y=y||new this.constructor).setDirect(this.low.x,this.low.y,this.low.z,this.high.x,this.high.y,this.high.z,!1),y}cloneTranslated(y,k){return k=k||new this.constructor,this.isNull||k.setDirect(this.low.x+y.x,this.low.y+y.y,this.low.z+y.z,this.high.x+y.x,this.high.y+y.y,this.high.z+y.z,!1),k}static createNull(y){return(y=y||new this).setNull(),y}extend(...y){let k;for(k of y)this.extendPoint(k)}static create(...y){const k=ut.createNull();let M;for(M of y)k.extendPoint(M);return k}static createFromVariantData(y){const k=new ct;return ht.streamXYZ(y,k),k.claimResult()}static createTransformed(y,...k){const M=this.createNull();let b;for(b of k)M.extendTransformedXYZ(y,b.x,b.y,b.z);return M}static createTransformedArray(y,k){const M=this.createNull();return M.extendArray(k,y),M}static createInverseTransformedArray(y,k){const M=this.createNull();return M.extendInverseTransformedArray(k,y),M}setXYZ(y,k,M){this.low.x=this.high.x=y,this.low.y=this.high.y=k,this.low.z=this.high.z=M}static createXYZ(y,k,M,b){return(b=b||new this).setDirect(y,k,M,y,k,M,!1),b}static createXYZXYZ(y,k,M,b,E,D,R){return(R=R||new this).setDirect(Math.min(y,b),Math.min(k,E),Math.min(M,D),Math.max(y,b),Math.max(k,E),Math.max(M,D),!1),R}static createXYZXYZOrCorrectToNull(y,k,M,b,E,D,R){return R=R||new this,y>b||k>E||M>D?this.createNull(R):(R.setDirect(Math.min(y,b),Math.min(k,E),Math.min(M,D),Math.max(y,b),Math.max(k,E),Math.max(M,D),!0),R)}static createRange2d(y,k=0,M){const b=M||new this;return b.setNull(),b.extendXYZ(y.low.x,y.low.y,k),b.extendXYZ(y.high.x,y.high.y,k),b}static createArray(y,k){let M;for(M of((k=k||new this).setNull(),y))k.extendPoint(M);return k}extendArray(y,k){if(Array.isArray(y))if(k)for(const M of y)this.extendTransformedXYZ(k,M.x,M.y,M.z);else for(const M of y)this.extendXYZ(M.x,M.y,M.z);else if(k)for(let M=0;M<y.length;M++)this.extendTransformedXYZ(k,y.getXAtUncheckedPointIndex(M),y.getYAtUncheckedPointIndex(M),y.getZAtUncheckedPointIndex(M));else for(let M=0;M<y.length;M++)this.extendXYZ(y.getXAtUncheckedPointIndex(M),y.getYAtUncheckedPointIndex(M),y.getZAtUncheckedPointIndex(M))}extendInverseTransformedArray(y,k){if(Array.isArray(y))for(const M of y)this.extendInverseTransformedXYZ(k,M.x,M.y,M.z);else for(let M=0;M<y.length;M++)this.extendInverseTransformedXYZ(k,y.getXAtUncheckedPointIndex(M),y.getYAtUncheckedPointIndex(M),y.getZAtUncheckedPointIndex(M))}extendTransformedXYZ(y,k,M,b){const E=y.origin,D=y.matrix.coffs;this.extendXYZ(E.x+D[0]*k+D[1]*M+D[2]*b,E.y+D[3]*k+D[4]*M+D[5]*b,E.z+D[6]*k+D[7]*M+D[8]*b)}extendTransformedXYZW(y,k,M,b,E){const D=y.origin,R=y.matrix.coffs;this.extendXYZW(D.x*E+R[0]*k+R[1]*M+R[2]*b,D.y*E+R[3]*k+R[4]*M+R[5]*b,D.z*E+R[6]*k+R[7]*M+R[8]*b,E)}extendInverseTransformedXYZ(y,k,M,b){const E=y.origin;if(!y.matrix.computeCachedInverse(!0))return!1;const D=y.matrix.inverseCoffs,R=k-E.x,X=M-E.y,z=b-E.z;return this.extendXYZ(D[0]*R+D[1]*X+D[2]*z,D[3]*R+D[4]*X+D[5]*z,D[6]*R+D[7]*X+D[8]*z),!0}extendTransformTransformedXYZ(y,k,M,b,E){const D=k.origin,R=k.matrix.coffs;this.extendTransformedXYZ(y,D.x+R[0]*M+R[1]*b+R[2]*E,D.y+R[3]*M+R[4]*b+R[5]*E,D.z+R[6]*M+R[7]*b+R[8]*E)}get isNull(){return this.high.x<this.low.x||this.high.y<this.low.y||this.high.z<this.low.z}static isNull(y){return y.high.x<y.low.x||y.high.y<y.low.y||y.high.z<y.low.z}get isSinglePoint(){return this.high.x===this.low.x&&this.high.y===this.low.y&&this.high.z===this.low.z}get center(){return this.low.interpolate(.5,this.high)}get xLow(){return this.low.x}get yLow(){return this.low.y}get zLow(){return this.low.z}get xHigh(){return this.high.x}get yHigh(){return this.high.y}get zHigh(){return this.high.z}xLength(){const y=this.high.x-this.low.x;return y>0?y:0}yLength(){const y=this.high.y-this.low.y;return y>0?y:0}zLength(){const y=this.high.z-this.low.z;return y>0?y:0}maxLength(){return Math.max(this.xLength(),this.yLength(),this.zLength())}diagonal(y){return this.low.vectorTo(this.high,y)}diagonalFractionToPoint(y,k){return this.low.interpolate(y,this.high,k)}fractionToPoint(y,k,M=0,b){return this.low.interpolateXYZ(y,k,M,this.high,b)}localXYZToWorld(y,k,M,b){if(!this.isNull)return this.low.interpolateXYZ(y,k,M,this.high,b)}localToWorld(y,k){return this.localXYZToWorld(y.x,y.y,y.z,k)}localToWorldArrayInPlace(y){if(this.isNull)return!1;for(const k of y)this.low.interpolateXYZ(k.x,k.y,k.z,this.high,k);return!1}worldToLocal(y,k){const M=dt.npcScaleFactor(this.low.x,this.high.x),b=dt.npcScaleFactor(this.low.y,this.high.y),E=dt.npcScaleFactor(this.low.z,this.high.z);if(0!==M&&0!==b&&0!==E)return j.create((y.x-this.low.x)*M,(y.y-this.low.y)*b,(y.z-this.low.z)*E,k)}worldToLocalArrayInPlace(y){const k=dt.npcScaleFactor(this.low.x,this.high.x),M=dt.npcScaleFactor(this.low.y,this.high.y),b=dt.npcScaleFactor(this.low.z,this.high.z);if(0===k||0===M||0===b)return!1;for(const E of y)j.create((E.x-this.low.x)*k,(E.y-this.low.y)*M,(E.z-this.low.z)*b,E);return!0}corners(y){return void 0!==y&&y.length>=8?(y[0].set(this.low.x,this.low.y,this.low.z),y[1].set(this.high.x,this.low.y,this.low.z),y[2].set(this.low.x,this.high.y,this.low.z),y[3].set(this.high.x,this.high.y,this.low.z),y[4].set(this.low.x,this.low.y,this.high.z),y[5].set(this.high.x,this.low.y,this.high.z),y[6].set(this.low.x,this.high.y,this.high.z),y[7].set(this.high.x,this.high.y,this.high.z),y.length=8,y):[j.create(this.low.x,this.low.y,this.low.z),j.create(this.high.x,this.low.y,this.low.z),j.create(this.low.x,this.high.y,this.low.z),j.create(this.high.x,this.high.y,this.low.z),j.create(this.low.x,this.low.y,this.high.z),j.create(this.high.x,this.low.y,this.high.z),j.create(this.low.x,this.high.y,this.high.z),j.create(this.high.x,this.high.y,this.high.z)]}static faceCornerIndices(y){return 0===y?[0,4,6,2]:1===y?[1,3,7,5]:2===y?[0,1,5,4]:3===y?[3,2,6,7]:4===y?[0,2,3,1]:[4,5,7,6]}rectangleXY(y=0,k=!0,M=!0){if(this.isNull)return;const b=[this.fractionToPoint(0,0,y),this.fractionToPoint(1,0,y),this.fractionToPoint(1,1,y),this.fractionToPoint(0,1,y)];return M&&b.push(b[0].clone()),k||b.reverse(),b}maxAbs(){return this.isNull?0:Math.max(this.low.maxAbs(),this.high.maxAbs())}get isAlmostZeroX(){return Q.isSmallMetricDistance(this.xLength())}get isAlmostZeroY(){return Q.isSmallMetricDistance(this.yLength())}get isAlmostZeroZ(){return Q.isSmallMetricDistance(this.zLength())}containsXYZ(y,k,M){return y>=this.low.x&&k>=this.low.y&&M>=this.low.z&&y<=this.high.x&&k<=this.high.y&&M<=this.high.z}containsXY(y,k){return y>=this.low.x&&k>=this.low.y&&y<=this.high.x&&k<=this.high.y}containsPoint(y){return this.containsXYZ(y.x,y.y,y.z)}containsPointXY(y){return y.x>=this.low.x&&y.y>=this.low.y&&y.x<=this.high.x&&y.y<=this.high.y}containsRange(y){return y.low.x>=this.low.x&&y.low.y>=this.low.y&&y.low.z>=this.low.z&&y.high.x<=this.high.x&&y.high.y<=this.high.y&&y.high.z<=this.high.z}intersectsRange(y){return!(this.low.x>y.high.x||this.low.y>y.high.y||this.low.z>y.high.z||y.low.x>this.high.x||y.low.y>this.high.y||y.low.z>this.high.z)}intersectsRangeXY(y){return!(this.low.x>y.high.x||this.low.y>y.high.y||y.low.x>this.high.x||y.low.y>this.high.y)}distanceToPoint(y){return this.isNull?dt._EXTREME_POSITIVE:Math.min(Q.hypotenuseXYZ(dt.coordinateToRangeAbsoluteDistance(y.x,this.low.x,this.high.x),dt.coordinateToRangeAbsoluteDistance(y.y,this.low.y,this.high.y),dt.coordinateToRangeAbsoluteDistance(y.z,this.low.z,this.high.z)),dt._EXTREME_POSITIVE)}distanceToRange(y){return Math.min(Q.hypotenuseXYZ(dt.rangeToRangeAbsoluteDistance(this.low.x,this.high.x,y.low.x,y.high.x),dt.rangeToRangeAbsoluteDistance(this.low.y,this.high.y,y.low.y,y.high.y),dt.rangeToRangeAbsoluteDistance(this.low.z,this.high.z,y.low.z,y.high.z)),dt._EXTREME_POSITIVE)}extendXYZ(y,k,M){y<this.low.x&&(this.low.x=y),y>this.high.x&&(this.high.x=y),k<this.low.y&&(this.low.y=k),k>this.high.y&&(this.high.y=k),M<this.low.z&&(this.low.z=M),M>this.high.z&&(this.high.z=M)}extendInterpolated(y,k,M){if(k<.5)this.extendXYZ(y.x+k*(M.x-y.x),y.y+k*(M.y-y.y),y.z+k*(M.z-y.z));else{const b=1-k;this.extendXYZ(M.x+b*(y.x-M.x),M.y+b*(y.y-M.y),M.z+b*(y.z-M.z))}}extendXOnly(y){y<this.low.x&&(this.low.x=y),y>this.high.x&&(this.high.x=y)}extendYOnly(y){y<this.low.y&&(this.low.y=y),y>this.high.y&&(this.high.y=y)}extendZOnly(y){y<this.low.z&&(this.low.z=y),y>this.high.z&&(this.high.z=y)}extendSingleAxis(y,k){k===D.X&&this.extendXOnly(y),k===D.Y&&this.extendYOnly(y),k===D.Z&&this.extendZOnly(y)}extendXYZW(y,k,M,b){Q.isSmallMetricDistance(b)||this.extendXYZ(y/b,k/b,M/b)}extendPoint(y,k){k?this.extendTransformedXYZ(k,y.x,y.y,y.z):this.extendXYZ(y.x,y.y,y.z)}extendTransformedPoint(y,k){this.extendTransformedXYZ(y,k.x,k.y,k.z)}extendRange(y){ut.isNull(y)||(this.extendXYZ(y.low.x,y.low.y,y.low.z),this.extendXYZ(y.high.x,y.high.y,y.high.z))}extendWhenLarger(y,k){ut.isNull(y)||ut.isNull(this)||(this.high.x+=dt.multiplyIfPositive(this.high.x-y.high.x,k),this.high.y+=dt.multiplyIfPositive(this.high.y-y.high.y,k),this.high.z+=dt.multiplyIfPositive(this.high.z-y.high.z,k),this.low.x-=dt.multiplyIfPositive(y.low.x-this.low.x,k),this.low.y-=dt.multiplyIfPositive(y.low.y-this.low.y,k),this.low.z-=dt.multiplyIfPositive(y.low.z-this.low.z,k))}intersect(y,k){return this.intersectsRange(y)?ut.createXYZXYZOrCorrectToNull(Math.max(this.low.x,y.low.x),Math.max(this.low.y,y.low.y),Math.max(this.low.z,y.low.z),Math.min(this.high.x,y.high.x),Math.min(this.high.y,y.high.y),Math.min(this.high.z,y.high.z),k):ut.createNull(k)}union(y,k){return this.isNull?y.clone(k):y.isNull?this.clone(k):ut.createXYZXYZOrCorrectToNull(Math.min(this.low.x,y.low.x),Math.min(this.low.y,y.low.y),Math.min(this.low.z,y.low.z),Math.max(this.high.x,y.high.x),Math.max(this.high.y,y.high.y),Math.max(this.high.z,y.high.z),k)}scaleAboutCenterInPlace(y){if(!this.isNull){y=Math.abs(y);const k=.5*(this.low.x+this.high.x),M=.5*(this.low.y+this.high.y),b=.5*(this.low.z+this.high.z);this.high.x=Q.interpolate(k,y,this.high.x),this.high.y=Q.interpolate(M,y,this.high.y),this.high.z=Q.interpolate(b,y,this.high.z),this.low.x=Q.interpolate(k,y,this.low.x),this.low.y=Q.interpolate(M,y,this.low.y),this.low.z=Q.interpolate(b,y,this.low.z)}}expandInPlace(y){this.setDirect(this.low.x-y,this.low.y-y,this.low.z-y,this.high.x+y,this.high.y+y,this.high.z+y,!0)}getLocalToWorldTransform(y){return pt.createOriginAndMatrix(j.create(this.low.x,this.low.y,this.low.z),xt.createRowValues(this.high.x-this.low.x,0,0,0,this.high.y-this.low.y,0,0,0,this.high.z-this.low.z),y)}getNpcToWorldRangeTransform(y){const k=this.getLocalToWorldTransform(y),M=k.matrix;return 0===M.coffs[0]&&(M.coffs[0]=1),0===M.coffs[4]&&(M.coffs[4]=1),0===M.coffs[8]&&(M.coffs[8]=1),k}ensureMinLengths(y=.001){let k=(y-this.xLength())/2;k>0&&(this.low.x-=k,this.high.x+=k),k=(y-this.yLength())/2,k>0&&(this.low.y-=k,this.high.y+=k),k=(y-this.zLength())/2,k>0&&(this.low.z-=k,this.high.z+=k)}}class ft extends dt{setNull(){this.low=dt._EXTREME_POSITIVE,this.high=dt._EXTREME_NEGATIVE}setDirect(y,k,M=!1){this.low=y,this.high=k,M&&y>k&&this.setNull()}constructor(y=dt._EXTREME_POSITIVE,k=dt._EXTREME_NEGATIVE){super(),this.low=y,this.high=k,this.setDirect(y,k)}isAlmostEqual(y){return Q.isSameCoordinate(this.low,y.low)&&Q.isSameCoordinate(this.high,y.high)||this.isNull&&y.isNull}setFrom(y){this.low=y.low,this.high=y.high}setFromJSON(y){if(this.setNull(),Array.isArray(y)){let k;for(k of y)Number.isFinite(k)&&this.extendX(k)}else void 0!==y.low&&Number.isFinite(y.low)&&void 0!==y.high&&Number.isFinite(y.high)&&(this.extendX(y.low),this.extendX(y.high))}static fromJSON(y){const k=new this;return y&&k.setFromJSON(y),k}toJSON(){return this.isNull?new Array:[this.low,this.high]}clone(y){return(y=y||new this.constructor).setDirect(this.low,this.high),y}static createFrom(y,k){return(k=k||new this).setDirect(y.low,y.high),k}static createNull(y){return(y=y||new this).setNull(),y}cloneTranslated(y,k){return(k=k||this.clone()).isNull||(k.low+=y,k.high+=y),k}setX(y){this.low=this.high=y}static createX(y,k){return(k=k||new this).setDirect(y,y),k}setXXUnordered(y,k){y<=k?(this.low=y,this.high=k):(this.low=k,this.high=y)}get isExact01(){return 0===this.low&&1===this.high}static createXX(y,k,M){return(M=M||new this).setDirect(Math.min(y,k),Math.max(y,k)),M}static createXXOrCorrectToNull(y,k,M){return k<y?ft.createNull(M):((M=M||new this).setDirect(Math.min(y,k),Math.max(y,k)),M)}static createArray(y,k){let M;for(M of(k=k||new this,y))k.extendX(M);return k}extendArray(y){let k;for(k of y)this.extendX(k)}extendArraySubset(y,k,M){const b=k+M;for(let E=k;E<b;E++)this.extendX(y[E])}get isNull(){return this.high<this.low}get isSinglePoint(){return this.high===this.low}length(){const y=this.high-this.low;return y>0?y:0}fractionToPoint(y){return Q.interpolate(this.low,y,this.high)}maxAbs(){return this.isNull?0:Math.max(Math.abs(this.low),Math.abs(this.high))}get isAlmostZeroLength(){return Q.isSmallMetricDistance(this.length())}containsX(y){return y>=this.low&&y<=this.high}containsXOpen(y){return y>this.low&&y<this.high}containsRange(y){return y.low>=this.low&&y.high<=this.high}intersectsRange(y){return!(this.low>y.high||y.low>this.high)}intersectRangeXXInPlace(y,k){k<y||k<this.low||y>this.high?this.setNull():(k<this.high&&(this.high=k),y>this.low&&(this.low=y))}distanceToRange(y){return dt.rangeToRangeAbsoluteDistance(this.low,this.high,y.low,y.high)}distanceToX(y){return this.isNull?dt._EXTREME_POSITIVE:dt.coordinateToRangeAbsoluteDistance(y,this.low,this.high)}extendX(y){y<this.low&&(this.low=y),y>this.high&&(this.high=y)}extendRange(y){y.isNull||(this.extendX(y.low),this.extendX(y.high))}extendLow(y){return!!(this.isNull||y<this.low)&&(this.low=y,!0)}extendHigh(y){return!!(this.isNull||y>this.high)&&(this.high=y,!0)}intersect(y,k){return this.intersectsRange(y)?ft.createXXOrCorrectToNull(Math.max(this.low,y.low),Math.min(this.high,y.high),k):ft.createNull(k)}union(y,k){return ft.createXX(Math.min(this.low,y.low),Math.max(this.high,y.high),k)}scaleAboutCenterInPlace(y){if(!this.isNull){y=Math.abs(y);const k=.5*(this.low+this.high);this.high=Q.interpolate(k,y,this.high),this.low=Q.interpolate(k,y,this.low)}}expandInPlace(y){this.setDirect(this.low-y,this.high+y,!0)}clipLinearMapToInterval(y,k,M,b){if(b<M||this.high<this.low)return!1;const E=Q.conditionalDivideFraction(M-y,k),D=Q.conditionalDivideFraction(b-y,k);return void 0===E||void 0===D?M<=y&&y<=b||(this.setNull(),!1):(E<D?(E>this.low&&(this.low=E),D<this.high&&(this.high=D)):(E<this.high&&(this.high=E),D>this.low&&(this.low=D)),!(this.high<this.low&&(this.setNull(),1)))}}class gt extends dt{setNull(){this.low.x=dt._EXTREME_POSITIVE,this.low.y=dt._EXTREME_POSITIVE,this.high.x=dt._EXTREME_NEGATIVE,this.high.y=dt._EXTREME_NEGATIVE}static toFloat64Array(y){return Float64Array.of(y.low.x,y.low.y,y.high.x,y.high.y)}toFloat64Array(){return gt.toFloat64Array(this)}static fromFloat64Array(y){if(4!==y.length)throw new Error("invalid array");return new this(y[0],y[1],y[2],y[3])}static fromArrayBuffer(y){return this.fromFloat64Array(new Float64Array(y))}constructor(y=gt._EXTREME_POSITIVE,k=gt._EXTREME_POSITIVE,M=gt._EXTREME_NEGATIVE,b=gt._EXTREME_NEGATIVE){super(),this.low=H.create(y,k),this.high=H.create(M,b)}isAlmostEqual(y){return this.low.isAlmostEqual(y.low)&&this.high.isAlmostEqual(y.high)||this.isNull&&y.isNull}setFrom(y){this.low.set(y.low.x,y.low.y),this.high.set(y.high.x,y.high.y)}static createFrom(y,k){return k?(k.setFrom(y),k):this.createXYXYOrCorrectToNull(y.low.x,y.low.y,y.high.x,y.high.y,k)}setFromJSON(y){if(this.setNull(),Array.isArray(y)){const k=H.create();for(const M of y)k.setFromJSON(M),this.extendPoint(k);return}const k=H.fromJSON(y.low),M=H.fromJSON(y.high);dt.isExtremePoint2d(k)||dt.isExtremePoint2d(M)||(this.extendPoint(k),this.extendPoint(M))}freeze(){return this.low.freeze(),this.high.freeze(),Object.freeze(this)}toJSON(){return this.isNull?[]:[this.low.toJSON(),this.high.toJSON()]}static fromJSON(y){const k=new this;return y&&k.setFromJSON(y),k}setDirect(y,k,M,b,E){this.low.x=y,this.low.y=k,this.high.x=M,this.high.y=b,E&&(this.low.x>this.high.x||this.low.y>this.high.y)&&this.setNull()}clone(y){return(y=y||new this.constructor).setDirect(this.low.x,this.low.y,this.high.x,this.high.y,!1),y}cloneTranslated(y,k){return k=k||new this.constructor,this.isNull||k.setDirect(this.low.x+y.x,this.low.y+y.y,this.high.x+y.x,this.high.y+y.y,!1),k}static createNull(y){return(y=y||new this).setNull(),y}setXY(y,k){this.low.x=this.high.x=y,this.low.y=this.high.y=k}static createXY(y,k,M){return(M=M||new this).setDirect(y,k,y,k,!1),M}static createXYXY(y,k,M,b,E){return(E=E||new this).setDirect(Math.min(y,M),Math.min(k,b),Math.max(y,M),Math.max(k,b),!1),E}static createXYXYXY(y,k,M,b,E,D,R){return(R=R||new this).setDirect(Math.min(y,M,E),Math.min(k,b,D),Math.max(y,M,E),Math.max(k,b,D),!1),R}static createXYXYOrCorrectToNull(y,k,M,b,E){return y>M||k>b?this.createNull(E):((E=E||new this).setDirect(Math.min(y,M),Math.min(k,b),Math.max(y,M),Math.max(k,b),!0),E)}static createArray(y,k){let M;for(M of(k=k||new this,y))k.extendPoint(M);return k}get isNull(){return this.high.x<this.low.x||this.high.y<this.low.y}static isNull(y){return y.high.x<y.low.x||y.high.y<y.low.y}get isSinglePoint(){return this.high.x===this.low.x&&this.high.y===this.low.y}get center(){return this.low.interpolate(.5,this.high)}get xLow(){return this.low.x}get yLow(){return this.low.y}get xHigh(){return this.high.x}get yHigh(){return this.high.y}xLength(){const y=this.high.x-this.low.x;return y>0?y:0}yLength(){const y=this.high.y-this.low.y;return y>0?y:0}diagonal(y){return this.low.vectorTo(this.high,y)}diagonalFractionToPoint(y,k){return this.low.interpolate(y,this.high,k)}fractionToPoint(y,k,M){return this.low.interpolateXY(y,k,this.high,M)}corners3d(y=!1,k=0){return y?[j.create(this.low.x,this.low.y,k),j.create(this.high.x,this.low.y,k),j.create(this.high.x,this.high.y,k),j.create(this.low.x,this.high.y,k),j.create(this.low.x,this.low.y,k)]:[j.create(this.low.x,this.low.y,k),j.create(this.high.x,this.low.y,k),j.create(this.low.x,this.high.y,k),j.create(this.high.x,this.high.y,k)]}maxAbs(){return this.isNull?0:Math.max(this.low.maxAbs(),this.high.maxAbs())}get isAlmostZeroX(){return Q.isSmallMetricDistance(this.xLength())}get isAlmostZeroY(){return Q.isSmallMetricDistance(this.yLength())}containsXY(y,k){return y>=this.low.x&&k>=this.low.y&&y<=this.high.x&&k<=this.high.y}containsPoint(y){return this.containsXY(y.x,y.y)}containsRange(y){return y.low.x>=this.low.x&&y.low.y>=this.low.y&&y.high.x<=this.high.x&&y.high.y<=this.high.y}intersectsRange(y){return!(this.low.x>y.high.x||this.low.y>y.high.y||y.low.x>this.high.x||y.low.y>this.high.y)}distanceToPoint(y){return this.isNull?gt._EXTREME_POSITIVE:Math.min(Q.hypotenuseXY(dt.coordinateToRangeAbsoluteDistance(y.x,this.low.x,this.high.x),dt.coordinateToRangeAbsoluteDistance(y.y,this.low.y,this.high.y)),gt._EXTREME_POSITIVE)}distanceToRange(y){return Math.min(Q.hypotenuseXY(dt.rangeToRangeAbsoluteDistance(this.low.x,this.high.x,y.low.x,y.high.x),dt.rangeToRangeAbsoluteDistance(this.low.y,this.high.y,y.low.y,y.high.y)),gt._EXTREME_POSITIVE)}extendXY(y,k){y<this.low.x&&(this.low.x=y),y>this.high.x&&(this.high.x=y),k<this.low.y&&(this.low.y=k),k>this.high.y&&(this.high.y=k)}extendTransformedXY(y,k,M){const b=y.multiplyComponentXYZ(0,k,M,0),E=y.multiplyComponentXYZ(1,k,M,0);this.extendXY(b,E)}extendPoint(y){this.extendXY(y.x,y.y)}extendRange(y){gt.isNull(y)||(this.extendXY(y.low.x,y.low.y),this.extendXY(y.high.x,y.high.y))}intersect(y,k){return this.intersectsRange(y)?gt.createXYXY(Math.max(this.low.x,y.low.x),Math.max(this.low.y,y.low.y),Math.min(this.high.x,y.high.x),Math.min(this.high.y,y.high.y),k):gt.createNull(k)}union(y,k){return this.isNull?gt.createFrom(y,k):gt.isNull(y)?this.clone(k):gt.createXYXY(Math.min(this.low.x,y.low.x),Math.min(this.low.y,y.low.y),Math.max(this.high.x,y.high.x),Math.max(this.high.y,y.high.y),k)}scaleAboutCenterInPlace(y){if(!this.isNull){y=Math.abs(y);const k=.5*(this.low.x+this.high.x),M=.5*(this.low.y+this.high.y);this.high.x=Q.interpolate(k,y,this.high.x),this.high.y=Q.interpolate(M,y,this.high.y),this.low.x=Q.interpolate(k,y,this.low.x),this.low.y=Q.interpolate(M,y,this.low.y)}}expandInPlace(y){this.setDirect(this.low.x-y,this.low.y-y,this.high.x+y,this.high.y+y,!0)}worldToLocal(y,k){const M=dt.npcScaleFactor(this.low.x,this.high.x),b=dt.npcScaleFactor(this.low.y,this.high.y);if(0!==M&&0!==b)return H.create((y.x-this.low.x)*M,(y.y-this.low.y)*b,k)}}class pt{constructor(y,k){this._origin=y,this._matrix=k}static get identity(){return void 0===this._identity&&(this._identity=pt.createIdentity(),this._identity.freeze()),this._identity}freeze(){return this._origin.freeze(),this._matrix.freeze(),Object.freeze(this)}setFrom(y){this._origin.setFrom(y._origin),this._matrix.setFrom(y._matrix)}setIdentity(){this._origin.setZero(),this._matrix.setIdentity()}setFromJSON(y){if(y){if(y instanceof Object&&y.origin&&y.matrix)return this._origin.setFromJSON(y.origin),void this._matrix.setFromJSON(y.matrix);if(Q.isArrayOfNumberArray(y,3,4))return this._matrix.setRowValues(y[0][0],y[0][1],y[0][2],y[1][0],y[1][1],y[1][2],y[2][0],y[2][1],y[2][2]),void this._origin.set(y[0][3],y[1][3],y[2][3]);if(Q.isNumberArray(y,12))return this._matrix.setRowValues(y[0],y[1],y[2],y[4],y[5],y[6],y[8],y[9],y[10]),void this._origin.set(y[3],y[7],y[11])}this.setIdentity()}isAlmostEqual(y){return this===y||this.origin.isAlmostEqual(y.origin)&&this.matrix.isAlmostEqual(y.matrix)}isAlmostEqualAllowZRotation(y){return this._origin.isAlmostEqual(y._origin)&&this._matrix.isAlmostEqualAllowZRotation(y._matrix)}toRows(){return[[this._matrix.coffs[0],this._matrix.coffs[1],this._matrix.coffs[2],this._origin.x],[this._matrix.coffs[3],this._matrix.coffs[4],this._matrix.coffs[5],this._origin.y],[this._matrix.coffs[6],this._matrix.coffs[7],this._matrix.coffs[8],this._origin.z]]}toJSON(){return this.toRows()}static fromJSON(y){const k=pt.createIdentity();return k.setFromJSON(y),k}clone(y){return y?(y._matrix.setFrom(this._matrix),y._origin.setFrom(this._origin),y):new pt(j.createFrom(this._origin),this._matrix.clone())}cloneRigid(y=E.XYZ){const k=xt.createRigidFromMatrix3d(this.matrix,y);if(k)return new pt(this.origin.cloneAsPoint3d(),k)}static createRefs(y,k,M){return y||(y=j.createZero()),M?(M._origin=y,M._matrix=k,M):new pt(y,k)}static createRowValues(y,k,M,b,E,D,R,X,z,N,Y,O,B){return B?(B._origin.set(b,X,O),B._matrix.setRowValues(y,k,M,E,D,R,z,N,Y),B):new pt(j.create(b,X,O),xt.createRowValues(y,k,M,E,D,R,z,N,Y))}static createZero(y){return pt.createRowValues(0,0,0,0,0,0,0,0,0,0,0,0,y)}static createTranslationXYZ(y=0,k=0,M=0,b){return pt.createRefs($.create(y,k,M),xt.createIdentity(),b)}static createTranslation(y,k){return pt.createRefs(y,xt.createIdentity(),k)}get matrix(){return this._matrix}get origin(){return this._origin}getOrigin(){return j.createFrom(this._origin)}getTranslation(){return $.createFrom(this._origin)}getMatrix(){return this._matrix.clone()}get isIdentity(){return this._matrix.isIdentity&&this._origin.isAlmostZero}static createIdentity(y){return y?(y._origin.setZero(),y._matrix.setIdentity(),y):pt.createRefs(j.createZero(),xt.createIdentity())}static createOriginAndMatrix(y,k,M){return M?(M._origin.setFromPoint3d(y),M._matrix.setFrom(k),M):pt.createRefs(y?y.cloneAsPoint3d():j.createZero(),void 0===k?xt.createIdentity():k.clone(),M)}setOriginAndMatrixColumns(y,k,M,b){void 0!==y&&this._origin.setFrom(y),this._matrix.setColumns(k,M,b)}static createOriginAndMatrixColumns(y,k,M,b,E){return E?E.setOriginAndMatrixColumns(y,k,M,b):E=pt.createRefs($.createFrom(y),xt.createColumns(k,M,b)),E}static createRigidFromOriginAndColumns(y,k,M,b,E){const D=xt.createRigidFromColumns(k,M,b,E?E._matrix:void 0);if(D)return E?(E._origin.setFrom(y),E):((E=pt.createRefs(void 0,D))._origin.setFromPoint3d(y),E)}static createFixedPointAndMatrix(y,k,M){if(y){const b=xt.xyzMinusMatrixTimesXYZ(y,k,y);return pt.createRefs(b,k.clone(),M)}return pt.createRefs(void 0,k.clone())}static createMatrixPickupPutdown(y,k,M,b){const E=xt.xyzMinusMatrixTimesXYZ(M,y,k);return pt.createRefs(E,y.clone(),b)}static createScaleAboutPoint(y,k,M){const b=xt.createScale(k,k,k),E=xt.xyzMinusMatrixTimesXYZ(y,b,y);return pt.createRefs(E,b,M)}static createFlattenAlongVectorToPlane(y,k,M){const b=xt.createFlattenAlongVectorToPlane(y,M);if(void 0!==b)return pt.createFixedPointAndMatrix(k,b)}multiplyPoint2d(y,k){return xt.xyPlusMatrixTimesXY(this._origin,this._matrix,y,k)}multiplyPoint3d(y,k){return xt.xyzPlusMatrixTimesXYZ(this._origin,this._matrix,y,k)}multiplyXYAndZInPlace(y){return xt.xyzPlusMatrixTimesXYZInPlace(this._origin,this._matrix,y)}multiplyXYZ(y,k,M=0,b){return xt.xyzPlusMatrixTimesCoordinates(this._origin,this._matrix,y,k,M,b)}multiplyComponentXYZ(y,k,M,b=0){const E=this._matrix.coffs,D=3*y;return this.origin.at(y)+E[D]*k+E[D+1]*M+E[D+2]*b}multiplyComponentXYZW(y,k,M,b,E){const D=this._matrix.coffs,R=3*y;return this.origin.at(y)*E+D[R]*k+D[R+1]*M+D[R+2]*b}multiplyXYZW(y,k,M,b,E){return xt.xyzPlusMatrixTimesWeightedCoordinates(this._origin,this._matrix,y,k,M,b,E)}multiplyXYZWToFloat64Array(y,k,M,b,E){return xt.xyzPlusMatrixTimesWeightedCoordinatesToFloat64Array(this._origin,this._matrix,y,k,M,b,E)}multiplyXYZToFloat64Array(y,k,M,b){return xt.xyzPlusMatrixTimesCoordinatesToFloat64Array(this._origin,this._matrix,y,k,M,b)}multiplyTransposeXYZW(y,k,M,b,E){const D=this._matrix.coffs,R=this._origin;return Dt.create(y*D[0]+k*D[3]+M*D[6],y*D[1]+k*D[4]+M*D[7],y*D[2]+k*D[5]+M*D[8],y*R.x+k*R.y+M*R.z+b,E)}multiplyPoint3dArrayInPlace(y){let k;for(k of y)xt.xyzPlusMatrixTimesXYZ(this._origin,this._matrix,k,k)}multiplyPoint3dArrayArrayInPlace(y){for(const k of y)this.multiplyPoint3dArrayInPlace(k)}multiplyInversePoint3d(y,k){return this._matrix.multiplyInverseXYZAsPoint3d(y.x-this._origin.x,y.y-this._origin.y,y.z-this._origin.z,k)}multiplyInversePoint4d(y,k){const M=y.w;return this._matrix.multiplyInverseXYZW(y.x-M*this.origin.x,y.y-M*this.origin.y,y.z-M*this.origin.z,M,k)}multiplyInverseXYZ(y,k,M,b){return this._matrix.multiplyInverseXYZAsPoint3d(y-this._origin.x,k-this._origin.y,M-this._origin.z,b)}computeCachedInverse(y=!0){return this._matrix.computeCachedInverse(y)}static matchArrayLengths(y,k,M){const b=y.length,E=k.length;if(b>E)for(let D=E;D<b;D++)k.push(M());else E>b&&(k.length=b);return b}multiplyInversePoint3dArray(y,k){if(!this._matrix.computeCachedInverse(!0))return;const M=this.origin.x,b=this.origin.y,E=this.origin.z;if(k){const D=pt.matchArrayLengths(y,k,(()=>j.createZero()));for(let R=0;R<D;R++)this._matrix.multiplyInverseXYZAsPoint3d(y[R].x-M,y[R].y-b,y[R].z-E,k[R]);return k}k=[];for(const D of y)k.push(this._matrix.multiplyInverseXYZAsPoint3d(D.x-M,D.y-b,D.z-E));return k}multiplyInversePoint3dArrayInPlace(y){if(!this._matrix.computeCachedInverse(!0))return!1;for(const k of y)this._matrix.multiplyInverseXYZAsPoint3d(k.x-this.origin.x,k.y-this.origin.y,k.z-this.origin.z,k);return!0}multiplyPoint2dArray(y,k){if(k){const M=pt.matchArrayLengths(y,k,(()=>H.createZero()));for(let b=0;b<M;b++)xt.xyPlusMatrixTimesXY(this._origin,this._matrix,y[b],k[b]);return k}k=[];for(const M of y)k.push(xt.xyPlusMatrixTimesXY(this._origin,this._matrix,M));return k}multiplyPoint3dArray(y,k){if(k){const M=pt.matchArrayLengths(y,k,(()=>j.createZero()));for(let b=0;b<M;b++)xt.xyzPlusMatrixTimesXYZ(this._origin,this._matrix,y[b],k[b]);return k}k=[];for(const M of y)k.push(xt.xyzPlusMatrixTimesXYZ(this._origin,this._matrix,M));return k}multiplyVector(y,k){return this._matrix.multiplyVector(y,k)}multiplyVectorInPlace(y){this._matrix.multiplyVectorInPlace(y)}multiplyVectorXYZ(y,k,M,b){return this._matrix.multiplyXYZ(y,k,M,b)}setMultiplyTransformTransform(y,k){xt.xyzPlusMatrixTimesXYZ(y._origin,y._matrix,k._origin,this._origin),y._matrix.multiplyMatrixMatrix(k._matrix,this._matrix)}multiplyTransformTransform(y,k){return k?(k.setMultiplyTransformTransform(this,y),k):pt.createRefs(xt.xyzPlusMatrixTimesXYZ(this._origin,this._matrix,y._origin),this._matrix.multiplyMatrixMatrix(y._matrix))}multiplyTransformMatrix3d(y,k){return k?(this._matrix.multiplyMatrixMatrix(y,k._matrix),k._origin.setFrom(this._origin),k):pt.createRefs(this._origin.cloneAsPoint3d(),this._matrix.multiplyMatrixMatrix(y))}multiplyRange(y,k){if(y.isNull)return y.clone(k);const M=y.low.x,b=y.low.y,E=y.low.z,D=y.high.x,R=y.high.y,X=y.high.z;return(k=ut.createNull(k)).extendTransformedXYZ(this,M,b,E),k.extendTransformedXYZ(this,D,b,E),k.extendTransformedXYZ(this,M,R,E),k.extendTransformedXYZ(this,D,R,E),k.extendTransformedXYZ(this,M,b,X),k.extendTransformedXYZ(this,D,b,X),k.extendTransformedXYZ(this,M,R,X),k.extendTransformedXYZ(this,D,R,X),k}inverse(y){const k=this._matrix.inverse(y?y._matrix:void 0);if(k)return y?(k.multiplyXYZ(-this._origin.x,-this._origin.y,-this._origin.z,y._origin),y):pt.createRefs(k.multiplyXYZ(-this._origin.x,-this._origin.y,-this._origin.z),k)}static initFromRange(y,k,M,b){const E=k.minus(y);0===E.x&&(E.x=1),0===E.y&&(E.y=1),0===E.z&&(E.z=1);const D=new xt;if(M&&(xt.createScale(E.x,E.y,E.z,D),pt.createOriginAndMatrix(y,D,M)),b){const k=new j(-y.x/E.x,-y.y/E.y,-y.z/E.z);xt.createScale(1/E.x,1/E.y,1/E.z,D),pt.createOriginAndMatrix(k,D,b)}}}class mt{static loadMatrix(y,k,M,b,E,D,R,X,z,N){y[0]=k,y[1]=M,y[2]=b,y[3]=E,y[4]=D,y[5]=R,y[6]=X,y[7]=z,y[8]=N}static multiplyMatrixMatrix(y,k,M){return(!M||M.length<9)&&(M=new Float64Array(9)),mt.loadMatrix(M,y[0]*k[0]+y[1]*k[3]+y[2]*k[6],y[0]*k[1]+y[1]*k[4]+y[2]*k[7],y[0]*k[2]+y[1]*k[5]+y[2]*k[8],y[3]*k[0]+y[4]*k[3]+y[5]*k[6],y[3]*k[1]+y[4]*k[4]+y[5]*k[7],y[3]*k[2]+y[4]*k[5]+y[5]*k[8],y[6]*k[0]+y[7]*k[3]+y[8]*k[6],y[6]*k[1]+y[7]*k[4]+y[8]*k[7],y[6]*k[2]+y[7]*k[5]+y[8]*k[8]),M}static multiplyMatrixMatrixTranspose(y,k,M){return(!M||M.length<9)&&(M=new Float64Array(9)),mt.loadMatrix(M,y[0]*k[0]+y[1]*k[1]+y[2]*k[2],y[0]*k[3]+y[1]*k[4]+y[2]*k[5],y[0]*k[6]+y[1]*k[7]+y[2]*k[8],y[3]*k[0]+y[4]*k[1]+y[5]*k[2],y[3]*k[3]+y[4]*k[4]+y[5]*k[5],y[3]*k[6]+y[4]*k[7]+y[5]*k[8],y[6]*k[0]+y[7]*k[1]+y[8]*k[2],y[6]*k[3]+y[7]*k[4]+y[8]*k[5],y[6]*k[6]+y[7]*k[7]+y[8]*k[8]),M}static multiplyMatrixTransposeMatrix(y,k,M){return(!M||M.length<9)&&(M=new Float64Array(9)),mt.loadMatrix(M,y[0]*k[0]+y[3]*k[3]+y[6]*k[6],y[0]*k[1]+y[3]*k[4]+y[6]*k[7],y[0]*k[2]+y[3]*k[5]+y[6]*k[8],y[1]*k[0]+y[4]*k[3]+y[7]*k[6],y[1]*k[1]+y[4]*k[4]+y[7]*k[7],y[1]*k[2]+y[4]*k[5]+y[7]*k[8],y[2]*k[0]+y[5]*k[3]+y[8]*k[6],y[2]*k[1]+y[5]*k[4]+y[8]*k[7],y[2]*k[2]+y[5]*k[5]+y[8]*k[8]),M}static transposeInPlace(y){let k=y[1];y[1]=y[3],y[3]=k,k=y[2],y[2]=y[6],y[6]=k,k=y[5],y[5]=y[7],y[7]=k}static copyTransposed(y,k){return k===y?mt.transposeInPlace(k):((!k||k.length<9)&&(k=new Float64Array(9)),k[0]=y[0],k[1]=y[3],k[2]=y[6],k[3]=y[1],k[4]=y[4],k[5]=y[7],k[6]=y[2],k[7]=y[5],k[8]=y[8]),k}static copy(y,k){return k!==y&&(k[0]=y[0],k[1]=y[1],k[2]=y[2],k[3]=y[3],k[4]=y[4],k[5]=y[5],k[6]=y[6],k[7]=y[7],k[8]=y[8]),k}}!function(y){y[y.unknown=0]="unknown",y[y.inverseStored=1]="inverseStored",y[y.singular=2]="singular"}(Y||(Y={}));class xt{static get identity(){return void 0===this._identity&&(this._identity=xt.createIdentity(),this._identity.freeze()),this._identity}freeze(){return this.computeCachedInverse(!0),Object.freeze(this)}constructor(y){this.coffs=y&&y.length>=9?y:new Float64Array(9),this.inverseCoffs=void 0,this.inverseState=Y.unknown}toJSON(){return[[this.coffs[0],this.coffs[1],this.coffs[2]],[this.coffs[3],this.coffs[4],this.coffs[5]],[this.coffs[6],this.coffs[7],this.coffs[8]]]}setFromJSON(y){this.inverseCoffs=void 0,y?Array.isArray(y)?Q.isArrayOfNumberArray(y,3,3)?this.setRowValues(y[0][0],y[0][1],y[0][2],y[1][0],y[1][1],y[1][2],y[2][0],y[2][1],y[2][2]):9!==y.length?4!==y.length?this.setRowValues(0,0,0,0,0,0,0,0,0):this.setRowValues(y[0],y[1],0,y[2],y[3],0,0,0,1):this.setRowValues(y[0],y[1],y[2],y[3],y[4],y[5],y[6],y[7],y[8]):y instanceof xt&&this.setFrom(y):this.setRowValues(0,0,0,0,0,0,0,0,0)}static fromJSON(y){const k=xt.createIdentity();return k.setFromJSON(y),k}isAlmostEqual(y,k){return Q.isDistanceWithinTol(this.maxDiff(y),k)}isAlmostEqualColumn(y,k,M){const b=Q.maxAbsXYZ(this.coffs[y]-k.coffs[y],this.coffs[y+3]-k.coffs[y+3],this.coffs[y+6]-k.coffs[y+6]);return Q.isDistanceWithinTol(b,M)}isAlmostEqualColumnXYZ(y,k,M,b,E){const D=Q.maxAbsXYZ(this.coffs[y]-k,this.coffs[y+3]-M,this.coffs[y+6]-b);return Q.isDistanceWithinTol(D,E)}isAlmostEqualAllowZRotation(y,k){if(this.isAlmostEqual(y,k))return!0;if(this.isAlmostEqualColumn(D.Z,y,k)){const M=W.radiansBetweenVectorsXYZ(this.coffs[0],this.coffs[3],this.coffs[6],y.coffs[0],y.coffs[3],y.coffs[6]),b=W.createRadians(M),E=this.columnX(),D=this.columnY(),R=this.columnZ();let X=$.createRotateVectorAroundVector(E,R,b);if(y.isAlmostEqualColumnXYZ(0,X.x,X.y,X.z,k))return X=$.createRotateVectorAroundVector(D,R,b),y.isAlmostEqualColumnXYZ(1,X.x,X.y,X.z,k)}return!1}isExactEqual(y){return 0===this.maxDiff(y)}get isXY(){return 0===this.coffs[2]&&0===this.coffs[5]&&0===this.coffs[6]&&0===this.coffs[7]&&1===this.coffs[8]}static _create(y){return y||new xt}static createRowValues(y,k,M,b,E,D,R,X,z,N){return(N=N||new xt).inverseState=Y.unknown,N.coffs[0]=y,N.coffs[1]=k,N.coffs[2]=M,N.coffs[3]=b,N.coffs[4]=E,N.coffs[5]=D,N.coffs[6]=R,N.coffs[7]=X,N.coffs[8]=z,N}static createCapture(y,k){const M=new xt(y);return k&&k.length>=9?(M.inverseCoffs=k,M.inverseState=Y.inverseStored):M.inverseState=Y.unknown,M}static createColumnsInAxisOrder(y,k,M,b,D){return D||(D=new xt),y===E.YZX?D.setColumns(b,k,M):y===E.ZXY?D.setColumns(M,b,k):y===E.XZY?D.setColumns(k,b,M):y===E.YXZ?D.setColumns(M,k,b):y===E.ZYX?D.setColumns(b,M,k):D.setColumns(k,M,b),D}createInverseCoffsWithZeros(){this.inverseCoffs||(this.inverseState=Y.unknown,this.inverseCoffs=new Float64Array(9))}setupInverseTranspose(){const y=this.coffs;this.inverseState=Y.inverseStored,this.inverseCoffs=Float64Array.from([y[0],y[3],y[6],y[1],y[4],y[7],y[2],y[5],y[8]])}setRowValues(y,k,M,b,E,D,R,X,z){this.coffs[0]=y,this.coffs[1]=k,this.coffs[2]=M,this.coffs[3]=b,this.coffs[4]=E,this.coffs[5]=D,this.coffs[6]=R,this.coffs[7]=X,this.coffs[8]=z,this.inverseState=Y.unknown}setIdentity(){this.setRowValues(1,0,0,0,1,0,0,0,1),this.setupInverseTranspose()}setZero(){this.setRowValues(0,0,0,0,0,0,0,0,0),this.inverseState=Y.singular}setFrom(y){if(void 0!==y){if(y!==this){for(let k=0;k<9;k++)this.coffs[k]=y.coffs[k];if(y.inverseState===Y.inverseStored&&void 0!==y.inverseCoffs){this.createInverseCoffsWithZeros();for(let k=0;k<9;k++)this.inverseCoffs[k]=y.inverseCoffs[k];this.inverseState=Y.inverseStored}else y.inverseState!==Y.inverseStored?this.inverseState=y.inverseState:this.inverseState=Y.unknown}}else this.setIdentity()}clone(y){return(y=y||new xt).setFrom(this),y}static createZero(){const y=new xt;return y.inverseState=Y.singular,y}static createIdentity(y){return(y=y||new xt).setIdentity(),y}static createScale(y,k,M,b){return b?b.setZero():b=new xt,b.coffs[0]=y,b.coffs[4]=k,b.coffs[8]=M,0===y||0===k||0===M?b.inverseState=Y.singular:(b.inverseState=Y.inverseStored,b.inverseCoffs=Float64Array.from([1/y,0,0,0,1/k,0,0,0,1/M])),b}static createUniformScale(y){return xt.createScale(y,y,y)}static createPerpendicularVectorFavorXYPlane(y,k){const M=y.magnitude()/64;return Math.abs(y.x)<M&&Math.abs(y.y)<M?$.createCrossProduct(y.x,y.y,y.z,0,-1,0,k):$.createCrossProduct(0,0,1,y.x,y.y,y.z,k)}static createPerpendicularVectorFavorPlaneContainingZ(y,k){return k=xt.createPerpendicularVectorFavorXYPlane(y,k),y.crossProduct(k,k)}static createShuffledColumns(y,k,M,b,E){const D=xt._create(E);return D.setColumn(Q.axisOrderToAxis(b,0),y),D.setColumn(Q.axisOrderToAxis(b,1),k),D.setColumn(Q.axisOrderToAxis(b,2),M),D}static createRigidFromColumns(y,k,M,b){const E=y.normalize();if(E){const D=E.unitCrossProduct(k);if(D){const k=D.unitCrossProduct(y);if(k){const y=xt.createShuffledColumns(E,k,D,M,b);return y.setupInverseTranspose(),y}}}}static createRigidHeadsUp(y,k=E.ZXY,M){const b=xt.createPerpendicularVectorFavorXYPlane(y),D=xt.createRigidFromColumns(y,b,k,M);return D?(D.setupInverseTranspose(),D):xt.createIdentity(M)}static createRotationAroundVector(y,k,M){const b=k.cos(),E=k.sin(),D=1-b,R=y.normalize();if(R){const y=xt.createRowValues(R.x*R.x*D+b,R.x*R.y*D-E*R.z,R.x*R.z*D+E*R.y,R.y*R.x*D+E*R.z,R.y*R.y*D+b,R.y*R.z*D-E*R.x,R.z*R.x*D-E*R.y,R.z*R.y*D+E*R.x,R.z*R.z*D+b,M);return y.setupInverseTranspose(),y}}static createRotationAroundAxisIndex(y,k,M){const b=k.cos(),E=k.sin();let R;return R=y===D.X?xt.createRowValues(1,0,0,0,b,-E,0,E,b,M):y===D.Y?xt.createRowValues(b,0,E,0,1,0,-E,0,b,M):xt.createRowValues(b,-E,0,E,b,0,0,0,1,M),R.setupInverseTranspose(),R}applyGivensRowOp(y,k,M,b){let E=3*y,D=3*k;const R=E+3;for(;E<R;E++,D++){const y=this.coffs[E],k=this.coffs[D];this.coffs[E]=y*M+k*b,this.coffs[D]=-y*b+k*M}}applyGivensColumnOp(y,k,M,b){const E=y+9;for(;y<E;y+=3,k+=3){const E=this.coffs[y],D=this.coffs[k];this.coffs[y]=E*M+D*b,this.coffs[k]=-E*b+D*M}}static createColumns(y,k,M,b){return xt.createRowValues(y.x,k.x,M.x,y.y,k.y,M.y,y.z,k.z,M.z,b)}static createColumnsXYW(y,k,M,b,E,D,R){return xt.createRowValues(y.x,M.x,E.x,y.y,M.y,E.y,k,b,D,R)}static createViewedAxes(y,k,M=0,b=0){const E=y.crossProduct(k);if(E.normalizeInPlace()){const D=xt.createColumns(y,k,E);if(0!==M){let y=Math.sqrt(.5),k=M<0?-y:y;if(1!==Math.abs(M)){const b=W.degreesToRadians(45*M);y=Math.cos(b),k=Math.sin(b)}D.applyGivensColumnOp(2,0,y,k)}if(0!==b){const y=b*Math.atan(Math.sqrt(.5)),k=Math.cos(y),M=Math.sin(y);D.applyGivensColumnOp(1,2,k,-M)}return D}}static createStandardWorldToView(y,k=!1,M){switch(y){case R.Bottom:M=xt.createRowValues(1,0,0,0,-1,0,0,0,-1);break;case R.Left:M=xt.createRowValues(0,-1,0,0,0,1,-1,0,0);break;case R.Right:M=xt.createRowValues(0,1,0,0,0,1,1,0,0);break;case R.Front:M=xt.createRowValues(1,0,0,0,0,1,0,-1,0);break;case R.Back:M=xt.createRowValues(-1,0,0,0,0,1,0,1,0);break;case R.Iso:M=xt.createRowValues(.707106781186548,-.7071067811865476,0,.408248290463863,.408248290463863,.816496580927726,-.577350269189626,-.5773502691896257,.5773502691896257);break;case R.RightIso:M=xt.createRowValues(.707106781186548,.7071067811865476,0,-.408248290463863,.408248290463863,.816496580927726,.577350269189626,-.5773502691896257,.5773502691896257);break;case R.Top:default:M=xt.createIdentity(M)}return k&&M.transposeInPlace(),M}applySymmetricJacobi(y,k,M,b){const E=b.at(y,y),D=b.at(k,k),R=b.at(y,k);if(Math.abs(R)<Q.smallFloatingPoint*(E+D))return 0;const X=W.trigValuesToHalfAngleTrigValues(E-D,2*R),z=X.c,N=X.s;return Math.abs(N)<2e-15?0:(b.applyGivensRowOp(y,k,z,N),b.applyGivensColumnOp(y,k,z,N),M.applyGivensColumnOp(y,k,z,N),Math.abs(R))}symmetricEigenvalues(y,k){const M=this.clone();y.setIdentity(),M.coffs[3]=M.coffs[1],M.coffs[6]=M.coffs[2],M.coffs[7]=M.coffs[5];const b=1e-12*this.sumSquares();for(let E=0;E<7;E++)if(this.applySymmetricJacobi(0,1,y,M)+this.applySymmetricJacobi(0,2,y,M)+this.applySymmetricJacobi(1,2,y,M)<b)return k.set(M.at(0,0),M.at(1,1),M.at(2,2)),!0;return!1}applyFastSymmetricJacobi(y,k,M,b){const E=4*y,D=4*k,R=3*y+k,X=3*k+y,z=3*y+M,N=3*M+y,Y=3*k+M,O=3*M+k,B=this.coffs[E],V=this.coffs[D],U=this.coffs[R];if(Math.abs(U)<Q.smallFloatingPoint*(B+V))return 0;const L=W.trigValuesToHalfAngleTrigValues(B-V,2*U),Z=L.c,q=L.s,jr=Z*Z,Gr=q*q,Jr=2*Z*q;this.coffs[E]=jr*B+Jr*U+Gr*V,this.coffs[D]=Gr*B-Jr*U+jr*V,this.coffs[R]=0,this.coffs[X]=0;const Kr=this.coffs[z],so=this.coffs[Y];return this.coffs[z]=Z*Kr+q*so,this.coffs[Y]=-q*Kr+Z*so,this.coffs[N]=this.coffs[z],this.coffs[O]=this.coffs[Y],b.applyGivensColumnOp(y,k,Z,q),Math.abs(U)}fastSymmetricEigenvalues(y,k){const M=this.clone();y.setIdentity();const b=1e-12*this.sumSquares();for(let E=0;E<7;E++)if(M.applyFastSymmetricJacobi(0,1,2,y)+M.applyFastSymmetricJacobi(0,2,1,y)+M.applyFastSymmetricJacobi(1,2,0,y)<b)return k.set(M.at(0,0),M.at(1,1),M.at(2,2)),!0;return!1}getAxisAndAngleOfRotation(){const y=this.coffs[0]+this.coffs[4]+this.coffs[8],k=this.coffs[3]-this.coffs[1],M=this.coffs[7]-this.coffs[5],b=this.coffs[2]-this.coffs[6],E=(y-1)/2,D=Q.hypotenuseXYZ(k,M,b)/2,R=E*E+D*D-1;if(Math.abs(R)>Q.smallAngleRadians)return{axis:$.create(0,0,1),angle:W.createRadians(0),ok:!1};if(Math.abs(D)<Q.smallAngleRadians){if(E>0)return{axis:$.create(0,0,1),angle:W.createRadians(0),ok:!0};const y=this.coffs[0],k=this.coffs[4],M=this.coffs[8];if(Q.isAlmostEqualNumber(-1,k)&&Q.isAlmostEqualNumber(-1,M))return{axis:$.create(1,0,0),angle:W.createDegrees(180),ok:!0};if(Q.isAlmostEqualNumber(-1,y)&&Q.isAlmostEqualNumber(-1,M))return{axis:$.create(0,1,0),angle:W.createDegrees(180),ok:!0};if(Q.isAlmostEqualNumber(-1,y)&&Q.isAlmostEqualNumber(-1,k))return{axis:$.create(0,0,1),angle:W.createDegrees(180),ok:!0};const b=xt.createIdentity(),D=$.create(0,0,0);if(this.fastSymmetricEigenvalues(b,D)){for(let y=0;y<2;y++){const k=D.at(y);if(Q.isAlmostEqualNumber(1,k))return{axis:b.getColumn(y),angle:W.createDegrees(180),ok:!0}}return{axis:$.create(0,0,1),angle:W.createRadians(0),ok:!1}}return{axis:$.create(0,0,1),angle:W.createRadians(0),ok:!1}}const X=1/(2*D);return{axis:$.create(M*X,b*X,k*X),angle:W.createAtan2(D,E),ok:!0}}applyJacobiColumnRotation(y,k,M){const b=this.coffs[y]*this.coffs[y]+this.coffs[y+3]*this.coffs[y+3]+this.coffs[y+6]*this.coffs[y+6],E=this.coffs[k]*this.coffs[k]+this.coffs[k+3]*this.coffs[k+3]+this.coffs[k+6]*this.coffs[k+6],D=this.coffs[y]*this.coffs[k]+this.coffs[y+3]*this.coffs[k+3]+this.coffs[y+6]*this.coffs[k+6],R=W.trigValuesToHalfAngleTrigValues(b-E,2*D),X=R.c,z=R.s;return Math.abs(z)<2e-15?0:(this.applyGivensColumnOp(y,k,X,z),M.applyGivensRowOp(y,k,X,z),Math.abs(D))}factorPerpendicularColumns(y,k){y.setFrom(this),k.setIdentity();const M=1e-12*this.sumSquares();for(let b=0;b<7;b++)if(y.applyJacobiColumnRotation(0,1,k)+y.applyJacobiColumnRotation(0,2,k)+y.applyJacobiColumnRotation(1,2,k)<M)return!0;return!1}factorOrthogonalScaleOrthogonal(y,k,M){const b=xt.createZero();if(!this.factorPerpendicularColumns(b,M))return!1;const D=[];D.push(b.getColumn(0)),D.push(b.getColumn(1)),D.push(b.getColumn(2)),k.set(D[0].magnitude(),D[1].magnitude(),D[2].magnitude()),b.determinant()<0&&(k.z=-k.z);const R=Q.smallFloatingPoint,X=Math.abs(k.x)<R,z=Math.abs(k.y)<R,N=Math.abs(k.z)<R;return X||z||N?X||z?X?y.setIdentity():y=xt.createRigidHeadsUp(D[0],E.XYZ,y):(D[0].scaleInPlace(1/k.x),D[1].scaleInPlace(1/k.y),D[2]=D[0].unitCrossProduct(D[1],D[2]),y.setColumns(D[0],D[1],D[2])):y=b.scaleColumns(1/k.x,1/k.y,1/k.z,y),!0}static createPartialRotationVectorToVector(y,k,M,b){let E=y.unitCrossProduct(M);return E?xt.createRotationAroundVector(E,W.createRadians(k*y.planarAngleTo(M,E).radians)):Q.isSmallMetricDistance(y.magnitude())||Q.isSmallMetricDistance(M.magnitude())?void 0:y.dotProduct(M)>0?xt.createIdentity(b):(E=xt.createPerpendicularVectorFavorPlaneContainingZ(y,E),xt.createRotationAroundVector(E,W.createRadians(k*Math.PI)))}static createRotationVectorToVector(y,k,M){return this.createPartialRotationVectorToVector(y,1,k,M)}static create90DegreeRotationAroundAxis(y){if(0===(y=Q.cyclic3dAxis(y))){const y=xt.createRowValues(1,0,0,0,0,-1,0,1,0);return y.setupInverseTranspose(),y}if(1===y){const y=xt.createRowValues(0,0,1,0,1,0,-1,0,0);return y.setupInverseTranspose(),y}{const y=xt.createRowValues(0,-1,0,1,0,0,0,0,1);return y.setupInverseTranspose(),y}}columnX(y){return $.create(this.coffs[0],this.coffs[3],this.coffs[6],y)}columnY(y){return $.create(this.coffs[1],this.coffs[4],this.coffs[7],y)}columnZ(y){return $.create(this.coffs[2],this.coffs[5],this.coffs[8],y)}columnXMagnitudeSquared(){return Q.hypotenuseSquaredXYZ(this.coffs[0],this.coffs[3],this.coffs[6])}columnYMagnitudeSquared(){return Q.hypotenuseSquaredXYZ(this.coffs[1],this.coffs[4],this.coffs[7])}columnZMagnitudeSquared(){return Q.hypotenuseSquaredXYZ(this.coffs[2],this.coffs[5],this.coffs[8])}columnXMagnitude(){return Q.hypotenuseXYZ(this.coffs[0],this.coffs[3],this.coffs[6])}columnYMagnitude(){return Q.hypotenuseXYZ(this.coffs[1],this.coffs[4],this.coffs[7])}columnZMagnitude(){return Q.hypotenuseXYZ(this.coffs[2],this.coffs[5],this.coffs[8])}columnXYCrossProductMagnitude(){return Q.crossProductMagnitude(this.coffs[0],this.coffs[3],this.coffs[6],this.coffs[1],this.coffs[4],this.coffs[7])}rowXMagnitude(){return Q.hypotenuseXYZ(this.coffs[0],this.coffs[1],this.coffs[2])}rowYMagnitude(){return Q.hypotenuseXYZ(this.coffs[3],this.coffs[4],this.coffs[5])}rowZMagnitude(){return Q.hypotenuseXYZ(this.coffs[6],this.coffs[7],this.coffs[8])}columnXDotColumnY(){return this.coffs[0]*this.coffs[1]+this.coffs[3]*this.coffs[4]+this.coffs[6]*this.coffs[7]}columnXDotColumnZ(){return this.coffs[0]*this.coffs[2]+this.coffs[3]*this.coffs[5]+this.coffs[6]*this.coffs[8]}columnYDotColumnZ(){return this.coffs[1]*this.coffs[2]+this.coffs[4]*this.coffs[5]+this.coffs[7]*this.coffs[8]}columnDotXYZ(y,k,M,b){return this.coffs[y]*k+this.coffs[y+3]*M+this.coffs[y+6]*b}rowX(y){return $.create(this.coffs[0],this.coffs[1],this.coffs[2],y)}rowY(y){return $.create(this.coffs[3],this.coffs[4],this.coffs[5],y)}rowZ(y){return $.create(this.coffs[6],this.coffs[7],this.coffs[8],y)}dotColumnX(y){return y.x*this.coffs[0]+y.y*this.coffs[3]+y.z*this.coffs[6]}dotColumnY(y){return y.x*this.coffs[1]+y.y*this.coffs[4]+y.z*this.coffs[7]}dotColumnZ(y){return y.x*this.coffs[2]+y.y*this.coffs[5]+y.z*this.coffs[8]}dotRowX(y){return y.x*this.coffs[0]+y.y*this.coffs[1]+y.z*this.coffs[2]}dotRowY(y){return y.x*this.coffs[3]+y.y*this.coffs[4]+y.z*this.coffs[5]}dotRowZ(y){return y.x*this.coffs[6]+y.y*this.coffs[7]+y.z*this.coffs[8]}dotRowXXYZ(y,k,M){return y*this.coffs[0]+k*this.coffs[1]+M*this.coffs[2]}dotRowYXYZ(y,k,M){return y*this.coffs[3]+k*this.coffs[4]+M*this.coffs[5]}dotRowZXYZ(y,k,M){return y*this.coffs[6]+k*this.coffs[7]+M*this.coffs[8]}columnZCrossVector(y,k){return Q.crossProductXYZXYZ(this.coffs[2],this.coffs[5],this.coffs[8],y.x,y.y,y.z,k)}setColumnsPoint4dXYZ(y,k,M){this.inverseState=Y.unknown,this.setRowValues(y.x,k.x,M.x,y.y,k.y,M.y,y.z,k.z,M.z)}setColumn(y,k){const M=Q.cyclic3dAxis(y);this.inverseState=Y.unknown,k?(this.coffs[M]=k.x,this.coffs[M+3]=k.y,this.coffs[M+6]=k.z):(this.coffs[M]=0,this.coffs[M+3]=0,this.coffs[M+6]=0)}setColumns(y,k,M){this.setColumn(0,y),this.setColumn(1,k),this.setColumn(2,M)}setRow(y,k){const M=3*Q.cyclic3dAxis(y);this.coffs[M]=k.x,this.coffs[M+1]=k.y,this.coffs[M+2]=k.z,this.inverseState=Y.unknown}getColumn(y,k){const M=Q.cyclic3dAxis(y);return $.create(this.coffs[M],this.coffs[M+3],this.coffs[M+6],k)}getRow(y,k){const M=3*Q.cyclic3dAxis(y);return $.create(this.coffs[M],this.coffs[M+1],this.coffs[M+2],k)}static createRows(y,k,M,b){return xt.createRowValues(y.x,y.y,y.z,k.x,k.y,k.z,M.x,M.y,M.z,b)}static createDirectionalScale(y,k,M){const b=y.normalize();if(b){const y=b.x,E=b.y,D=b.z,R=k-1;return xt.createRowValues(1+R*y*y,R*y*E,R*y*D,R*E*y,1+R*E*E,R*E*D,R*D*y,R*D*E,1+R*D*D,M)}return xt.createUniformScale(k)}static createFlattenAlongVectorToPlane(y,k){const M=xt.createIdentity(),b=y.dotProduct(k),E=Q.conditionalDivideCoordinate(1,-b);if(void 0!==E)return M.addScaledOuterProductInPlace(y,k,E),M}multiplyPoint(y,k){const M=y.x,b=y.y,E=y.z;return j.create(this.coffs[0]*M+this.coffs[1]*b+this.coffs[2]*E,this.coffs[3]*M+this.coffs[4]*b+this.coffs[5]*E,this.coffs[6]*M+this.coffs[7]*b+this.coffs[8]*E,k)}multiplyVector(y,k){const M=y.x,b=y.y,E=y.z;return $.create(this.coffs[0]*M+this.coffs[1]*b+this.coffs[2]*E,this.coffs[3]*M+this.coffs[4]*b+this.coffs[5]*E,this.coffs[6]*M+this.coffs[7]*b+this.coffs[8]*E,k)}multiplyVectorArrayInPlace(y){for(const k of y)k.set(this.coffs[0]*k.x+this.coffs[1]*k.y+this.coffs[2]*k.z,this.coffs[3]*k.x+this.coffs[4]*k.y+this.coffs[5]*k.z,this.coffs[6]*k.x+this.coffs[7]*k.y+this.coffs[8]*k.z)}static xyzMinusMatrixTimesXYZ(y,k,M,b){const E=M.x,D=M.y,R=M.z;return j.create(y.x-(k.coffs[0]*E+k.coffs[1]*D+k.coffs[2]*R),y.y-(k.coffs[3]*E+k.coffs[4]*D+k.coffs[5]*R),y.z-(k.coffs[6]*E+k.coffs[7]*D+k.coffs[8]*R),b)}static xyPlusMatrixTimesXY(y,k,M,b){const E=M.x,D=M.y;return H.create(y.x+k.coffs[0]*E+k.coffs[1]*D,y.y+k.coffs[3]*E+k.coffs[4]*D,b)}static xyzPlusMatrixTimesXYZ(y,k,M,b){const E=M.x,D=M.y,R=M.z;return j.create(y.x+k.coffs[0]*E+k.coffs[1]*D+k.coffs[2]*R,y.y+k.coffs[3]*E+k.coffs[4]*D+k.coffs[5]*R,y.z+k.coffs[6]*E+k.coffs[7]*D+k.coffs[8]*R,b)}static xyzPlusMatrixTimesXYZInPlace(y,k,M){const b=M.x,E=M.y,D=M.z;M.x=y.x+k.coffs[0]*b+k.coffs[1]*E+k.coffs[2]*D,M.y=y.y+k.coffs[3]*b+k.coffs[4]*E+k.coffs[5]*D,M.z=y.z+k.coffs[6]*b+k.coffs[7]*E+k.coffs[8]*D}static xyzPlusMatrixTimesCoordinates(y,k,M,b,E,D){return j.create(y.x+k.coffs[0]*M+k.coffs[1]*b+k.coffs[2]*E,y.y+k.coffs[3]*M+k.coffs[4]*b+k.coffs[5]*E,y.z+k.coffs[6]*M+k.coffs[7]*b+k.coffs[8]*E,D)}static xyzPlusMatrixTimesWeightedCoordinates(y,k,M,b,E,D,R){return Dt.create(k.coffs[0]*M+k.coffs[1]*b+k.coffs[2]*E+y.x*D,k.coffs[3]*M+k.coffs[4]*b+k.coffs[5]*E+y.y*D,k.coffs[6]*M+k.coffs[7]*b+k.coffs[8]*E+y.z*D,D,R)}static xyzPlusMatrixTimesWeightedCoordinatesToFloat64Array(y,k,M,b,E,D,R){return(!R||R.length<4)&&(R=new Float64Array(4)),R[0]=k.coffs[0]*M+k.coffs[1]*b+k.coffs[2]*E+y.x*D,R[1]=k.coffs[3]*M+k.coffs[4]*b+k.coffs[5]*E+y.y*D,R[2]=k.coffs[6]*M+k.coffs[7]*b+k.coffs[8]*E+y.z*D,R[3]=D,R}static xyzPlusMatrixTimesCoordinatesToFloat64Array(y,k,M,b,E,D){return(!D||D.length<3)&&(D=new Float64Array(3)),D[0]=k.coffs[0]*M+k.coffs[1]*b+k.coffs[2]*E+y.x,D[1]=k.coffs[3]*M+k.coffs[4]*b+k.coffs[5]*E+y.y,D[2]=k.coffs[6]*M+k.coffs[7]*b+k.coffs[8]*E+y.z,D}multiplyTransposeVector(y,k){k=k||new $;const M=y.x,b=y.y,E=y.z;return k.x=this.coffs[0]*M+this.coffs[3]*b+this.coffs[6]*E,k.y=this.coffs[1]*M+this.coffs[4]*b+this.coffs[7]*E,k.z=this.coffs[2]*M+this.coffs[5]*b+this.coffs[8]*E,k}multiplyXYZ(y,k,M,b){return(b=b||new $).x=this.coffs[0]*y+this.coffs[1]*k+this.coffs[2]*M,b.y=this.coffs[3]*y+this.coffs[4]*k+this.coffs[5]*M,b.z=this.coffs[6]*y+this.coffs[7]*k+this.coffs[8]*M,b}multiplyXYZtoXYZ(y,k){const M=y.x,b=y.y,E=y.z;return k.x=this.coffs[0]*M+this.coffs[1]*b+this.coffs[2]*E,k.y=this.coffs[3]*M+this.coffs[4]*b+this.coffs[5]*E,k.z=this.coffs[6]*M+this.coffs[7]*b+this.coffs[8]*E,k}multiplyXY(y,k,M){return(M=M||new $).x=this.coffs[0]*y+this.coffs[1]*k,M.y=this.coffs[3]*y+this.coffs[4]*k,M.z=this.coffs[6]*y+this.coffs[7]*k,M}originPlusMatrixTimesXY(y,k,M,b){return j.create(y.x+this.coffs[0]*k+this.coffs[1]*M,y.y+this.coffs[3]*k+this.coffs[4]*M,y.z+this.coffs[6]*k+this.coffs[7]*M,b)}multiplyVectorInPlace(y){const k=y.x,M=y.y,b=y.z;y.x=this.coffs[0]*k+this.coffs[1]*M+this.coffs[2]*b,y.y=this.coffs[3]*k+this.coffs[4]*M+this.coffs[5]*b,y.z=this.coffs[6]*k+this.coffs[7]*M+this.coffs[8]*b}multiplyTransposeVectorInPlace(y){const k=y.x,M=y.y,b=y.z;y.x=this.coffs[0]*k+this.coffs[3]*M+this.coffs[6]*b,y.y=this.coffs[1]*k+this.coffs[4]*M+this.coffs[7]*b,y.z=this.coffs[2]*k+this.coffs[5]*M+this.coffs[8]*b}multiplyTransposeXYZ(y,k,M,b){return(b=b||new $).x=this.coffs[0]*y+this.coffs[3]*k+this.coffs[6]*M,b.y=this.coffs[1]*y+this.coffs[4]*k+this.coffs[7]*M,b.z=this.coffs[2]*y+this.coffs[5]*k+this.coffs[8]*M,b}multiplyInverse(y,k){if(this.computeCachedInverse(!0),this.inverseCoffs){const M=y.x,b=y.y,E=y.z;return $.create(this.inverseCoffs[0]*M+this.inverseCoffs[1]*b+this.inverseCoffs[2]*E,this.inverseCoffs[3]*M+this.inverseCoffs[4]*b+this.inverseCoffs[5]*E,this.inverseCoffs[6]*M+this.inverseCoffs[7]*b+this.inverseCoffs[8]*E,k)}}multiplyInverseTranspose(y,k){if(this.computeCachedInverse(!0),this.inverseCoffs){const M=y.x,b=y.y,E=y.z;return $.create(this.inverseCoffs[0]*M+this.inverseCoffs[3]*b+this.inverseCoffs[6]*E,this.inverseCoffs[1]*M+this.inverseCoffs[4]*b+this.inverseCoffs[7]*E,this.inverseCoffs[2]*M+this.inverseCoffs[5]*b+this.inverseCoffs[8]*E,k)}}multiplyInverseXYZAsVector3d(y,k,M,b){if(this.computeCachedInverse(!0),this.inverseCoffs)return $.create(this.inverseCoffs[0]*y+this.inverseCoffs[1]*k+this.inverseCoffs[2]*M,this.inverseCoffs[3]*y+this.inverseCoffs[4]*k+this.inverseCoffs[5]*M,this.inverseCoffs[6]*y+this.inverseCoffs[7]*k+this.inverseCoffs[8]*M,b)}multiplyInverseXYZW(y,k,M,b,E){if(this.computeCachedInverse(!0),this.inverseCoffs)return Dt.create(this.inverseCoffs[0]*y+this.inverseCoffs[1]*k+this.inverseCoffs[2]*M,this.inverseCoffs[3]*y+this.inverseCoffs[4]*k+this.inverseCoffs[5]*M,this.inverseCoffs[6]*y+this.inverseCoffs[7]*k+this.inverseCoffs[8]*M,b,E)}multiplyInverseXYZAsPoint3d(y,k,M,b){if(this.computeCachedInverse(!0),this.inverseCoffs)return j.create(this.inverseCoffs[0]*y+this.inverseCoffs[1]*k+this.inverseCoffs[2]*M,this.inverseCoffs[3]*y+this.inverseCoffs[4]*k+this.inverseCoffs[5]*M,this.inverseCoffs[6]*y+this.inverseCoffs[7]*k+this.inverseCoffs[8]*M,b)}finishInverseCoffs(y,k,M){k&&M?(this.createInverseCoffsWithZeros(),this.inverseState=Y.inverseStored,y(k,M,this.inverseCoffs)):this.inverseState=Y.unknown}multiplyMatrixMatrix(y,k){return k=k||new xt,mt.multiplyMatrixMatrix(this.coffs,y.coffs,k.coffs),this.inverseState===Y.inverseStored&&y.inverseState===Y.inverseStored?k.finishInverseCoffs(((y,k,M)=>mt.multiplyMatrixMatrix(y,k,M)),y.inverseCoffs,this.inverseCoffs):this.inverseState===Y.singular||y.inverseState===Y.singular?k.inverseState=Y.singular:k.inverseState=Y.unknown,k}multiplyMatrixMatrixInverse(y,k){if(y.computeCachedInverse(!0))return k=k||new xt,mt.multiplyMatrixMatrix(this.coffs,y.inverseCoffs,xt._productBuffer),this.inverseState===Y.inverseStored?k.finishInverseCoffs(((y,k,M)=>mt.multiplyMatrixMatrix(y,k,M)),y.coffs,this.inverseCoffs):k.inverseState=Y.unknown,mt.copy(xt._productBuffer,k.coffs),k}multiplyMatrixInverseMatrix(y,k){if(this.computeCachedInverse(!0))return k=k||new xt,mt.multiplyMatrixMatrix(this.inverseCoffs,y.coffs,xt._productBuffer),y.inverseState===Y.inverseStored?k.finishInverseCoffs(((y,k,M)=>mt.multiplyMatrixMatrix(y,k,M)),y.inverseCoffs,this.coffs):k.inverseState=Y.unknown,mt.copy(xt._productBuffer,k.coffs),k}multiplyMatrixMatrixTranspose(y,k){return k=k||new xt,mt.multiplyMatrixMatrixTranspose(this.coffs,y.coffs,k.coffs),this.inverseState===Y.inverseStored&&y.inverseState===Y.inverseStored?k.finishInverseCoffs(((y,k,M)=>mt.multiplyMatrixTransposeMatrix(y,k,M)),y.inverseCoffs,this.inverseCoffs):this.inverseState===Y.singular||y.inverseState===Y.singular?k.inverseState=Y.singular:k.inverseState=Y.unknown,k}multiplyMatrixTransposeMatrix(y,k){return k=k||new xt,mt.multiplyMatrixTransposeMatrix(this.coffs,y.coffs,k.coffs),this.inverseState===Y.inverseStored&&y.inverseState===Y.inverseStored?k.finishInverseCoffs(((y,k,M)=>mt.multiplyMatrixMatrixTranspose(y,k,M)),y.inverseCoffs,this.inverseCoffs):this.inverseState===Y.singular||y.inverseState===Y.singular?k.inverseState=Y.singular:k.inverseState=Y.unknown,k}multiplyMatrixTransform(y,k){return k?(this.multiplyXYZtoXYZ(y.origin,k.origin),this.multiplyMatrixMatrix(y.matrix,k.matrix),k):pt.createRefs(this.multiplyXYZ(y.origin.x,y.origin.y,y.origin.z),this.multiplyMatrixMatrix(y.matrix))}transpose(y){return y||(y=new xt),mt.copyTransposed(this.coffs,y.coffs),void 0!==this.inverseCoffs?(y.inverseState=Y.inverseStored,y.inverseCoffs=mt.copyTransposed(this.inverseCoffs,y.inverseCoffs)):(y.inverseState=this.inverseState,y.inverseCoffs=void 0),y}transposeInPlace(){mt.transposeInPlace(this.coffs),this.inverseCoffs&&mt.transposeInPlace(this.inverseCoffs)}inverse(y){if(this.computeCachedInverse(!0))return y===this?(mt.copy(this.coffs,xt._productBuffer),mt.copy(this.inverseCoffs,this.coffs),mt.copy(xt._productBuffer,this.inverseCoffs),y):(void 0===y&&(y=xt.createIdentity()),y.createInverseCoffsWithZeros(),mt.copy(this.coffs,y.inverseCoffs),mt.copy(this.inverseCoffs,y.coffs),y.inverseState=this.inverseState,y)}static rowColumnDot(y,k,M,b){return y[k]*M[b]+y[k+1]*M[b+3]+y[k+2]*M[b+6]}static indexedRowCrossProduct(y,k,M,b,E){b[E]=y[k+1]*y[M+2]-y[k+2]*y[M+1],b[E+3]=y[k+2]*y[M]-y[k]*y[M+2],b[E+6]=y[k]*y[M+1]-y[k+1]*y[M]}indexedColumnCrossProductInPlace(y,k,M){const b=this.coffs;b[M]=b[y+3]*b[k+6]-b[y+6]*b[k+3],b[M+3]=b[y+6]*b[k]-b[y]*b[k+6],b[M+6]=b[y]*b[k+3]-b[y+3]*b[k]}axisOrderCrossProductsInPlace(y){switch(y){case E.XYZ:this.indexedColumnCrossProductInPlace(0,1,2),this.indexedColumnCrossProductInPlace(2,0,1);break;case E.YZX:this.indexedColumnCrossProductInPlace(1,2,0),this.indexedColumnCrossProductInPlace(0,1,2);break;case E.ZXY:this.indexedColumnCrossProductInPlace(2,0,1),this.indexedColumnCrossProductInPlace(1,2,0);break;case E.XZY:this.indexedColumnCrossProductInPlace(0,2,1),this.indexedColumnCrossProductInPlace(1,0,2);break;case E.YXZ:this.indexedColumnCrossProductInPlace(1,0,2),this.indexedColumnCrossProductInPlace(2,1,0);break;case E.ZYX:this.indexedColumnCrossProductInPlace(2,1,0),this.indexedColumnCrossProductInPlace(0,2,1)}}normalizeColumnsInPlace(y){const k=this.columnXMagnitude(),M=this.columnYMagnitude(),b=this.columnZMagnitude();return y&&y.set(k,M,b),!(Q.isSmallMetricDistance(k)||Q.isSmallMetricDistance(M)||Q.isSmallMetricDistance(b)||(this.scaleColumns(1/k,1/M,1/b,this),0))}normalizeRowsInPlace(y){const k=this.rowXMagnitude(),M=this.rowYMagnitude(),b=this.rowZMagnitude();return y&&y.set(k,M,b),!(Q.isSmallMetricDistance(k)||Q.isSmallMetricDistance(M)||Q.isSmallMetricDistance(b)||(this.scaleRows(1/k,1/M,1/b,this),0))}isSingular(){return!this.computeCachedInverse(!0)}markSingular(){this.inverseState=Y.singular}computeCachedInverse(y){if(y&&xt.useCachedInverse&&this.inverseState!==Y.unknown)return xt.numUseCache++,this.inverseState===Y.inverseStored;this.inverseState=Y.unknown,this.createInverseCoffsWithZeros();const k=this.coffs,M=this.inverseCoffs;xt.indexedRowCrossProduct(k,3,6,M,0),xt.indexedRowCrossProduct(k,6,0,M,1),xt.indexedRowCrossProduct(k,0,3,M,2),xt.numComputeCache++;const b=xt.rowColumnDot(k,0,M,0);if(0===b)return this.inverseState=Y.singular,this.inverseCoffs=void 0,!1;const E=1/b;for(let D=0;D<9;D++)M[D]*=E;return this.inverseState=Y.inverseStored,!0}static flatIndexOf(y,k){return 3*Q.cyclic3dAxis(y)+Q.cyclic3dAxis(k)}indexedColumnWithWeight(y,k,M){return y=Q.cyclic3dAxis(y),Dt.create(this.coffs[y],this.coffs[y+3],this.coffs[y+6],k,M)}at(y,k){return this.coffs[xt.flatIndexOf(y,k)]}setAt(y,k,M){this.coffs[xt.flatIndexOf(y,k)]=M,this.inverseState=Y.unknown}scale(y,k){return xt.createRowValues(this.coffs[0]*y,this.coffs[1]*y,this.coffs[2]*y,this.coffs[3]*y,this.coffs[4]*y,this.coffs[5]*y,this.coffs[6]*y,this.coffs[7]*y,this.coffs[8]*y,k)}scaleColumns(y,k,M,b){return xt.createRowValues(this.coffs[0]*y,this.coffs[1]*k,this.coffs[2]*M,this.coffs[3]*y,this.coffs[4]*k,this.coffs[5]*M,this.coffs[6]*y,this.coffs[7]*k,this.coffs[8]*M,b)}scaleColumnsInPlace(y,k,M){if(this.coffs[0]*=y,this.coffs[1]*=k,this.coffs[2]*=M,this.coffs[3]*=y,this.coffs[4]*=k,this.coffs[5]*=M,this.coffs[6]*=y,this.coffs[7]*=k,this.coffs[8]*=M,this.inverseState===Y.inverseStored&&void 0!==this.inverseCoffs){const b=Q.conditionalDivideFraction(1,y),E=Q.conditionalDivideFraction(1,k),D=Q.conditionalDivideFraction(1,M);void 0!==b&&void 0!==E&&void 0!==D?(this.inverseCoffs[0]*=b,this.inverseCoffs[1]*=b,this.inverseCoffs[2]*=b,this.inverseCoffs[3]*=E,this.inverseCoffs[4]*=E,this.inverseCoffs[5]*=E,this.inverseCoffs[6]*=D,this.inverseCoffs[7]*=D,this.inverseCoffs[8]*=D):this.inverseState=Y.singular}}scaleRows(y,k,M,b){return xt.createRowValues(this.coffs[0]*y,this.coffs[1]*y,this.coffs[2]*y,this.coffs[3]*k,this.coffs[4]*k,this.coffs[5]*k,this.coffs[6]*M,this.coffs[7]*M,this.coffs[8]*M,b)}scaleRowsInPlace(y,k,M){if(this.coffs[0]*=y,this.coffs[1]*=y,this.coffs[2]*=y,this.coffs[3]*=k,this.coffs[4]*=k,this.coffs[5]*=k,this.coffs[6]*=M,this.coffs[7]*=M,this.coffs[8]*=M,this.inverseState===Y.inverseStored&&void 0!==this.inverseCoffs){const b=Q.conditionalDivideFraction(1,y),E=Q.conditionalDivideFraction(1,k),D=Q.conditionalDivideFraction(1,M);void 0!==b&&void 0!==E&&void 0!==D?(this.inverseCoffs[0]*=b,this.inverseCoffs[1]*=E,this.inverseCoffs[2]*=D,this.inverseCoffs[3]*=b,this.inverseCoffs[4]*=E,this.inverseCoffs[5]*=D,this.inverseCoffs[6]*=b,this.inverseCoffs[7]*=E,this.inverseCoffs[8]*=D):this.inverseState=Y.singular}}addScaledInPlace(y,k){for(let M=0;M<9;M++)this.coffs[M]+=k*y.coffs[M];this.inverseState=Y.unknown}addScaledOuterProductInPlace(y,k,M){this.coffs[0]+=M*y.x*k.x,this.coffs[1]+=M*y.x*k.y,this.coffs[2]+=M*y.x*k.z,this.coffs[3]+=M*y.y*k.x,this.coffs[4]+=M*y.y*k.y,this.coffs[5]+=M*y.y*k.z,this.coffs[6]+=M*y.z*k.x,this.coffs[7]+=M*y.z*k.y,this.coffs[8]+=M*y.z*k.z,this.inverseState=Y.unknown}static createRigidViewAxesZTowardsEye(y,k,M,b){b=xt.createIdentity(b);const E=Q.hypotenuseXY(y,k);if(Q.isSmallMetricDistance(E))M<0&&b.scaleColumnsInPlace(1,-1,-1);else{const D=y/E,R=k/E;if(b.setRowValues(-R,0,D,D,0,R,0,1,0),0!==M){const D=Q.hypotenuseXYZ(y,k,M),R=M/D,X=E/D;b.applyGivensColumnOp(1,2,X,-R)}}return b}determinant(){return this.coffs[0]*this.coffs[4]*this.coffs[8]-this.coffs[0]*this.coffs[5]*this.coffs[7]-this.coffs[1]*this.coffs[3]*this.coffs[8]+this.coffs[1]*this.coffs[5]*this.coffs[6]+this.coffs[2]*this.coffs[3]*this.coffs[7]-this.coffs[2]*this.coffs[4]*this.coffs[6]}conditionNumber(){const y=Math.abs(this.determinant()),k=Q.hypotenuseXYZ(this.coffs[0],this.coffs[3],this.coffs[6])+Q.hypotenuseXYZ(this.coffs[1],this.coffs[4],this.coffs[7])+Q.hypotenuseXYZ(this.coffs[2],this.coffs[5],this.coffs[8]);return Q.safeDivideFraction(y,k,0)}sumSquares(){let y=0;for(let k=0;k<9;k++)y+=this.coffs[k]*this.coffs[k];return y}sumDiagonalSquares(){let y=0;for(let k=0;k<9;k+=4)y+=this.coffs[k]*this.coffs[k];return y}sumDiagonal(){return this.coffs[0]+this.coffs[4]+this.coffs[8]}maxAbs(){let y=0;for(let k=0;k<9;k++)y=Math.max(y,Math.abs(this.coffs[k]));return y}maxDiff(y){let k=0;for(let M=0;M<9;M++)k=Math.max(k,Math.abs(this.coffs[M]-y.coffs[M]));return k}get isIdentity(){return this.maxDiff(xt.identity)<Q.smallAngleRadians}get isDiagonal(){const y=this.sumSquares(),k=this.sumDiagonalSquares(),M=Math.abs(y-k);return Math.sqrt(M)<=Q.smallAngleRadians*(1+Math.sqrt(y))}sumSkewSquares(){return Q.hypotenuseSquaredXYZ(this.coffs[1]-this.coffs[3],this.coffs[2]-this.coffs[6],this.coffs[5]-this.coffs[7])}isSymmetric(){const y=this.sumSkewSquares();return Math.sqrt(y)<=Q.smallAngleRadians*(1+Math.sqrt(this.sumSquares()))}get hasCachedInverse(){return this.inverseState===Y.inverseStored&&void 0!==this.inverseCoffs}get isUpperTriangular(){const y=this.sumSquares(),k=Q.hypotenuseSquaredXYZ(this.coffs[3],this.coffs[6],this.coffs[7]);return Math.sqrt(k)<=Q.smallAngleRadians*(1+Math.sqrt(y))}get isLowerTriangular(){const y=this.sumSquares(),k=Q.hypotenuseSquaredXYZ(this.coffs[1],this.coffs[2],this.coffs[5]);return Math.sqrt(k)<=Q.smallAngleRadians*(1+Math.sqrt(y))}sameDiagonalScale(){const y=this.sumSquares(),k=this.sumDiagonalSquares(),M=Math.abs(y-k);if(Math.sqrt(M)<=Q.smallAngleRadians*(1+Math.sqrt(y))&&Q.isSameCoordinate(this.coffs[0],this.coffs[4])&&Q.isSameCoordinate(this.coffs[0],this.coffs[8]))return this.coffs[0]}testPerpendicularUnitRowsAndColumns(){return this.multiplyMatrixMatrixTranspose(this).isIdentity}isRigid(y=!1){return this.testPerpendicularUnitRowsAndColumns()&&(y||this.determinant()>0)}factorRigidWithSignedScale(y){const k=this.multiplyMatrixMatrixTranspose(this).sameDiagonalScale();if(void 0===k||k<=0)return;const M=this.determinant()>0?Math.sqrt(k):-Math.sqrt(k),b=1/M;return{rigidAxes:this.scaleColumns(b,b,b,y),scale:M}}factorRigidSkew(y,k,M=E.XYZ){return xt.createRigidFromMatrix3d(this,M,y)?(y.multiplyMatrixTransposeMatrix(this,k),!0):(y.setIdentity(),k.setFrom(this),!1)}get isSignedPermutation(){let y=0;for(let k=0;k<3;k++)for(let M=0;M<3;M++){const b=this.at(k,M);if(0===b);else{if(1!==b&&-1!==b)return!1;if(y++,0!==this.at(k+1,M)||0!==this.at(k+2,M)||0!==this.at(k,M+1)||0!==this.at(k,M+2))return!1}}return 3===y}makeRigid(y=E.XYZ){const k=this.maxAbs();if(Q.isSmallMetricDistance(k))return!1;const M=1/k;return this.scaleColumnsInPlace(M,M,M),this.axisOrderCrossProductsInPlace(y),this.normalizeColumnsInPlace()}static createRigidFromMatrix3d(y,k=E.XYZ,M){if((M=y.clone(M)).makeRigid(k))return M}static createFromQuaternion(y){const k=y.x*y.x,M=y.y*y.y,b=y.z*y.z,E=y.w*y.w,D=k+M+b+E;if(0===D)return xt.createIdentity();{const R=1/D;return xt.createRowValues(R*(E+k-M-b),2*R*(y.w*y.z+y.x*y.y),2*R*(y.x*y.z-y.w*y.y),2*R*(y.x*y.y-y.w*y.z),R*(E-k+M-b),2*R*(y.w*y.x+y.y*y.z),2*R*(y.x*y.z+y.w*y.y),2*R*(y.y*y.z-y.w*y.x),R*(E-k-M+b))}}static computeQuatTerm(y,k,M,b){let E;return b>.5?(E=.5*Math.sqrt(b),k*y<0&&(E=-E)):E=y*M,E}toQuaternion(){const y=Dt.createZero(),k=[[this.coffs[0],this.coffs[3],this.coffs[6]],[this.coffs[1],this.coffs[4],this.coffs[7]],[this.coffs[2],this.coffs[5],this.coffs[8]]],M=k[0][0],b=k[1][1],E=k[2][2],D=[];let R;D[0]=1+M-b-E,D[1]=1-M+b-E,D[2]=1-M-b+E,D[3]=1+M+b+E;let X=0;for(let z=1;z<=3;z++)D[z]>D[X]&&(X=z);return 0===X?(y.x=.5*Math.sqrt(D[0]),R=1/(4*y.x),y.y=xt.computeQuatTerm(k[0][1]+k[1][0],y.x,R,D[1]),y.z=xt.computeQuatTerm(k[0][2]+k[2][0],y.x,R,D[2]),y.w=xt.computeQuatTerm(k[2][1]-k[1][2],y.x,R,D[3])):1===X?(y.y=.5*Math.sqrt(D[1]),R=1/(4*y.y),y.x=xt.computeQuatTerm(k[0][1]+k[1][0],y.y,R,D[0]),y.z=xt.computeQuatTerm(k[1][2]+k[2][1],y.y,R,D[2]),y.w=xt.computeQuatTerm(k[0][2]-k[2][0],y.y,R,D[3])):2===X?(y.z=.5*Math.sqrt(D[2]),R=1/(4*y.z),y.x=xt.computeQuatTerm(k[0][2]+k[2][0],y.z,R,D[0]),y.y=xt.computeQuatTerm(k[1][2]+k[2][1],y.z,R,D[1]),y.w=xt.computeQuatTerm(k[1][0]-k[0][1],y.z,R,D[3])):(y.w=.5*Math.sqrt(D[3]),R=1/(4*y.w),y.x=xt.computeQuatTerm(k[2][1]-k[1][2],y.w,R,D[0]),y.y=xt.computeQuatTerm(k[0][2]-k[2][0],y.w,R,D[1]),y.z=xt.computeQuatTerm(k[1][0]-k[0][1],y.w,R,D[2])),y}}xt.useCachedInverse=!0,xt.numUseCache=0,xt.numComputeCache=0,xt._productBuffer=new Float64Array(9);class _t extends tt{constructor(y,k){super(),this._origin=y,this._normal=k}static _create(y,k,M,b,E,D){return new _t(j.create(y,k,M),$.create(b,E,D))}static createXYPlane(y){return y?_t._create(y.x,y.y,y.z,0,0,1):_t._create(0,0,0,0,0,1)}static createYZPlane(y){return y?_t._create(y.x,y.y,y.z,1,0,0):_t._create(0,0,0,1,0,0)}static createZXPlane(y){return y?_t._create(y.x,y.y,y.z,0,1,0):_t._create(0,0,0,0,1,0)}static create(y,k,M){if(M){if(void 0===k.normalize(M._normal))return;return y.clone(M._origin),M}const b=k.normalize();if(void 0!==b)return new _t(y.clone(),b)}static createFrom(y,k){if(y instanceof _t)return y.clone(k);if(k){if(void 0===y.getUnitNormal(k._normal))return;return y.getAnyPointOnPlane(k._origin),k}const M=y.getUnitNormal();if(void 0===M)return;const b=y.getAnyPointOnPlane();return new _t(b,M)}static createXYZUVW(y,k,M,b,E,D,R){const X=Q.hypotenuseXYZ(b,E,D);if(!(X<Q.smallMetricDistance))return R?(R._origin.set(y,k,M),R._normal.set(b/X,E/X,D/X),R):new _t(j.create(y,k,M),$.create(b/X,E/X,D/X))}static createOriginAndTargetXY(y,k,M){const b=k.x-y.x,E=k.y-y.y;return this.createXYZUVW(y.x,y.y,0,E,-b,0,M)}static createXYAngle(y,k,M,b){return b?(b._origin.set(y,k,0),b._normal.set(M.cos(),M.sin(),0),b):new _t(j.create(y,k,0),$.create(M.cos(),M.sin()))}static createPointPointVectorInPlane(y,k,M){const b=M.crossProductStartEnd(y,k);if(b.tryNormalizeInPlace())return new _t(y,b)}static createOriginAndTargets(y,k,M){const b=y.crossProductToPoints(k,M);if(b.tryNormalizeInPlace())return new _t(y,b)}static createOriginAndVectors(y,k,M){const b=k.crossProduct(M);if(b.tryNormalizeInPlace())return new _t(y,b)}isAlmostEqual(y){return this._origin.isAlmostEqual(y._origin)&&this._normal.isAlmostEqual(y._normal)}setFromJSON(y){y?(this._origin.setFromJSON(y.origin),this._normal.setFromJSON(y.normal)):(this._origin.set(0,0,0),this._normal.set(0,0,1))}toJSON(){return{origin:this._origin.toJSON(),normal:this._normal.toJSON()}}static fromJSON(y){const k=_t.createXYPlane();return k.setFromJSON(y),k}getOriginRef(){return this._origin}getNormalRef(){return this._normal}getLocalToWorld(){const y=xt.createRigidHeadsUp(this._normal,E.ZXY);return pt.createRefs(this._origin.clone(),y)}getProjectionToPlane(){const y=xt.createIdentity();return y.addScaledOuterProductInPlace(this._normal,this._normal,-1),y.markSingular(),pt.createFixedPointAndMatrix(this._origin,y)}set(y,k){this._origin.setFrom(y),this._normal.setFrom(k)}clone(y){return y?(y.set(this._origin,this._normal),y):new _t(this._origin.clone(),this._normal.clone())}cloneTransformed(y,k=!1){const M=this.clone();if(k){if(y.multiplyInversePoint3d(M._origin,M._origin),void 0!==y.matrix.multiplyTransposeVector(M._normal,M._normal)&&M._normal.normalizeInPlace())return M}else if(y.multiplyPoint3d(M._origin,M._origin),void 0!==y.matrix.multiplyInverseTranspose(M._normal,M._normal)&&M._normal.normalizeInPlace())return M}setFrom(y){this.set(y._origin,y._normal)}altitude(y){return this._normal.dotProductStartEnd(this._origin,y)}altitudeXY(y,k){return(y-this._origin.x)*this._normal.x+(k-this._origin.y)*this._normal.y}normalX(){return this._normal.x}normalY(){return this._normal.y}normalZ(){return this._normal.z}getUnitNormal(y){return this._normal.clone(y)}getAnyPointOnPlane(y){return this._origin.clone(y)}weightedAltitude(y){return this._normal.dotProductStart3dEnd4d(this._origin,y)}altitudeToPoint(y,k){return this._origin.plusScaled(this._normal,y,k)}velocityXYZ(y,k,M){return this._normal.dotProductXYZ(y,k,M)}velocity(y){return this._normal.dotProduct(y)}altitudeXYZ(y,k,M){return this._normal.dotProductStartEndXYZ(this._origin,y,k,M)}altitudeXYZW(y,k,M,b){return this._normal.dotProductStartEndXYZW(this._origin,y,k,M,b)}projectPointToPlane(y,k){return y.plusScaled(this._normal,-this._normal.dotProductStartEnd(this._origin,y),k)}isPointInPlane(y,k=Q.smallMetricDistance){const M=this._normal.dotProductStartEnd(this._origin,y);return Math.abs(M)<=k}}function yt(y,k){return y?y.clone(k):void 0}!function(y){y[y.isolated=0]="isolated",y[y.isolatedAtVertex=1]="isolatedAtVertex",y[y.intervalStart=10]="intervalStart",y[y.intervalInterior=11]="intervalInterior",y[y.intervalEnd=12]="intervalEnd"}(O||(O={})),function(y){y[y.error=0]="error",y[y.success=1]="success",y[y.stoppedAtBoundary=2]="stoppedAtBoundary"}(B||(B={}));class vt{constructor(){this.pointQ=j.createZero(),this.fraction=0,this.point=j.createZero(),this.a=0}setIntervalRole(y){this.intervalRole=y}captureFraction1Point1(y,k){this.fraction1=y,this.point1=k}get hasFraction1(){return void 0!==this.fraction1}get isIsolated(){return void 0===this.intervalRole||this.intervalRole===O.isolated||this.intervalRole===O.isolatedAtVertex}get fractionDelta(){return void 0!==this.fraction1?this.fraction1-this.fraction:0}collapseToEnd(){void 0!==this.fraction1&&(this.fraction=this.fraction1),this.point1&&(this.point=this.point1),this.collapseToStart()}collapseToStart(){this.fraction1=void 0,this.point1=void 0}clone(y){return y===this||((y=y||new vt).curve=this.curve,y.fraction=this.fraction,y.fraction1=this.fraction1,y.point1=yt(this.point1,y.point1),y.point.setFromPoint3d(this.point),y.vectorInCurveLocationDetail=yt(this.vectorInCurveLocationDetail,y.vectorInCurveLocationDetail),y.a=this.a,y.childDetail=yt(this.childDetail,y.childDetail),y.curveSearchStatus=this.curveSearchStatus),y}setFP(y,k,M,b=0){this.fraction=y,this.point.setFromPoint3d(k),this.vectorInCurveLocationDetail=yt(M,this.vectorInCurveLocationDetail),this.a=b}setFR(y,k,M=0){return this.setFP(y,k.origin,k.direction,M)}setCurve(y){this.curve=y}setDistanceTo(y){this.a=this.point.distance(y)}static create(y,k){return(k=k||new vt).curve=y,k}static createCurveFractionPoint(y,k,M,b){return(b=b||new vt).curve=y,b.fraction=k,b.point.setFromPoint3d(M),b.vectorInCurveLocationDetail=void 0,b.a=0,b.childDetail=void 0,b.curveSearchStatus=void 0,b}static createRayFractionPoint(y,k,M,b){return(b=b||new vt).fraction=k,b.ray=y,b.point.setFromPoint3d(M),b}static createCurveFractionPointDistanceCurveSearchStatus(y,k,M,b,E,D){return(D=D||new vt).curve=y,D.fraction=k,D.point.setFromPoint3d(M),D.vectorInCurveLocationDetail=void 0,D.a=b,D.childDetail=void 0,D.curveSearchStatus=E,D}static createConditionalMoveSignedDistance(y,k,M,b,E,D){let R=E,X=B.success;return y||Q.isIn01(b)||(b<0?(R=-k.curveLengthBetweenFractions(M,0),b=0,X=B.stoppedAtBoundary):b>1&&(b=1,R=k.curveLengthBetweenFractions(M,1),X=B.stoppedAtBoundary)),(D=D||new vt).curve=k,D.fraction=b,k.fractionToPoint(b,D.point),D.vectorInCurveLocationDetail=void 0,D.a=R,D.childDetail=void 0,D.curveSearchStatus=X,D}static createCurveEvaluatedFraction(y,k,M){return(M=M||new vt).curve=y,M.fraction=k,y.fractionToPoint(k,M.point),M.vectorInCurveLocationDetail=void 0,M.a=0,M.childDetail=void 0,M.curveSearchStatus=void 0,M}static createCurveEvaluatedFractionPointAndDerivative(y,k,M){(M=M||new vt).curve=y,M.fraction=k;const b=y.fractionToPointAndDerivative(k);return M.point.setFromPoint3d(b.origin),M.vectorInCurveLocationDetail=b.direction,M.a=0,M.childDetail=void 0,M.curveSearchStatus=void 0,M}static createCurveEvaluatedFractionFraction(y,k,M,b){return(b=b||new vt).curve=y,b.fraction=k,y.fractionToPoint(k,b.point),b.fraction1=M,b.point1=y.fractionToPoint(M,b.point1),b.vectorInCurveLocationDetail=void 0,b.a=0,b.childDetail=void 0,b.curveSearchStatus=void 0,b}static createCurveFractionPointDistance(y,k,M,b,E){return(E=E||new vt).curve=y,E.fraction=k,E.point.setFromPoint3d(M),E.vectorInCurveLocationDetail=void 0,E.a=b,E.childDetail=void 0,E.curveSearchStatus=void 0,E}updateIfCloserCurveFractionPointDistance(y,k,M,b){return!(this.a<b||(vt.createCurveFractionPointDistance(y,k,M,b,this),0))}swapFractionsAndPoints(){if(void 0!==this.fraction1){const y=this.fraction;this.fraction=this.fraction1,this.fraction1=y}if(void 0!==this.point1){const y=this.point;this.point=this.point1,this.point1=y}}inverseInterpolateFraction(y,k=0){const M=Q.inverseInterpolate01(this.fraction,this.fraction1,y);return void 0===M?k:M}static chooseSmallerA(y,k){return y?k?y.a<=k.a?y:k:y:k}isSameCurveAndFraction(y){return this.curve===y.curve&&Q.isAlmostEqualNumber(this.fraction,y.fraction)}tryTransformInPlace(y){return!(this.curve&&!this.curve.tryTransformInPlace(y)||(this.ray&&this.ray.transformInPlace(y),this.curve?this.curve.fractionToPoint(this.fraction,this.point):y.multiplyXYAndZInPlace(this.point),this.vectorInCurveLocationDetail&&y.multiplyVectorInPlace(this.vectorInCurveLocationDetail),this.childDetail&&this.childDetail!==this&&!this.childDetail.tryTransformInPlace(y)||(this.point1&&(this.curve&&this.fraction1?this.curve.fractionToPoint(this.fraction1,this.point1):y.multiplyXYAndZInPlace(this.point1)),0)))}}!function(y){y[y.Intersection=0]="Intersection",y[y.PerpendicularChord=1]="PerpendicularChord",y[y.CoincidentGeometry=2]="CoincidentGeometry",y[y.ParallelGeometry=3]="ParallelGeometry"}(V||(V={}));class Pt{constructor(y,k){this.detailA=y||new vt,this.detailB=k||new vt}static createCapture(y,k,M){return(M=M||new Pt).detailA=y,M.detailB=k,M}static createCaptureOptionalReverse(y,k,M,b){return(b=b||new Pt).detailA=y,b.detailB=k,b}clone(y){return(y=y||new Pt).detailA=this.detailA.clone(),y.detailB=this.detailB.clone(),y.approachType=this.approachType,y}swapDetails(){const y=this.detailA;this.detailA=this.detailB,this.detailB=y}static removeAdjacentDuplicates(y,k=0){return y.flatMap(((y,M,b)=>M>=k&&M>0&&!y.detailA.hasFraction1&&!y.detailB.hasFraction1&&y.detailA.isSameCurveAndFraction(b[M-1].detailA)&&y.detailB.isSameCurveAndFraction(b[M-1].detailB)?[]:[y]))}tryTransformInPlace(y){return this.detailA.tryTransformInPlace(y)&&this.detailB.tryTransformInPlace(y)}}class At{get startDegrees(){return W.radiansToDegrees(this._radians0)}get endDegrees(){return W.radiansToDegrees(this._radians1)}get sweepDegrees(){return W.radiansToDegrees(this._radians1-this._radians0)}get startRadians(){return this._radians0}get endRadians(){return this._radians1}get sweepRadians(){return this._radians1-this._radians0}get isEmpty(){return W.isAlmostEqualRadiansNoPeriodShift(0,this.sweepRadians)}get startAngle(){return W.createRadians(this._radians0)}get endAngle(){return W.createRadians(this._radians1)}static create(y){return y instanceof At?y.clone():y instanceof W?new At(0,y.radians):At.create360()}constructor(y=0,k=0){this._radians0=y,this._radians1=k}setStartEndRadians(y=0,k=2*Math.PI){const M=k-y;W.isFullCircleRadians(M)&&(k=y+(M>0?2:-2)*Math.PI),this._radians0=y,this._radians1=k}setStartEndDegrees(y=0,k=360){this.setStartEndRadians(W.degreesToRadians(y),W.degreesToRadians(k))}static createStartEndRadians(y=0,k=2*Math.PI,M){return(M=M||new At).setStartEndRadians(y,k),M}cloneMinusRadians(y){return new At(this._radians0-y,this._radians1-y)}static createStartEndDegrees(y=0,k=360,M){return At.createStartEndRadians(W.degreesToRadians(y),W.degreesToRadians(k),M)}static createStartEnd(y,k,M){return(M=M||new At).setStartEndRadians(y.radians,k.radians),M}static createStartSweepRadians(y=0,k=Math.PI,M){return(M=M||new At).setStartEndRadians(y,y+k),M}static createStartSweepDegrees(y=0,k=360,M){return At.createStartEndRadians(W.degreesToRadians(y),W.degreesToRadians(y+k),M)}static createStartSweep(y,k,M){return At.createStartSweepRadians(y.radians,k.radians,M)}interpolate(y,k){return new At(Q.interpolate(this._radians0,y,k._radians0),Q.interpolate(this._radians1,y,k._radians1))}setFrom(y){this._radians0=y._radians0,this._radians1=y._radians1}static create360(y){return new At(y=y||0,y+2*Math.PI)}static createFullLatitude(){return At.createStartEndRadians(-.5*Math.PI,.5*Math.PI)}reverseInPlace(){const y=this._radians0;this._radians0=this._radians1,this._radians1=y}cloneComplement(y=!1,k){const M=this.sweepRadians>=0?2:-2;return y?At.createStartEndRadians(this.startRadians,this.endRadians-M*Math.PI,k):At.createStartEndRadians(this.endRadians,this.startRadians+M*Math.PI,k)}capLatitudeInPlace(){const y=.5*Math.PI;this._radians0=Q.clampToStartEnd(this._radians0,-y,y),this._radians1=Q.clampToStartEnd(this._radians1,-y,y)}get isCCW(){return this._radians1>=this._radians0}get isFullCircle(){return W.isFullCircleRadians(this.sweepRadians)}get isFullLatitudeSweep(){const y=.5*Math.PI;return W.isAlmostEqualRadiansNoPeriodShift(this._radians0,-y)&&W.isAlmostEqualRadiansNoPeriodShift(this._radians1,y)}clone(){return new At(this._radians0,this._radians1)}fractionToRadians(y){return y<.5?this._radians0+y*(this._radians1-this._radians0):this._radians1+(y-1)*(this._radians1-this._radians0)}fractionToAngle(y){return W.createRadians(this.fractionToRadians(y))}fractionPeriod(){return this.isEmpty?1:W.pi2Radians/Math.abs(this._radians1-this._radians0)}angleToUnboundedFraction(y){return this.isEmpty?1:(y.radians-this._radians0)/(this._radians1-this._radians0)}static fractionToSignedPeriodicFractionStartEnd(y,k,M,b){const E=M-k;if(W.isAlmostEqualRadiansNoPeriodShift(0,E))return y;if(Q.isIn01(y))return y;const D=W.pi2Radians/Math.abs(E);return(y%=D)+D<1&&(y+=D),Q.isIn01(y)||b&&y<0||!b&&y>1?y:b?y-D:y+D}fractionToSignedPeriodicFraction(y,k){return At.fractionToSignedPeriodicFractionStartEnd(y,this._radians0,this._radians1,k)}static radiansToPositivePeriodicFractionStartEnd(y,k,M,b=0){const E=Q.largeCoordinateResult;let D=this.radiansToSignedPeriodicFractionStartEnd(y,k,M,E);return D===E?b:(D<0&&(D+=W.pi2Radians/Math.abs(M-k)),D)}radiansToPositivePeriodicFraction(y,k=0){return At.radiansToPositivePeriodicFractionStartEnd(y,this._radians0,this._radians1,k)}angleToPositivePeriodicFraction(y,k=0){return this.radiansToPositivePeriodicFraction(y.radians,k)}radiansArrayToPositivePeriodicFractions(y){const k=y.length;for(let M=0;M<k;M++)y.reassign(M,this.radiansToPositivePeriodicFraction(y.atUncheckedIndex(M)))}static radiansToSignedPeriodicFractionStartEnd(y,k,M,b=0){const E=M-k;if(W.isAlmostEqualRadiansNoPeriodShift(0,E))return b;if(W.isAlmostEqualRadiansAllowPeriodShift(k,M)){if(W.isAlmostEqualRadiansNoPeriodShift(y,k))return 0;if(W.isAlmostEqualRadiansNoPeriodShift(y,M))return 1}else{if(W.isAlmostEqualRadiansAllowPeriodShift(y,k))return 0;if(W.isAlmostEqualRadiansAllowPeriodShift(y,M))return 1}const D=(y-k)/E;return this.fractionToSignedPeriodicFractionStartEnd(D,k,M,D<0)}radiansToSignedPeriodicFraction(y,k=0){return At.radiansToSignedPeriodicFractionStartEnd(y,this._radians0,this._radians1,k)}angleToSignedPeriodicFraction(y,k=0){return this.radiansToSignedPeriodicFraction(y.radians,k)}static radiansToSignedFractionStartEnd(y,k,M,b=!1,E=0){const D=Q.largeCoordinateResult;let R=this.radiansToSignedPeriodicFractionStartEnd(y,k,M,D);if(R===D)return E;if(b&&R>1||!b&&R<0){let y=W.pi2Radians/Math.abs(M-k);b&&(y=-y),R+=y}return R}radiansToSignedFraction(y,k=!1,M=0){return At.radiansToSignedFractionStartEnd(y,this._radians0,this._radians1,k,M)}angleToSignedFraction(y,k=!1,M=0){return this.radiansToSignedFraction(y.radians,k,M)}static isRadiansInStartEnd(y,k,M,b=!0){return(y-k)*(y-M)<=0||(k===M?b?W.isAlmostEqualRadiansAllowPeriodShift(y,k):W.isAlmostEqualRadiansNoPeriodShift(y,k):!!b&&this.radiansToPositivePeriodicFractionStartEnd(y,k,M,1e3)<=1)}isRadiansInSweep(y,k=!0){return At.isRadiansInStartEnd(y,this.startRadians,this.endRadians,k)}isAngleInSweep(y){return this.isRadiansInSweep(y.radians)}setFromJSON(y){y?y instanceof At?this.setFrom(y):Q.isNumberArray(y.degrees,2)?this.setStartEndDegrees(y.degrees[0],y.degrees[1]):Q.isNumberArray(y.radians,2)?this.setStartEndRadians(y.radians[0],y.radians[1]):Q.isNumberArray(y,2)?this.setStartEndDegrees(y[0],y[1]):this.setStartEndRadians():this.setStartEndRadians()}static fromJSON(y){const k=At.create360();return k.setFromJSON(y),k}toJSON(){return[this.startDegrees,this.endDegrees]}isAlmostEqualAllowPeriodShift(y,k=Q.smallAngleRadians){return this.isCCW===y.isCCW&&W.isAlmostEqualRadiansAllowPeriodShift(this._radians0,y._radians0,k)&&W.isAlmostEqualRadiansAllowPeriodShift(this._radians1-this._radians0,y._radians1-y._radians0,k)}isAlmostEqualNoPeriodShift(y,k=Q.smallAngleRadians){return W.isAlmostEqualRadiansNoPeriodShift(this._radians0,y._radians0,k)&&W.isAlmostEqualRadiansNoPeriodShift(this._radians1-this._radians0,y._radians1-y._radians0,k)}isAlmostEqual(y){return this.isAlmostEqualNoPeriodShift(y)}}class It{constructor(y=8,k){this._data=new Float64Array(y),this._inUse=0,this._growthFactor=void 0!==k&&k>=1?k:1.5}copyData(y,k,M){let b=M??0;if(b<0&&(b=0),b>=this._data.length)return{count:0,offset:0};let E=k??y.length;return E>0&&(E>y.length&&(E=y.length),b+E>this._data.length&&(E=this._data.length-b)),E<=0?{count:0,offset:0}:(E===y.length?this._data.set(y,b):y instanceof Float64Array?this._data.set(y.subarray(0,E),b):this._data.set(y.slice(0,E),b),{count:E,offset:b})}static create(y){const k=new It(y.length);return k.copyData(y),k._inUse=y.length,k}static compare(y,k){return y-k}clone(y=!1){const k=new It(y?this.capacity():this._inUse);return k.copyData(this._data,this._inUse),k._inUse=this._inUse,k}get length(){return this._inUse}setAtUncheckedIndex(y,k){this._data[y]=k}move(y,k){this._data[k]=this._data[y]}swap(y,k){const M=this._data[y];this._data[y]=this._data[k],this._data[k]=M}push(y){this.ensureCapacity(this._inUse+1),this._data[this._inUse]=y,this._inUse++}pushArray(y){this.ensureCapacity(this._inUse+y.length),this.copyData(y,y.length,this._inUse),this._inUse+=y.length}pushBlockCopy(y,k){y>=0&&y<this._inUse&&k>0&&y+k<=this._inUse&&(this.ensureCapacity(this._inUse+k),this._data.copyWithin(this._inUse,y,y+k),this._inUse+=k)}clear(){this._inUse=0}capacity(){return this._data.length}ensureCapacity(y,k=!0){if(y>this.capacity()){k&&(y*=this._growthFactor);const M=this._data;this._data=new Float64Array(y),this.copyData(M,this._inUse)}}resize(y,k=0){y>=0&&y<this._inUse?this._inUse=y:y>this._inUse&&(this.ensureCapacity(y,!1),this._data.fill(k,this._inUse),this._inUse=y)}pop(){this._inUse>0&&this._inUse--}atUncheckedIndex(y){return this._data[y]}front(){return this._data[0]}back(){return this._data[this._inUse-1]}reassign(y,k){this._data[y]=k}sort(y=(y,k)=>It.compare(y,k)){for(let k=0;k<this._inUse;k++)for(let M=k+1;M<this._inUse;M++){const b=this._data[k],E=this._data[M];y(b,E)>0&&(this._data[k]=E,this._data[M]=b)}}restrictToInterval(y,k){const M=this._data,b=M.length;let E=0,D=0;for(let R=0;R<b;R++)D=M[R],D>=y&&D<=k&&(M[E++]=D);this._inUse=E}compressAdjacentDuplicates(y=0){const k=this._data,M=this._inUse;if(0===M)return;let b,E=1,D=k[0];for(let R=1;R<M;R++)b=k[R],Math.abs(b-D)>y&&(k[E++]=b,D=b);this._inUse=E}}class St{constructor(y=0,k=0,M=0){this.coffs=[y,k,M]}static solveQuadratic(y,k,M){const b=Q.conditionalDivideFraction(k,y),E=Q.conditionalDivideFraction(M,y);if(void 0!==b&&void 0!==E){const y=b*b-4*E;if(y>0){const k=Math.sqrt(y);return[.5*(-b-k),.5*(-b+k)]}if(y<0)return;const k=-.5*b;return[k,k]}const D=Q.conditionalDivideFraction(-M,k);if(void 0!==D)return[D]}addConstant(y){this.coffs[0]+=y}addSquaredLinearTerm(y,k,M=1){this.coffs[0]+=M*(y*y),this.coffs[1]+=M*(2*y*k),this.coffs[2]+=M*(k*k)}realRoots(){const y=St.solveQuadratic(this.coffs[2],this.coffs[1],this.coffs[0]);if(y&&y.length>1&&y[0]>y[1]){const k=y[0];y[0]=y[1],y[1]=k}return y}evaluate(y){return this.coffs[0]+y*(this.coffs[1]+y*this.coffs[2])}evaluateDerivative(y){return this.coffs[1]+2*y*this.coffs[2]}tryGetVertexFactorization(){const y=Q.conditionalDivideFraction(-this.coffs[1],2*this.coffs[2]);if(void 0!==y){const k=this.evaluate(y);return{c:this.coffs[2],x0:y,y0:k}}}static fromRootsAndC2(y,k,M=1){return new St(M*y*k,-M*(y+k),M)}}class wt{static isZero(y){return Math.abs(y)<this._EQN_EPS}static isSmallRatio(y,k,M=1e-9,b=8e-16){return Math.abs(y)<=M||Math.abs(y)<b*Math.abs(k)}static cbrt(y){return y>0?Math.pow(y,1/3):y<0?-Math.pow(-y,1/3):0}static safeDivide(y,k,M,b=0,E){return Math.abs(M)>this._safeDivideFactor*Math.abs(k)?(y[E]=k/M,!0):(y[E]=b,!1)}static checkRootProximity(y,k){return 0===k?y.atUncheckedIndex(k)<y.atUncheckedIndex(k+1):k>0&&k+1<y.length?y.atUncheckedIndex(k)>y.atUncheckedIndex(k-1)&&y.atUncheckedIndex(k)<y.atUncheckedIndex(k+1):y.atUncheckedIndex(k)>y.atUncheckedIndex(k-1)}static newtonMethodAdjustment(y,k,M){let b=y[M],E=0;for(let D=M-1;D>=0;D--)E=b+k*E,b=y[D]+k*b;if(Math.abs(E)>=1e-14*(1+Math.abs(k)))return b/E}static improveRoots(y,k,M,b){for(let E=0;E<M.length;E++){let D=this.newtonMethodAdjustment(y,M.atUncheckedIndex(E),k);if(void 0===D||0===D)continue;const R=M.atUncheckedIndex(E);let X=0,z=0;for(;void 0!==D&&0!==D&&X<12;){if(Math.abs(D)<1e-10*(1+Math.abs(M.atUncheckedIndex(E)))){if(++z>1)break}else z=0;const N=M.atUncheckedIndex(E)-D;if(M.reassign(E,N),b&&!this.checkRootProximity(M,E)){M.reassign(E,R);break}D=this.newtonMethodAdjustment(y,M.atUncheckedIndex(E),k),X++}}}static appendSolution(y,k){void 0!==y&&k.push(y)}static append2Solutions(y,k,M){M.push(y),M.push(k)}static appendLinearRoot(y,k,M){wt.appendSolution(Q.conditionalDivideFraction(-y,k),M)}static mostDistantFromMean(y){if(!y||0===y.length)return 0;let k=0;for(let E=0;E<y.length;E++)k+=y.atUncheckedIndex(E);k/=y.length;let M=0,b=y.atUncheckedIndex(0);for(let E=0;E<y.length;E++){const D=Math.abs(y.atUncheckedIndex(E)-k);D>M&&(M=D,b=y.atUncheckedIndex(E))}return b}static appendQuadraticRoots(y,k){const M=Q.conditionalDivideFraction(1,y[2]);if(!M)return void this.appendLinearRoot(y[0],y[1],k);const b=.5*y[1]*M,E=b*b-y[0]*M;if(this.isZero(E))this.appendSolution(-b,k);else if(!(E<0)&&E>0){const y=Math.sqrt(E);this.append2Solutions(y-b,-y-b,k)}}static addConstant(y,k){for(let M=0;M<k.length;M++)k.reassign(M,k.atUncheckedIndex(M)+y)}static signedCubeRoot(y){return y>=0?Math.pow(y,1/3):-Math.pow(-y,1/3)}static appendFullCubicSolutions(y,k,M,b,E){const D=(k*k-3*y*M)/(y*y*9),R=-k/(3*y),X=b+R*(M+R*(k+R*y)),z=4*y*y*D*D*D,N=X*X-z;if(N>0){const k=Math.sqrt(N),M=.5/y;E.push(R+this.signedCubeRoot(M*(-X+k))+this.signedCubeRoot(M*(-X-k)))}else if(N<0){let k=Math.sqrt(z);y<0&&(k=-k);const M=Math.acos(-X/k)/3,b=2*Math.sqrt(D),N=2*Math.PI/3;E.push(R+b*Math.cos(M)),E.push(R+b*Math.cos(M+N)),E.push(R+b*Math.cos(M-N))}else{const k=this.signedCubeRoot(.5*X/y),M=R+k;E.push(R-2*k),E.push(M),E.push(M)}}static appendCubicRoots(y,k){void 0!==Q.conditionalDivideCoordinate(1,y[3])?(this.appendFullCubicSolutions(y[3],y[2],y[1],y[0],k),this.improveRoots(y,3,k,!1)):this.appendQuadraticRoots(y,k),k.sort()}static appendQuarticRoots(y,k){const M=new Float64Array(4);let b,E;const D=new Float64Array(1);if(!this.safeDivide(D,1,y[4],0,0))return void this.appendCubicRoots(y,k);const R=y[3]*D[0],X=y[2]*D[0],z=y[1]*D[0],N=-.25*R,Y=R*R,O=-.375*Y+X,B=.125*Y*R-.5*R*X+z,V=-.01171875*Y*Y+.0625*Y*X-.25*R*z+y[0]*D[0],U=new It;if(this.isZero(V))return M[0]=B,M[1]=O,M[2]=0,M[3]=1,this.appendCubicRoots(M,k),k.push(0),void this.addConstant(N,k);{M[0]=.5*V*O-.125*B*B,M[1]=-V,M[2]=-.5*O,M[3]=1,this.appendCubicRoots(M,U);const y=this.mostDistantFromMean(U);if(b=y*y-V,E=2*y-O,this.isSmallRatio(b,V))b=0;else{if(!(b>0))return;b=Math.sqrt(b)}if(this.isSmallRatio(E,O))E=0;else{if(!(E>0))return;E=Math.sqrt(E)}M[0]=y-b,M[1]=B<0?-E:E,M[2]=1,this.appendQuadraticRoots(M,k),M[0]=y+b,M[1]=B<0?E:-E,M[2]=1,this.appendQuadraticRoots(M,k)}this.addConstant(N,k),k.sort(),this.improveRoots(y,4,k,!0)}static appendCosSinRadians(y,k,M,b,E){M&&M.push(y),b&&b.push(k),E&&E.push(Math.atan2(k,y))}static appendImplicitLineUnitCircleIntersections(y,k,M,b,E,D,R=1e-14){let X;const z=k*k+M*M;let N=0;if(X=R<0?0:2*R,z<=0)N=0===y?-2:-1;else{const R=-y/z,Y=1-y*y/z;if(Y<-X){const X=Math.sqrt(z),Y=y<0?1/X:-1/X;this.appendCosSinRadians(R*k,R*M,b,E,D),this.appendCosSinRadians(k*Y,M*Y,b,E,D),N=0}else if(Y<X){const X=Math.sqrt(z),Y=y<0?1/X:-1/X;this.appendCosSinRadians(R*k,R*M,b,E,D),this.appendCosSinRadians(k*Y,M*Y,b,E,D),N=1}else{const y=Math.sqrt(Y/z),X=R*k,O=R*M;this.appendCosSinRadians(X-y*M,O+y*k,b,E,D),this.appendCosSinRadians(X+y*M,O-y*k,b,E,D),N=2}}return N}}wt._EQN_EPS=1e-9,wt._safeDivideFactor=1e-14;class Ct{static degreeKnownEvaluate(y,k,M){if(k<0)return 0;let b=y[k];for(let E=k-1;E>=0;E--)b=M*b+y[E];return b}static evaluate(y,k){const M=y.length-1;return this.degreeKnownEvaluate(y,M,k)}static accumulate(y,k,M){let b=y.length-1;const E=k.length-1;for(let D=0;D<=E;D++)y[D]+=M*k[D];for(;b>=0&&0===y[b];)b--;return b}static zero(y){for(let k=0;k<y.length;k++)y[k]=0}}class Tt{static solveAngles(y,k,M,b){let E,D=Math.abs(M);b.length=0;const R=this._smallAngle;for(let Y=0;Y<=k;Y++)E=Math.abs(y[Y]),E>D&&(D=E);const X=R*D;let z=k;for(;z>0&&Math.abs(y[z])<=X;)z--;const N=new It;if(-1===z);else{if(0===z||(1===z?N.push(-y[0]/y[1]):2===z?wt.appendQuadraticRoots(y,N):3===z?wt.appendCubicRoots(y,N):4===z?wt.appendQuarticRoots(y,N):e()),N.length>0)for(let y=0;y<N.length;y++){const k=Ct.evaluate(this.S,N.atUncheckedIndex(y)),M=Ct.evaluate(this.C,N.atUncheckedIndex(y));b.push(Math.atan2(k,M))}z<k&&b.push(-.5*Math.PI)}return b.length>0}static solveUnitCircleImplicitQuadricIntersection(y,k,M,b,E,D,R){const X=new Float64Array(5);let z;Ct.zero(X),Q.hypotenuseXYZ(y,k,M)>Tt._coefficientRelTol*Q.hypotenuseXYZ(b,E,D)?(Ct.accumulate(X,this.CW,b),Ct.accumulate(X,this.SW,E),Ct.accumulate(X,this.WW,D),Ct.accumulate(X,this.SS,M),Ct.accumulate(X,this.CC,y),Ct.accumulate(X,this.SC,k),z=4):(Ct.accumulate(X,this.C,b),Ct.accumulate(X,this.S,E),Ct.accumulate(X,this.W,D),z=2);const N=Math.max(Math.abs(y),Math.abs(M),Math.abs(k),Math.abs(b),Math.abs(E),Math.abs(D));return this.solveAngles(X,z,N,R)}static solveUnitCircleEllipseIntersection(y,k,M,b,E,D,R,X){X.length=0;const z=M*M+b*b,N=2*(M*E+b*D),Y=E*E+D*D,O=2*(M*y+b*k),B=2*(E*y+D*k),V=y*y+k*k-1,U=this.solveUnitCircleImplicitQuadricIntersection(z,N,Y,O,B,V,R);for(const L of R){const R=Math.cos(L),z=Math.sin(L),N=y+M*R+E*z,Y=k+b*R+D*z;X.push(Math.atan2(Y,N))}return U}static solveUnitCircleHomogeneousEllipseIntersection(y,k,M,b,E,D,R,X,z,N,Y){Y.length=0;const O=b*b+E*E-D*D,B=2*(b*R+E*X-D*z),V=R*R+X*X-z*z,U=2*(b*y+E*k-D*M),L=2*(R*y+X*k-z*M),Z=y*y+k*k-M*M,q=this.solveUnitCircleImplicitQuadricIntersection(O,B,V,U,L,Z,N);for(const jr of N){const M=Math.cos(jr),D=Math.sin(jr),z=y+b*M+R*D,N=k+E*M+X*D;Y.push(Math.atan2(N,z))}return q}}Tt._smallAngle=1e-11,Tt.S=Float64Array.from([0,2,-2]),Tt.C=Float64Array.from([1,-2]),Tt.W=Float64Array.from([1,-2,2]),Tt.CW=Float64Array.from([1,-4,6,-4]),Tt.SW=Float64Array.from([0,2,-6,8,-4]),Tt.SC=Float64Array.from([0,2,-6,4]),Tt.SS=Float64Array.from([0,0,4,-8,4]),Tt.CC=Float64Array.from([1,-4,4]),Tt.WW=Float64Array.from([1,-4,8,-8,4]),Tt.CCMinusSS=Float64Array.from([1,-4,0,8,-4]),Tt._coefficientRelTol=1e-12;class Ft{constructor(y,k,M,b){this.a=y,this.b=k,this.c=M,this.d=b}evaluate(y,k){return this.a+this.b*y+k*(this.c+this.d*y)}static createUnitSquareValues(y,k,M,b){return new Ft(y,k,k,b-k-M)}static solveBilinearPair(y,k,M,b,E,D,R,X){const z=Q.crossProductXYXY(y,E,M,R),N=Q.crossProductXYXY(k,D,M,R)+Q.crossProductXYXY(y,E,b,X),Y=Q.crossProductXYXY(k,D,b,X),O=St.solveQuadratic(Y,N,z);if(void 0===O)return;const B=[];for(const V of O){const z=Q.conditionalDivideFraction(-(y+k*V),M+b*V),N=Q.conditionalDivideFraction(-(E+D*V),R+X*V);void 0!==z?B.push(H.create(V,z)):void 0!==N&&B.push(H.create(V,N))}return B}static solvePair(y,k,M,b){return Ft.solveBilinearPair(y.a-k,y.b,y.c,y.d,M.a-b,M.b,M.c,M.d)}}class kt{constructor(y,k,M){this.a=y,this.cosineCoff=k,this.sineCoff=M}set(y,k,M){this.a=y,this.cosineCoff=k,this.sineCoff=M}evaluateRadians(y){return this.a+this.cosineCoff*Math.cos(y)+this.sineCoff*Math.sin(y)}range(y){const k=Q.hypotenuseXY(this.cosineCoff,this.sineCoff);return ft.createXX(this.a-k,this.a+k,y)}rangeInStartEndRadians(y,k,M){if(W.isFullCircleRadians(k-y))return this.range(M);M=ft.createXX(this.evaluateRadians(y),this.evaluateRadians(k),M);const b=Math.atan2(this.sineCoff,this.cosineCoff),E=b+Math.PI;return At.isRadiansInStartEnd(b,y,k)&&M.extendX(this.evaluateRadians(b)),At.isRadiansInStartEnd(E,y,k)&&M.extendX(this.evaluateRadians(E)),M}rangeInSweep(y,k){return this.rangeInStartEndRadians(y.startRadians,y.endRadians,k)}referenceMinMaxRadians(){return Math.atan2(this.sineCoff,this.cosineCoff)}}class Mt{static lineSegment2dXYTransverseIntersectionUnbounded(y,k,M,b,E){const D=k.x-y.x,R=k.y-y.y,X=b.x-M.x,z=b.y-M.y,N=M.x-y.x,Y=M.y-y.y,O=Q.crossProductXYXY(D,R,X,z),B=Q.crossProductXYXY(N,Y,X,z),V=Q.crossProductXYXY(D,R,N,Y),U=Q.conditionalDivideFraction(B,O),L=Q.conditionalDivideFraction(V,O);return void 0!==U&&void 0!==L?(E.set(U,-L),!0):(E.set(0,0),!1)}static lineSegmentXYUVTransverseIntersectionUnbounded(y,k,M,b,E,D,R,X,z){const N=E-y,Y=D-k,O=Q.crossProductXYXY(M,b,R,X),B=Q.crossProductXYXY(N,Y,R,X),V=Q.crossProductXYXY(M,b,N,Y),U=Q.conditionalDivideFraction(B,O),L=Q.conditionalDivideFraction(V,O);return void 0!==U&&void 0!==L?(z.set(U,-L),!0):(z.set(0,0),!1)}static lineSegment3dXYTransverseIntersectionUnbounded(y,k,M,b,E){const D=k.x-y.x,R=k.y-y.y,X=b.x-M.x,z=b.y-M.y,N=M.x-y.x,Y=M.y-y.y,O=Q.crossProductXYXY(D,R,X,z),B=Q.crossProductXYXY(N,Y,X,z),V=Q.crossProductXYXY(D,R,N,Y),U=Q.conditionalDivideFraction(B,O),L=Q.conditionalDivideFraction(V,O);return void 0!==U&&void 0!==L?(E.set(U,-L),!0):(E.set(0,0),!1)}static lineSegment3dHXYTransverseIntersectionUnbounded(y,k,M,b,E){const D=Q.tripleProduct(y.x,k.x,M.x,y.y,k.y,M.y,y.w,k.w,M.w),R=Q.tripleProduct(y.x,k.x,b.x,y.y,k.y,b.y,y.w,k.w,b.w),X=Q.conditionalDivideFraction(-D,R-D);if(void 0!==X){const D=Q.tripleProduct(M.x,b.x,y.x,M.y,b.y,y.y,M.w,b.w,y.w),R=Q.tripleProduct(M.x,b.x,k.x,M.y,b.y,k.y,M.w,b.w,k.w),z=Q.conditionalDivideFraction(-D,R-D);if(void 0!==z)return J.create(z,X,E)}}static lineSegment3dHXYClosestPointUnbounded(y,k,M){const b=k.x*y.w-y.x*k.w,E=k.y*y.w-y.y*k.w,D=Q.tripleProduct(y.x,-E,M.x,y.y,b,M.y,y.w,0,M.w),R=Q.tripleProduct(k.x,-E,M.x,k.y,b,M.y,k.w,0,M.w);return Q.conditionalDivideFraction(-D,R-D)}static lineSegment3dXYClosestPointUnbounded(y,k,M){const b=k.x-y.x,E=k.y-y.y,D=b*b+E*E,R=b*(M.x-y.x)+E*(M.y-y.y);return Q.conditionalDivideFraction(R,D)}static lineSegment3dClosestPointUnbounded(y,k,M){const b=k.x-y.x,E=k.y-y.y,D=k.z-y.z,R=b*b+E*E+D*D,X=b*(M.x-y.x)+E*(M.y-y.y)+D*(M.z-y.z);return Q.conditionalDivideFraction(X,R)}static lineSegment3dClosestApproachUnbounded(y,k,M,b,E){return this.ray3dXYZUVWClosestApproachUnbounded(y.x,y.y,y.z,k.x-y.x,k.y-y.y,k.z-y.z,M.x,M.y,M.z,b.x-M.x,b.y-M.y,b.z-M.z,E)}static ray3dXYZUVWClosestApproachUnbounded(y,k,M,b,E,D,R,X,z,N,Y,O,B){const V=R-y,U=X-k,L=z-M,Z=Q.hypotenuseSquaredXYZ(b,E,D),q=Q.hypotenuseSquaredXYZ(N,Y,O),jr=Q.dotProductXYZXYZ(b,E,D,N,Y,O),Gr=Q.dotProductXYZXYZ(V,U,L,b,E,D),Jr=Q.dotProductXYZXYZ(V,U,L,N,Y,O);return Mt.linearSystem2d(Z,-jr,jr,-q,Gr,Jr,B)}static linearSystem2d(y,k,M,b,E,D,R){const X=Q.crossProductXYXY(y,M,k,b),z=Q.crossProductXYXY(E,D,k,b),N=Q.crossProductXYXY(y,M,E,D),Y=Q.conditionalDivideFraction(z,X),O=Q.conditionalDivideFraction(N,X);return void 0!==Y&&void 0!==O?(R.set(Y,O),!0):(R.set(0,0),!1)}static linearSystem3d(y,k,M,b,E,D,R,X,z,N,Y,O,B){const V=Q.tripleProduct(y,b,R,k,E,X,M,D,z),U=Q.tripleProduct(N,Y,O,k,E,X,M,D,z),L=Q.tripleProduct(y,b,R,N,Y,O,M,D,z),Z=Q.tripleProduct(y,b,R,k,E,X,N,Y,O),q=Q.conditionalDivideFraction(U,V),jr=Q.conditionalDivideFraction(L,V),Gr=Q.conditionalDivideFraction(Z,V);if(void 0!==q&&void 0!==jr&&void 0!==Gr)return $.create(q,jr,Gr,B)}static intersect3Planes(y,k,M,b,E,D,R){return this.linearSystem3d(k.x,k.y,k.z,b.x,b.y,b.z,D.x,D.y,D.z,Q.dotProductXYZXYZ(y.x,y.y,y.z,k.x,k.y,k.z),Q.dotProductXYZXYZ(M.x,M.y,M.z,b.x,b.y,b.z),Q.dotProductXYZXYZ(E.x,E.y,E.z,D.x,D.y,D.z),R)}static eliminateFromPivot(y,k,M,b){const E=y.length;let D=Q.conditionalDivideFraction(M[k],y[k]);if(void 0===D)return!1;D*=b;for(let R=k+1;R<E;R++)M[R]+=D*y[R];return!0}static solveBilinearPair(y,k,M,b,E,D,R,X){return Ft.solveBilinearPair(y,k,M,b,E,D,R,X)}}class bt{constructor(y,k){this.origin=y,this.direction=k,this.a=void 0}static _create(y,k,M,b,E,D){return new bt(j.create(y,k,M),$.create(b,E,D))}static createXAxis(){return bt._create(0,0,0,1,0,0)}static createYAxis(){return bt._create(0,0,0,0,1,0)}static createZAxis(){return bt._create(0,0,0,0,0,1)}static createZero(y){return y?(y.origin.setZero(),y.direction.setZero(),y):new bt(j.createZero(),$.createZero())}isAlmostEqual(y){return this.origin.isAlmostEqual(y.origin)&&this.direction.isAlmostEqual(y.direction)}dotProductToPoint(y){return this.direction.dotProductStartEnd(this.origin,y)}pointToFraction(y){return Q.safeDivideFraction(this.dotProductToPoint(y),this.direction.magnitudeSquared(),0)}projectPointToRay(y){return this.origin.plusScaled(this.direction,this.pointToFraction(y))}isAlmostEqualPointSet(y){if(!this.direction.isParallelTo(y.direction,!0))return!1;let k=this.projectPointToRay(y.origin);return!!y.origin.isAlmostEqualMetric(k)&&(k=y.projectPointToRay(this.origin),!!this.origin.isAlmostEqualMetric(k))}static create(y,k,M){return M?(M.set(y,k),M):new bt(y.clone(),k.clone())}static createWeightedDerivative(y,k,M){const b=y[3],E=k[3],D=y[0],R=y[1],X=y[2],z=k[0]*b-y[0]*E,N=k[1]*b-y[1]*E,Y=k[2]*b-y[2]*E;if(Q.isSmallMetricDistance(b))return;const O=1/b,B=O*O;return bt.createXYZUVW(D*O,R*O,X*O,z*B,N*B,Y*B,M)}static createXYZUVW(y,k,M,b,E,D,R){return R?(R.getOriginRef().set(y,k,M),R.getDirectionRef().set(b,E,D),R):new bt(j.create(y,k,M),$.create(b,E,D))}static createCapture(y,k){return new bt(y,k)}static createPointVectorNumber(y,k,M,b){return b?(b.origin.setFrom(y),b.direction.setFrom(k),b.a=M,b):((b=new bt(y.clone(),k.clone())).a=M,b)}static createStartEnd(y,k,M){return M?(M.origin.setFrom(y),M.direction.setStartEnd(y,k),M):new bt(y.clone(),$.createStartEnd(y,k))}getOriginRef(){return this.origin}getDirectionRef(){return this.direction}set(y,k){this.origin.setFrom(y),this.direction.setFrom(k)}clone(y){return y?(y.set(this.origin.clone(),this.direction.clone()),y):new bt(this.origin.clone(),this.direction.clone())}cloneTransformed(y,k){return bt.create(y.multiplyPoint3d(this.origin,k?.origin),y.multiplyVector(this.direction,k?.direction),k)}cloneInverseTransformed(y,k){if(y.computeCachedInverse(!0))return bt.create(y.multiplyInversePoint3d(this.origin,k?.origin),y.matrix.multiplyInverseXYZAsVector3d(this.direction.x,this.direction.y,this.direction.z,k?.direction),k)}transformInPlace(y){y.multiplyPoint3d(this.origin,this.origin),y.multiplyVector(this.direction,this.direction)}setFrom(y){this.set(y.origin,y.direction)}fractionToPoint(y,k){return this.origin.plusScaled(this.direction,y,k)}toRigidZFrame(y){const k=bt._workMatrix=xt.createRigidHeadsUp(this.direction,E.ZXY,bt._workMatrix);return pt.createOriginAndMatrix(this.origin,k,y)}setFromJSON(y){if(!y)return this.origin.set(0,0,0),void this.direction.set(0,0,1);this.origin.setFromJSON(y.origin),this.direction.setFromJSON(y.direction)}toJSON(){return{origin:this.origin.toJSON(),direction:this.direction.toJSON()}}static fromJSON(y){const k=bt.createXAxis();return k.setFromJSON(y),k}trySetDirectionMagnitudeInPlace(y=1){return this.direction.tryNormalizeInPlace()?(this.direction.scaleInPlace(y),!0):(this.direction.setZero(),this.a=0,!1)}tryNormalizeInPlaceWithAreaWeight(y){const k=Q.smallMetricDistanceSquared;return this.a=y,!!(Math.abs(y)>k&&this.direction.tryNormalizeInPlace(k))||(this.direction.setZero(),this.a=0,!1)}distance(y){const k=this.direction.magnitudeSquared(),M=this.dotProductToPoint(y),b=Q.inverseMetricDistanceSquared(k);return b?Math.sqrt(this.origin.distanceSquared(y)-M*M*b):Math.sqrt(this.origin.distanceSquared(y))}intersectionWithPlane(y,k){const M=$.createStartEnd(y.getOriginRef(),this.origin),b=this.direction.dotProduct(y.getNormalRef()),E=this.direction.magnitudeSquared(),D=M.dotProduct(y.getNormalRef()),R=Q.conditionalDivideFraction(-D,b);if(void 0!==R)return void 0!==Q.conditionalDivideFraction(E,b)?(k&&this.origin.plusScaled(this.direction,R,k),R):void 0}intersectionWithRange3d(y,k){if(y.isNull)return ft.createNull(k);const M=ft.createXX(-Q.largeCoordinateResult,Q.largeCoordinateResult,k);return M.clipLinearMapToInterval(this.origin.x,this.direction.x,y.low.x,y.high.x)&&M.clipLinearMapToInterval(this.origin.y,this.direction.y,y.low.y,y.high.y)&&M.clipLinearMapToInterval(this.origin.z,this.direction.z,y.low.z,y.high.z),M}intersectionWithTriangle(y,k,M,b,E,D){(void 0===b||b<0)&&(b=Q.smallMetricDistance),(void 0===E||E<0)&&(E=Q.smallFloatingPoint);const R=bt._workVector0=$.createStartEnd(y,k,bt._workVector0),X=bt._workVector1=$.createStartEnd(y,M,bt._workVector1),z=bt._workVector2=this.direction.crossProduct(X,bt._workVector2),N=R.dotProduct(z);if(N>=-b&&N<=b)return;const Y=1/N,O=bt._workVector3=$.createStartEnd(y,this.origin,bt._workVector3);let B=Y*O.dotProduct(z);if(B<0){if(!(B>-E))return;B=0}else if(B>1){if(!(B<1+E))return;B=1}const V=bt._workVector4=O.crossProduct(R,bt._workVector4);let U=Y*this.direction.dotProduct(V);if(U<0){if(!(U>-E))return;U=0}else if(B+U>1){if(!(B+U<1+E))return;U=1-B}const L=Y*X.dotProduct(V);return L<=b?void 0:this.origin.plusScaled(this.direction,L,D)}perpendicularPartOfVectorToTarget(y,k){const M=$.createStartEnd(this.origin,y),b=this.direction.magnitudeSquared(),E=this.direction.dotProductStartEnd(this.origin,y),D=Q.safeDivideFraction(E,b,0);return M.plusScaled(this.direction,-D,k)}static closestApproachRay3dRay3d(y,k){const M=J.create();let b,E,D,R,X;Mt.ray3dXYZUVWClosestApproachUnbounded(y.origin.x,y.origin.y,y.origin.z,y.direction.x,y.direction.y,y.direction.z,k.origin.x,k.origin.y,k.origin.z,k.direction.x,k.direction.y,k.direction.z,M)?(b=M.x,E=M.y,D=y.fractionToPoint(b),R=k.fractionToPoint(E),X=D.isAlmostEqualMetric(R)?V.Intersection:V.PerpendicularChord):(E=0,b=y.pointToFraction(k.origin),D=y.fractionToPoint(b),R=k.fractionToPoint(E),X=D.isAlmostEqualMetric(R)?V.CoincidentGeometry:V.ParallelGeometry);const z=Pt.createCapture(vt.createRayFractionPoint(y,b,y.fractionToPoint(b)),vt.createRayFractionPoint(k,E,k.fractionToPoint(E)));return z.approachType=X,z}static interpolatePointAndTangent(y,k,M,b,E){E=E??bt.createZero();const D=M.x-y.x,R=M.y-y.y,X=M.z-y.z;if(E.direction.set(b*D,b*R,b*X),k<=.5)E.origin.set(y.x+k*D,y.y+k*R,y.z+k*X);else{const y=k-1;E.origin.set(M.x+y*D,M.y+y*R,M.z+y*X)}return E}}class Et extends tt{constructor(y,k,M){super(),this.origin=y,this.vectorU=k,this.vectorV=M}static createOriginAndVectors(y,k,M,b){return b?(b.origin.setFrom(y),b.vectorU.setFrom(k),b.vectorV.setFrom(M),b):new Et(y.clone(),k.clone(),M.clone())}clone(y){return void 0!==y&&y.setOriginAndVectors(this.origin,this.vectorU,this.vectorV),new Et(this.origin.clone(),this.vectorU.clone(),this.vectorV.clone())}static createFrom(y,k){if(y instanceof Et)return y.clone(k);const M=y.getUnitNormal();if(void 0===M)return;const b=y.getAnyPointOnPlane(),E=xt.createPerpendicularVectorFavorXYPlane(M);if(E.tryNormalizeInPlace()){const y=M.unitCrossProduct(E);if(void 0!==y)return new Et(b,E,y)}}static createFromTransformColumnsXYAndLengths(y,k,M,b){return b?(b.origin.setFrom(y.getOrigin()),y.matrix.columnX(b.vectorU),y.matrix.columnY(b.vectorV)):b=new Et(y.getOrigin(),y.matrix.columnX(),y.matrix.columnY()),void 0!==k&&b.vectorU.scaleToLength(k,b.vectorU),void 0!==M&&b.vectorV.scaleToLength(M,b.vectorV),b}static createCapture(y,k,M,b){return b?(b.origin=y,b.vectorU=k,b.vectorV=M,b):new Et(y,k,M)}setOriginAndVectorsXYZ(y,k,M,b,E,D,R,X,z){return this.origin.set(y,k,M),this.vectorU.set(b,E,D),this.vectorV.set(R,X,z),this}setOriginAndVectors(y,k,M){return this.origin.setFrom(y),this.vectorU.setFrom(k),this.vectorV.setFrom(M),this}static createOriginAndVectorsXYZ(y,k,M,b,E,D,R,X,z,N){return N?N.setOriginAndVectorsXYZ(y,k,M,b,E,D,R,X,z):new Et(j.create(y,k,M),$.create(b,E,D),$.create(R,X,z))}static createOriginAndTargets(y,k,M,b){return Et.createOriginAndVectorsXYZ(y.x,y.y,y.z,k.x-y.x,k.y-y.y,k.z-y.z,M.x-y.x,M.y-y.y,M.z-y.z,b)}static createXYPlane(y){return Et.createOriginAndVectorsXYZ(0,0,0,1,0,0,0,1,0,y)}static createOriginAndVectorsArrays(y,k,M,b){return Et.createOriginAndVectorsXYZ(y[0],y[1],y[2],k[0],k[1],k[2],M[0],M[1],M[2],b)}static createOriginAndVectorsWeightedArrays(y,k,M,b){const E=y[3];if(b=Et.createXYPlane(b),Q.isSmallMetricDistance(E))return b;const D=1/E,R=k[3]*D*D,X=M[3]*D*D;return b.origin.set(y[0]*D,y[1]*D,y[2]*D),$.createAdd2ScaledXYZ(k[0],k[1],k[2],D,y[0],y[1],y[2],-R,b.vectorU),$.createAdd2ScaledXYZ(M[0],M[1],M[2],D,y[0],y[1],y[2],-X,b.vectorV),b}fractionToPoint(y,k,M){return this.origin.plus2Scaled(this.vectorU,y,this.vectorV,k,M)}fractionToVector(y,k,M){return $.createAdd2Scaled(this.vectorU,y,this.vectorV,k,M)}setFromJSON(y){y&&y.origin&&y.vectorV?(this.origin.setFromJSON(y.origin),this.vectorU.setFromJSON(y.vectorU),this.vectorV.setFromJSON(y.vectorV)):(this.origin.set(0,0,0),this.vectorU.set(1,0,0),this.vectorV.set(0,1,0))}toJSON(){return{origin:this.origin.toJSON(),vectorU:this.vectorU.toJSON(),vectorV:this.vectorV.toJSON()}}static fromJSON(y){const k=Et.createXYPlane();return k.setFromJSON(y),k}isAlmostEqual(y){return this.origin.isAlmostEqual(y.origin)&&this.vectorU.isAlmostEqual(y.vectorU)&&this.vectorV.isAlmostEqual(y.vectorV)}normalizeInPlace(){const y=this.vectorU.normalizeInPlace(),k=this.vectorV.normalizeInPlace();return y&&k}getUnitNormal(y){return this.vectorU.unitCrossProduct(this.vectorV,y)}unitNormal(y){return this.vectorU.unitCrossProduct(this.vectorV,y)}getAnyPointOnPlane(y){return this.origin.clone(y)}unitNormalRay(y){Et._workVector||(Et._workVector=$.create());const k=this.vectorU.unitCrossProduct(this.vectorV,Et._workVector);if(void 0!==k)return bt.create(this.origin,k,y)}toRigidFrame(y){return pt.createRigidFromOriginAndColumns(this.origin,this.vectorU,this.vectorV,E.XYZ,y)}transformInPlace(y){y.multiplyPoint3d(this.origin,this.origin),y.multiplyVector(this.vectorU,this.vectorU),y.multiplyVector(this.vectorV,this.vectorV)}normalX(){const y=this.vectorU.unitCrossProduct(this.vectorV);return void 0!==y?y.x:0}normalY(){const y=this.vectorU.unitCrossProduct(this.vectorV);return void 0!==y?y.y:0}normalZ(){const y=this.vectorU.unitCrossProduct(this.vectorV);return void 0!==y?y.z:0}altitude(y){const k=this.vectorU.unitCrossProduct(this.vectorV);return void 0===k?0:Q.dotProductXYZXYZ(y.x-this.origin.x,y.y-this.origin.y,y.z-this.origin.z,k.x,k.y,k.z)}altitudeXYZ(y,k,M){const b=this.vectorU.unitCrossProduct(this.vectorV);return void 0===b?0:Q.dotProductXYZXYZ(y-this.origin.x,k-this.origin.y,M-this.origin.z,b.x,b.y,b.z)}velocity(y){const k=this.vectorU.unitCrossProduct(this.vectorV);return void 0===k?0:Q.dotProductXYZXYZ(y.x,y.y,y.z,k.x,k.y,k.z)}velocityXYZ(y,k,M){const b=this.vectorU.unitCrossProduct(this.vectorV);return void 0===b?0:Q.dotProductXYZXYZ(y,k,M,b.x,b.y,b.z)}weightedAltitude(y){const k=y.w;return Q.tripleProduct(y.x-this.origin.x*k,y.y-this.origin.y*k,y.z-this.origin.z*k,this.vectorU.x,this.vectorU.y,this.vectorU.z,this.vectorV.x,this.vectorV.y,this.vectorV.z)}projectPointToPlane(y,k){const M=this.vectorU.unitCrossProduct(this.vectorV);if(void 0!==M){const b=M.dotProductStartEnd(this.origin,y);return y.plusScaled(M,-b,k)}const b=this.vectorU.magnitudeSquared(),E=this.vectorV.magnitudeSquared();if(b>=E){const M=this.vectorU.dotProductStartEnd(this.origin,y),E=Q.conditionalDivideCoordinate(M,b,0);if(void 0!==E)return y.plusScaled(this.vectorU,E,k)}else{const M=this.vectorV.dotProductStartEnd(this.origin,y),b=Q.conditionalDivideCoordinate(M,E,0);if(void 0!==b)return y.plusScaled(this.vectorV,b,k)}return this.origin.clone(k)}}function Rt(y,k,M,b,E,D){return D*(y-2*E*k-b*M)}class Dt extends tt{set(y=0,k=0,M=0,b=0){return this.xyzw[0]=y,this.xyzw[1]=k,this.xyzw[2]=M,this.xyzw[3]=b,this}setComponent(y,k){y>=0&&y<4&&(this.xyzw[y]=k)}get x(){return this.xyzw[0]}set x(y){this.xyzw[0]=y}get y(){return this.xyzw[1]}set y(y){this.xyzw[1]=y}get z(){return this.xyzw[2]}set z(y){this.xyzw[2]=y}get w(){return this.xyzw[3]}set w(y){this.xyzw[3]=y}constructor(y=0,k=0,M=0,b=0){super(),this.xyzw=new Float64Array(4),this.xyzw[0]=y,this.xyzw[1]=k,this.xyzw[2]=M,this.xyzw[3]=b}static create(y=0,k=0,M=0,b=0,E){return E?E.set(y,k,M,b):new Dt(y,k,M,b)}static createPlaneFrom(y){return new Dt(y.normalX(),y.normalY(),y.normalZ(),y.altitudeXYZ(0,0,0))}setFrom(y){return this.xyzw[0]=y.xyzw[0],this.xyzw[1]=y.xyzw[1],this.xyzw[2]=y.xyzw[2],this.xyzw[3]=y.xyzw[3],this}clone(y){return y?y.setFrom(this):new Dt(this.xyzw[0],this.xyzw[1],this.xyzw[2],this.xyzw[3])}setFromJSON(y){Q.isNumberArray(y,4)?this.set(y[0],y[1],y[2],y[3]):this.set(0,0,0,0)}static fromJSON(y){const k=new Dt;return k.setFromJSON(y),k}isAlmostEqual(y){return Q.isSameCoordinate(this.x,y.x)&&Q.isSameCoordinate(this.y,y.y)&&Q.isSameCoordinate(this.z,y.z)&&Q.isSameCoordinate(this.w,y.w)}isAlmostEqualXYZW(y,k,M,b){return Q.isSameCoordinate(this.x,y)&&Q.isSameCoordinate(this.y,k)&&Q.isSameCoordinate(this.z,M)&&Q.isSameCoordinate(this.w,b)}toJSON(){return[this.xyzw[0],this.xyzw[1],this.xyzw[2],this.xyzw[3]]}distanceXYZW(y){return Q.hypotenuseXYZW(y.xyzw[0]-this.xyzw[0],y.xyzw[1]-this.xyzw[1],y.xyzw[2]-this.xyzw[2],y.xyzw[3]-this.xyzw[3])}distanceSquaredXYZW(y){return Q.hypotenuseSquaredXYZW(y.xyzw[0]-this.xyzw[0],y.xyzw[1]-this.xyzw[1],y.xyzw[2]-this.xyzw[2],y.xyzw[3]-this.xyzw[3])}realDistanceXY(y){const k=this.w,M=y.w;if(!Q.isSmallMetricDistance(k)&&!Q.isSmallMetricDistance(M))return Q.hypotenuseXY(y.xyzw[0]/M-this.xyzw[0]/k,y.xyzw[1]/M-this.xyzw[1]/k)}maxDiff(y){return Math.max(Math.abs(y.xyzw[0]-this.xyzw[0]),Math.abs(y.xyzw[1]-this.xyzw[1]),Math.abs(y.xyzw[2]-this.xyzw[2]),Math.abs(y.xyzw[3]-this.xyzw[3]))}maxAbs(){return Math.max(Math.abs(this.xyzw[0]),Math.abs(this.xyzw[1]),Math.abs(this.xyzw[2]),Math.abs(this.xyzw[3]))}magnitudeXYZW(){return Q.hypotenuseXYZW(this.xyzw[0],this.xyzw[1],this.xyzw[2],this.xyzw[3])}magnitudeSquaredXYZ(){return Q.hypotenuseSquaredXYZ(this.xyzw[0],this.xyzw[1],this.xyzw[2])}minus(y,k){return Dt.create(this.xyzw[0]-y.xyzw[0],this.xyzw[1]-y.xyzw[1],this.xyzw[2]-y.xyzw[2],this.xyzw[3]-y.xyzw[3],k)}crossWeightedMinus(y,k){const M=this.xyzw[3],b=y.xyzw[3];return $.create(b*this.xyzw[0]-M*y.xyzw[0],b*this.xyzw[1]-M*y.xyzw[1],b*this.xyzw[2]-M*y.xyzw[2],k)}crossWeightedMinusPoint3d(y,k){const M=this.xyzw[3];return $.create(this.xyzw[0]-M*y.x,this.xyzw[1]-M*y.y,this.xyzw[2]-M*y.z,k)}plus(y,k){return Dt.create(this.xyzw[0]+y.xyzw[0],this.xyzw[1]+y.xyzw[1],this.xyzw[2]+y.xyzw[2],this.xyzw[3]+y.xyzw[3],k)}get isAlmostZero(){return Q.isSmallMetricDistance(this.maxAbs())}static createZero(){return new Dt(0,0,0,0)}static createPlanePointPointZ(y,k,M){return Dt.create(y.y*k.w-y.w*k.y,y.w*k.x-y.x*k.w,0,y.x*k.y-y.y*k.x,M)}static createFromPackedXYZ(y,k=0,M){if(k>=0&&k+2<y.length)return Dt.create(y[k],y[k+1],y[k+2],1,M)}static createFromPacked(y,k=0,M){if(k>=0&&k+3<y.length)return Dt.create(y[k],y[k+1],y[k+2],y[k+3],M)}static createFromPackedXYZW(y,k=0,M){return Dt.create(y[k],y[k+1],y[k+2],y[k+3],M)}static createFromPointAndWeight(y,k){return new Dt(y.x,y.y,y.z,k)}static createFromPoint(y){if(y instanceof H)return new Dt(y.x,y.y,0,1);if(y instanceof j)return new Dt(y.x,y.y,y.z,1);if(y instanceof Dt)return y.clone();if(Array.isArray(y)){const k=y.length>0?y[0]:0,M=y.length>1?y[1]:0,b=y.length>2?y[2]:0,E=y.length>3?y[3]:1;return new Dt(k,M,b,E)}const k=y.x,M=y.y,b=y.hasOwnProperty("z")?y.z:0,E=y.hasOwnProperty("w")?y.w:1;return new Dt(k,M,b,E)}plusScaled(y,k,M){return Dt.create(this.xyzw[0]+y.xyzw[0]*k,this.xyzw[1]+y.xyzw[1]*k,this.xyzw[2]+y.xyzw[2]*k,this.xyzw[3]+y.xyzw[3]*k,M)}interpolate(y,k,M){const b=1-y;return Dt.create(this.xyzw[0]*b+k.xyzw[0]*y,this.xyzw[1]*b+k.xyzw[1]*y,this.xyzw[2]*b+k.xyzw[2]*y,this.xyzw[3]*b+k.xyzw[3]*y,M)}plus2Scaled(y,k,M,b,E){return Dt.create(this.xyzw[0]+y.xyzw[0]*k+M.xyzw[0]*b,this.xyzw[1]+y.xyzw[1]*k+M.xyzw[1]*b,this.xyzw[2]+y.xyzw[2]*k+M.xyzw[2]*b,this.xyzw[3]+y.xyzw[3]*k+M.xyzw[3]*b,E)}plus3Scaled(y,k,M,b,E,D,R){return Dt.create(this.xyzw[0]+y.xyzw[0]*k+M.xyzw[0]*b+E.xyzw[0]*D,this.xyzw[1]+y.xyzw[1]*k+M.xyzw[1]*b+E.xyzw[1]*D,this.xyzw[2]+y.xyzw[2]*k+M.xyzw[2]*b+E.xyzw[2]*D,this.xyzw[3]+y.xyzw[3]*k+M.xyzw[3]*b+E.xyzw[3]*D,R)}static createAdd2Scaled(y,k,M,b,E){return Dt.create(y.xyzw[0]*k+M.xyzw[0]*b,y.xyzw[1]*k+M.xyzw[1]*b,y.xyzw[2]*k+M.xyzw[2]*b,y.xyzw[3]*k+M.xyzw[3]*b,E)}static createAdd3Scaled(y,k,M,b,E,D,R){return Dt.create(y.xyzw[0]*k+M.xyzw[0]*b+E.xyzw[0]*D,y.xyzw[1]*k+M.xyzw[1]*b+E.xyzw[1]*D,y.xyzw[2]*k+M.xyzw[2]*b+E.xyzw[2]*D,y.xyzw[3]*k+M.xyzw[3]*b+E.xyzw[3]*D,R)}dotVectorsToTargets(y,k){return(y.xyzw[0]-this.xyzw[0])*(k.xyzw[0]-this.xyzw[0])+(y.xyzw[1]-this.xyzw[1])*(k.xyzw[1]-this.xyzw[1])+(y.xyzw[2]-this.xyzw[2])*(k.xyzw[2]-this.xyzw[2])+(y.xyzw[3]-this.xyzw[3])*(k.xyzw[3]-this.xyzw[3])}dotProduct(y){return this.xyzw[0]*y.xyzw[0]+this.xyzw[1]*y.xyzw[1]+this.xyzw[2]*y.xyzw[2]+this.xyzw[3]*y.xyzw[3]}dotProductXYZW(y,k,M,b){return this.xyzw[0]*y+this.xyzw[1]*k+this.xyzw[2]*M+this.xyzw[3]*b}altitude(y){return this.xyzw[0]*y.x+this.xyzw[1]*y.y+this.xyzw[2]*y.z+this.xyzw[3]}altitudeXYZ(y,k,M){return this.xyzw[0]*y+this.xyzw[1]*k+this.xyzw[2]*M+this.xyzw[3]}weightedAltitude(y){return this.xyzw[0]*y.x+this.xyzw[1]*y.y+this.xyzw[2]*y.z+this.xyzw[3]*y.w}velocity(y){return this.xyzw[0]*y.x+this.xyzw[1]*y.y+this.xyzw[2]*y.z}velocityXYZ(y,k,M){return this.xyzw[0]*y+this.xyzw[1]*k+this.xyzw[2]*M}normalX(){return this.x}normalY(){return this.y}normalZ(){return this.z}static unitX(){return new Dt(1,0,0,0)}static unitY(){return new Dt(0,1,0,0)}static unitZ(){return new Dt(0,0,1,0)}static unitW(){return new Dt(0,0,0,1)}safeDivideOrNull(y,k){if(0!==y)return this.scale(1/y,k)}projectPointToPlane(y,k){const M=this.altitude(y),b=this.magnitudeSquaredXYZ(),E=Q.conditionalDivideCoordinate(-M,b,Q.largeFractionResult*Q.largeFractionResult);return void 0===E?y.clone(k):y.plusXYZ(E*this.x,E*this.y,E*this.z,k)}scale(y,k){return(k=k||new Dt).xyzw[0]=this.xyzw[0]*y,k.xyzw[1]=this.xyzw[1]*y,k.xyzw[2]=this.xyzw[2]*y,k.xyzw[3]=this.xyzw[3]*y,k}negate(y){return(y=y||new Dt).xyzw[0]=-this.xyzw[0],y.xyzw[1]=-this.xyzw[1],y.xyzw[2]=-this.xyzw[2],y.xyzw[3]=-this.xyzw[3],y}normalizeWeight(y){const k=Q.correctSmallFraction(this.xyzw[3]);return y=y||new Dt,this.safeDivideOrNull(k,y)}realPoint(y){const k=Q.correctSmallFraction(this.xyzw[3]);if(0===k)return;const M=1/k;return j.create(this.xyzw[0]*M,this.xyzw[1]*M,this.xyzw[2]*M,y)}realPointOrVector(){const y=Q.correctSmallFraction(this.xyzw[3]);if(0===y)return $.create(this.x,this.y,this.z);const k=1/y;return j.create(this.x*k,this.y*k,this.z*k)}static createRealPoint3dDefault000(y,k,M,b,E){const D=Q.correctSmallFraction(b),R=0===D?0:1/D;return j.create(y*R,k*R,M*R,E)}static createRealDerivativeRay3dDefault000(y,k,M,b,E,D,R,X,z){const N=Q.correctSmallFraction(b),Y=0===N?0:1/N,O=Y*Y;return bt.createXYZUVW(y*Y,k*Y,M*Y,(E*b-X*y)*O,(D*b-X*k)*O,(R*b-X*M)*O,z)}static createRealDerivativePlane3dByOriginAndVectorsDefault000(y,k,M,b,E,D,R,X,z,N,Y,O,B){const V=Q.correctSmallFraction(b),U=0===V?0:1/V,L=U*U,Z=y*U,q=k*U,jr=M*U,Gr=(E*b-X*y)*L,Jr=(D*b-X*k)*L,Kr=(R*b-X*M)*L;return Et.createOriginAndVectorsXYZ(Z,q,jr,Gr,Jr,Kr,Rt(z,X,O,Z,Gr,U),Rt(N,X,O,q,Jr,U),Rt(Y,X,O,jr,Kr,U),B)}realPointDefault000(y){const k=Q.correctSmallFraction(this.xyzw[3]);if(0===k)return j.create(0,0,0,y);y=y||new j;const M=1/k;return j.create(this.xyzw[0]*M,this.xyzw[1]*M,this.xyzw[2]*M,y)}normalizeXYZW(y){const k=Q.correctSmallFraction(this.magnitudeXYZW());return y=y||new Dt,this.safeDivideOrNull(k,y)}static determinantIndexed3X3(y,k,M,b,E,D){return Q.tripleProduct(y.xyzw[b],y.xyzw[E],y.xyzw[D],k.xyzw[b],k.xyzw[E],k.xyzw[D],M.xyzw[b],M.xyzw[E],M.xyzw[D])}static perpendicularPoint4dPlane(y,k,M){return Dt.create(Dt.determinantIndexed3X3(y,k,M,1,2,3),-Dt.determinantIndexed3X3(y,k,M,2,3,0),Dt.determinantIndexed3X3(y,k,M,3,0,1),-Dt.determinantIndexed3X3(y,k,M,0,1,2))}toPlane3dByOriginAndUnitNormal(y){return _t.createFrom(this,y)}normalizeQuaternion(){const y=Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w);if(y>0){const k=1/y;this.x*=k,this.y*=k,this.z*=k,this.w*=k}return y}static interpolateQuaternions(y,k,M,b){if(b||(b=new Dt),0===k)return y;if(1===k)return M;if(.5===k)return y.plus(M,b),b.normalizeQuaternion(),b;const E=y.clone(),D=M.clone();let R=y.dotProduct(M);if(R<0&&(D.negate(D),R=-R),R>.9995)return E.interpolate(k,D,b),b.normalizeQuaternion(),b;R<-1?R=-1:R>1&&(R=1);const X=new Dt;D.plusScaled(E,-R,X),X.normalizeQuaternion();const z=Math.acos(R)*k;return Dt.createAdd2Scaled(E,Math.cos(z),X,Math.sin(z))}radiansToPoint4dXYZW(y){const k=this.magnitudeXYZW(),M=y.magnitudeXYZW(),b=this.dotProduct(y),E=Q.conditionalDivideFraction(b,k*M);if(void 0!==E)return Math.acos(E)}}class Xt{constructor(){this._coffs=new Float64Array(16)}setFrom(y){for(let k=0;k<16;k++)this._coffs[k]=y._coffs[k]}clone(y){if(y===this)return this;void 0===y&&(y=new Xt);for(let k=0;k<16;k++)y._coffs[k]=this._coffs[k];return y}setZero(){for(let y=0;y<16;y++)this._coffs[y]=0}setIdentity(){for(let y=0;y<16;y++)this._coffs[y]=0;this._coffs[0]=this._coffs[5]=this._coffs[10]=this._coffs[15]=1}static is1000(y,k,M,b,E){return Math.abs(y-1)<=E&&Math.abs(k)<=E&&Math.abs(M)<=E&&Math.abs(b)<=E}isIdentity(y=1e-10){return Xt.is1000(this._coffs[0],this._coffs[1],this._coffs[2],this._coffs[3],y)&&Xt.is1000(this._coffs[5],this._coffs[6],this._coffs[7],this._coffs[4],y)&&Xt.is1000(this._coffs[10],this._coffs[11],this._coffs[8],this._coffs[9],y)&&Xt.is1000(this._coffs[15],this._coffs[12],this._coffs[13],this._coffs[14],y)}static createZero(y){return y?(y.setZero(),y):new Xt}static createRowValues(y,k,M,b,E,D,R,X,z,N,Y,O,B,V,U,L,Z){return(Z=Z||new Xt)._coffs[0]=y,Z._coffs[1]=k,Z._coffs[2]=M,Z._coffs[3]=b,Z._coffs[4]=E,Z._coffs[5]=D,Z._coffs[6]=R,Z._coffs[7]=X,Z._coffs[8]=z,Z._coffs[9]=N,Z._coffs[10]=Y,Z._coffs[11]=O,Z._coffs[12]=B,Z._coffs[13]=V,Z._coffs[14]=U,Z._coffs[15]=L,Z}static createRows(y,k,M,b,E){return this.createRowValues(y.x,y.y,y.z,y.w,k.x,k.y,k.z,k.w,M.x,M.y,M.z,M.w,b.x,b.y,b.z,b.w,E)}setOriginAndVectors(y,k,M,b){this._coffs[0]=k.x,this._coffs[1]=M.x,this._coffs[2]=b.x,this._coffs[3]=y.x,this._coffs[4]=k.y,this._coffs[5]=M.y,this._coffs[6]=b.y,this._coffs[7]=y.y,this._coffs[8]=k.z,this._coffs[9]=M.z,this._coffs[10]=b.z,this._coffs[11]=y.z,this._coffs[12]=0,this._coffs[13]=0,this._coffs[14]=0,this._coffs[15]=1}static createTransform(y,k){const M=y.matrix,b=y.origin;return Xt.createRowValues(M.coffs[0],M.coffs[1],M.coffs[2],b.x,M.coffs[3],M.coffs[4],M.coffs[5],b.y,M.coffs[6],M.coffs[7],M.coffs[8],b.z,0,0,0,1,k)}static createIdentity(y){return(y=Xt.createZero(y))._coffs[0]=1,y._coffs[5]=1,y._coffs[10]=1,y._coffs[15]=1,y}static createTranslationXYZ(y,k,M,b){return(b=Xt.createZero(b))._coffs[0]=1,b._coffs[5]=1,b._coffs[10]=1,b._coffs[15]=1,b._coffs[3]=y,b._coffs[7]=k,b._coffs[11]=M,b}plusScaled(y,k,M){M=this.clone(M);for(let b=0;b<16;b++)M._coffs[b]+=k*y._coffs[b];return M}static createTranslationAndScaleXYZ(y,k,M,b,E,D,R){return Xt.createRowValues(b,0,0,y,0,E,0,k,0,0,D,M,0,0,0,1,R)}static createBoxToBox(y,k,M,b,E){const D=k.x-y.x,R=k.y-y.y,X=k.z-y.z,z=b.x-M.x,N=b.y-M.y,Y=b.z-M.z,O=Q.conditionalDivideFraction(z,D),B=Q.conditionalDivideFraction(N,R),V=Q.conditionalDivideFraction(Y,X);if(void 0!==O&&void 0!==B&&void 0!==V)return Xt.createTranslationAndScaleXYZ(M.x-O*y.x,M.y-B*y.y,M.z-V*y.z,O,B,V,E)}setFromJSON(y){if(Q.isArrayOfNumberArray(y,4,4))for(let k=0;k<4;++k)for(let M=0;M<4;++M)this._coffs[4*k+M]=y[k][M];else this.setZero()}maxDiff(y){let k=0;for(let M=0;M<16;M++)k=Math.max(k,Math.abs(this._coffs[M]-y._coffs[M]));return k}maxAbs(){let y=0;for(let k=0;k<16;k++)y=Math.max(y,Math.abs(this._coffs[k]));return y}isAlmostEqual(y){return Q.isSmallMetricDistance(this.maxDiff(y))}isExactEqual(y){return 0===this.maxDiff(y)}toJSON(){const y=[];for(let k=0;k<4;++k){const M=4*k;y.push([this._coffs[M],this._coffs[M+1],this._coffs[M+2],this._coffs[M+3]])}return y}static fromJSON(y){const k=new Xt;return k.setFromJSON(y),k}getSteppedPoint(y,k,M){return Dt.create(this._coffs[y],this._coffs[y+k],this._coffs[y+2*k],this._coffs[y+3*k],M)}columnX(){return this.getSteppedPoint(0,4)}columnY(){return this.getSteppedPoint(1,4)}columnZ(){return this.getSteppedPoint(2,4)}columnW(){return this.getSteppedPoint(3,4)}rowX(){return this.getSteppedPoint(0,1)}rowY(){return this.getSteppedPoint(4,1)}rowZ(){return this.getSteppedPoint(8,1)}rowW(){return this.getSteppedPoint(12,1)}get hasPerspective(){return 0!==this._coffs[12]||0!==this._coffs[13]||0!==this._coffs[14]||1!==this._coffs[15]}diagonal(){return this.getSteppedPoint(0,5)}weight(){return this._coffs[15]}matrixPart(){return xt.createRowValues(this._coffs[0],this._coffs[1],this._coffs[2],this._coffs[4],this._coffs[5],this._coffs[6],this._coffs[8],this._coffs[9],this._coffs[10])}get asTransform(){if(!this.hasPerspective)return pt.createRowValues(this._coffs[0],this._coffs[1],this._coffs[2],this._coffs[3],this._coffs[4],this._coffs[5],this._coffs[6],this._coffs[7],this._coffs[8],this._coffs[9],this._coffs[10],this._coffs[11])}multiplyMatrixMatrix(y,k){k=k&&k!==this&&k!==y?k:new Xt;for(let M=0;M<16;M+=4)for(let b=0;b<4;b++)k._coffs[M+b]=this._coffs[M]*y._coffs[b]+this._coffs[M+1]*y._coffs[b+4]+this._coffs[M+2]*y._coffs[b+8]+this._coffs[M+3]*y._coffs[b+12];return k}multiplyMatrixMatrixTranspose(y,k){k=k&&k!==this&&k!==y?k:new Xt;let M=0;for(let b=0;b<16;b+=4)for(let E=0;E<16;E+=4)k._coffs[M++]=this._coffs[b]*y._coffs[E]+this._coffs[b+1]*y._coffs[E+1]+this._coffs[b+2]*y._coffs[E+2]+this._coffs[b+3]*y._coffs[E+3];return k}multiplyMatrixTransposeMatrix(y,k){k=k&&k!==this&&k!==y?k:new Xt;let M=0;for(let b=0;b<4;b+=1)for(let E=0;E<4;E+=1)k._coffs[M++]=this._coffs[b]*y._coffs[E]+this._coffs[b+4]*y._coffs[E+4]+this._coffs[b+8]*y._coffs[E+8]+this._coffs[b+12]*y._coffs[E+12];return k}cloneTransposed(y){return Xt.createRowValues(this._coffs[0],this._coffs[4],this._coffs[8],this._coffs[12],this._coffs[1],this._coffs[5],this._coffs[9],this._coffs[13],this._coffs[2],this._coffs[6],this._coffs[10],this._coffs[14],this._coffs[3],this._coffs[7],this._coffs[11],this._coffs[15],y)}multiplyXYZW(y,k,M,b,E){return(E=E||Dt.createZero()).set(this._coffs[0]*y+this._coffs[1]*k+this._coffs[2]*M+this._coffs[3]*b,this._coffs[4]*y+this._coffs[5]*k+this._coffs[6]*M+this._coffs[7]*b,this._coffs[8]*y+this._coffs[9]*k+this._coffs[10]*M+this._coffs[11]*b,this._coffs[12]*y+this._coffs[13]*k+this._coffs[14]*M+this._coffs[15]*b)}multiplyBlockedFloat64ArrayInPlace(y){const k=y.length;let M,b,E,D;for(let R=0;R+3<k;R+=4)M=y[R],b=y[R+1],E=y[R+2],D=y[R+3],y[R]=this._coffs[0]*M+this._coffs[1]*b+this._coffs[2]*E+this._coffs[3]*D,y[R+1]=this._coffs[4]*M+this._coffs[5]*b+this._coffs[6]*E+this._coffs[7]*D,y[R+2]=this._coffs[8]*M+this._coffs[9]*b+this._coffs[10]*E+this._coffs[11]*D,y[R+3]=this._coffs[12]*M+this._coffs[13]*b+this._coffs[14]*E+this._coffs[15]*D}multiplyPoint3d(y,k,M){return this.multiplyXYZW(y.x,y.y,y.z,k,M)}multiplyPoint3dArray(y,k,M=1){y.forEach(((y,b)=>{k[b]=this.multiplyXYZW(y.x,y.y,y.z,M,k[b])}))}multiplyTransposeXYZW(y,k,M,b,E){return(E=E||Dt.createZero()).set(this._coffs[0]*y+this._coffs[4]*k+this._coffs[8]*M+this._coffs[12]*b,this._coffs[1]*y+this._coffs[5]*k+this._coffs[9]*M+this._coffs[13]*b,this._coffs[2]*y+this._coffs[6]*k+this._coffs[10]*M+this._coffs[14]*b,this._coffs[3]*y+this._coffs[7]*k+this._coffs[11]*M+this._coffs[15]*b)}rowDotColumn(y,k,M){const b=4*y,E=M;return this._coffs[b]*k._coffs[E]+this._coffs[b+1]*k._coffs[E+4]+this._coffs[b+2]*k._coffs[E+8]+this._coffs[b+3]*k._coffs[E+12]}rowDotXYZW(y,k,M,b,E){const D=4*y;return this._coffs[D]*k+this._coffs[D+1]*M+this._coffs[D+2]*b+this._coffs[D+3]*E}rowDotRow(y,k,M){const b=4*y,E=4*M;return this._coffs[b]*k._coffs[E]+this._coffs[b+1]*k._coffs[E+1]+this._coffs[b+2]*k._coffs[E+2]+this._coffs[b+3]*k._coffs[E+3]}columnDotColumn(y,k,M){const b=y,E=M;return this._coffs[b]*k._coffs[E]+this._coffs[b+4]*k._coffs[E+4]+this._coffs[b+8]*k._coffs[E+8]+this._coffs[b+12]*k._coffs[E+12]}columnDotRow(y,k,M){const b=y,E=4*M;return this._coffs[b]*k._coffs[E]+this._coffs[b+4]*k._coffs[E+1]+this._coffs[b+8]*k._coffs[E+2]+this._coffs[b+12]*k._coffs[E+3]}atIJ(y,k){return this._coffs[4*y+k]}setAtIJ(y,k,M){this._coffs[4*y+k]=M}multiplyXYZWQuietRenormalize(y,k,M,b,E){(E=E||j.createZero()).set(this._coffs[0]*y+this._coffs[1]*k+this._coffs[2]*M+this._coffs[3]*b,this._coffs[4]*y+this._coffs[5]*k+this._coffs[6]*M+this._coffs[7]*b,this._coffs[8]*y+this._coffs[9]*k+this._coffs[10]*M+this._coffs[11]*b);const D=this._coffs[12]*y+this._coffs[13]*k+this._coffs[14]*M+this._coffs[15]*b,R=Q.conditionalDivideCoordinate(E.x,D),X=Q.conditionalDivideCoordinate(E.y,D),z=Q.conditionalDivideCoordinate(E.z,D);return void 0!==R&&void 0!==X&&void 0!==z&&(E.x=R,E.y=X,E.z=z),E}multiplyPoint4dArrayQuietRenormalize(y,k){y.forEach(((y,M)=>{k[M]=this.multiplyXYZWQuietRenormalize(y.x,y.y,y.z,y.w,k[M])}))}multiplyPoint4d(y,k){return this.multiplyXYZW(y.xyzw[0],y.xyzw[1],y.xyzw[2],y.xyzw[3],k)}multiplyTransposePoint4d(y,k){return this.multiplyTransposeXYZW(y.xyzw[0],y.xyzw[1],y.xyzw[2],y.xyzw[3],k)}multiplyPoint3dQuietNormalize(y,k){return this.multiplyXYZWQuietRenormalize(y.x,y.y,y.z,1,k)}multiplyPoint3dArrayQuietNormalize(y){y.forEach((y=>this.multiplyXYZWQuietRenormalize(y.x,y.y,y.z,1,y)))}addMomentsInPlace(y,k,M,b){this._coffs[0]+=y*y,this._coffs[1]+=y*k,this._coffs[2]+=y*M,this._coffs[3]+=y*b,this._coffs[4]+=k*y,this._coffs[5]+=k*k,this._coffs[6]+=k*M,this._coffs[7]+=k*b,this._coffs[8]+=M*y,this._coffs[9]+=M*k,this._coffs[10]+=M*M,this._coffs[11]+=M*b,this._coffs[12]+=b*y,this._coffs[13]+=b*k,this._coffs[14]+=b*M,this._coffs[15]+=b*b}addScaledInPlace(y,k=1){for(let M=0;M<16;M++)this._coffs[M]+=k*y._coffs[M]}rowOperation(y,k,M,b){if(0===b)return;let E=4*y+M,D=4*k+M;for(let R=M;R<4;R++,E++,D++)this._coffs[D]+=b*this._coffs[E]}determinant(){const y=this._coffs;return Q.determinant4x4(y[0],y[1],y[2],y[3],y[4],y[5],y[6],y[7],y[8],y[9],y[10],y[11],y[12],y[13],y[14],y[15])}createInverse(y){let k=this.columnX().maxAbs();if(0===k)return;const M=1/k;if(k=this.columnY().maxAbs(),0===k)return;const b=1/k;if(k=this.columnZ().maxAbs(),0===k)return;const E=1/k;if(k=this.columnW().maxAbs(),0===k)return;const D=1/k,R=this.columnX(),X=this.columnY(),z=this.columnZ(),N=this.columnW();R.scale(M,R),X.scale(b,X),z.scale(E,z),N.scale(D,N);const Y=Dt.perpendicularPoint4dPlane(X,z,N),O=Dt.perpendicularPoint4dPlane(R,N,z),B=Dt.perpendicularPoint4dPlane(N,R,X),V=Dt.perpendicularPoint4dPlane(z,X,R);y=Xt.createRows(Y,O,B,V,y);const U=Y.dotProduct(R),L=O.dotProduct(X),Z=B.dotProduct(z),q=V.dotProduct(N),jr=y.maxAbs();if(U*L>0&&U*Z>0&&U*q>0&&void 0!==Q.conditionalDivideCoordinate(jr,U)){const k=1/U;return y.scaleRowsInPlace(M*k,b*k,E*k,D*k),y}}rowArrays(y){return y?[[y(this._coffs[0]),y(this._coffs[1]),y(this._coffs[2]),y(this._coffs[3])],[y(this._coffs[4]),y(this._coffs[5]),y(this._coffs[6]),y(this._coffs[7])],[y(this._coffs[8]),y(this._coffs[9]),y(this._coffs[10]),y(this._coffs[11])],[y(this._coffs[12]),y(this._coffs[13]),y(this._coffs[14]),y(this._coffs[15])]]:[[this._coffs[0],this._coffs[1],this._coffs[2],this._coffs[3]],[this._coffs[4],this._coffs[5],this._coffs[6],this._coffs[7]],[this._coffs[8],this._coffs[9],this._coffs[10],this._coffs[11]],[this._coffs[12],this._coffs[13],this._coffs[14],this._coffs[15]]]}scaleRowsInPlace(y,k,M,b){for(let E=0;E<4;E++)this._coffs[E]*=y;for(let E=4;E<8;E++)this._coffs[E]*=k;for(let E=8;E<12;E++)this._coffs[E]*=M;for(let E=12;E<16;E++)this._coffs[E]*=b}addScaledOuterProductInPlace(y,k,M){let b=y.x*M;this._coffs[0]+=b*k.x,this._coffs[1]+=b*k.y,this._coffs[2]+=b*k.z,this._coffs[3]+=b*k.w,b=y.y*M,this._coffs[4]+=b*k.x,this._coffs[5]+=b*k.y,this._coffs[6]+=b*k.z,this._coffs[7]+=b*k.w,b=y.z*M,this._coffs[8]+=b*k.x,this._coffs[9]+=b*k.y,this._coffs[10]+=b*k.z,this._coffs[11]+=b*k.w,b=y.w*M,this._coffs[12]+=b*k.x,this._coffs[13]+=b*k.y,this._coffs[14]+=b*k.z,this._coffs[15]+=b*k.w}addTranslationSandwichInPlace(y,k,M,b,E){const D=y._coffs[3],R=y._coffs[7],X=y._coffs[11],z=y._coffs[12],N=y._coffs[13],Y=y._coffs[14],O=y._coffs[15],B=k*O,V=M*O,U=b*O;this._coffs[0]+=E*(y._coffs[0]+k*D+z*k+k*B),this._coffs[1]+=E*(y._coffs[1]+M*D+N*k+k*V),this._coffs[2]+=E*(y._coffs[2]+b*D+Y*k+k*U),this._coffs[3]+=E*(D+B),this._coffs[4]+=E*(y._coffs[4]+k*R+z*M+M*B),this._coffs[5]+=E*(y._coffs[5]+M*R+N*M+M*V),this._coffs[6]+=E*(y._coffs[6]+b*R+Y*M+M*U),this._coffs[7]+=E*(R+V),this._coffs[8]+=E*(y._coffs[8]+k*X+z*b+b*B),this._coffs[9]+=E*(y._coffs[9]+M*X+N*b+b*V),this._coffs[10]+=E*(y._coffs[10]+b*X+Y*b+b*U),this._coffs[11]+=E*(X+U),this._coffs[12]+=E*(z+B),this._coffs[13]+=E*(N+V),this._coffs[14]+=E*(Y+U),this._coffs[15]+=E*O}multiplyTranslationSandwichInPlace(y,k,M){const b=this._coffs[3],E=this._coffs[7],D=this._coffs[11],R=this._coffs[12],X=this._coffs[13],z=this._coffs[14],N=this._coffs[15],Y=y*N,O=k*N,B=M*N;this._coffs[0]+=y*b+R*y+y*Y,this._coffs[1]+=k*b+X*y+y*O,this._coffs[2]+=M*b+z*y+y*B,this._coffs[3]+=Y,this._coffs[4]+=y*E+R*k+k*Y,this._coffs[5]+=k*E+X*k+k*O,this._coffs[6]+=M*E+z*k+k*B,this._coffs[7]+=O,this._coffs[8]+=y*D+R*M+M*Y,this._coffs[9]+=k*D+X*M+M*O,this._coffs[10]+=M*D+z*M+M*B,this._coffs[11]+=B,this._coffs[12]+=Y,this._coffs[13]+=O,this._coffs[14]+=B}}class zt{constructor(y,k){this.xTest=y,this.yTest=k,this.u0=this.v0=this.u1=this.v1=0,this.numLeftCrossing=this.numRightCrossing=0,this.numHit=0}tryStartEdge(y,k,M,b){return k!==this.yTest&&(this.u0=y-this.xTest,this.v0=k-this.yTest,this.u1=M-this.xTest,this.v1=b-this.yTest,!0)}updateUV01(y,k){return this.u0=this.u1,this.v0=this.v1,this.u1=y,this.v1=k,!0}advance(y,k){const M=y-this.xTest,b=k-this.yTest,E=b*this.v1;if(E>0)return this.updateUV01(M,b);if(E<0){const y=-this.v1/(b-this.v1),k=this.u1+y*(M-this.u1);return 0===k?(this.numHit++,!1):(k>0?this.numRightCrossing++:this.numLeftCrossing++,this.updateUV01(M,b))}return 0===b?0===this.v1?M*this.u1<=0?(this.numHit++,!1):(this.u1=M,this.v1=b,!0):0===M?(this.numHit++,!1):this.updateUV01(M,b):0===this.u1?(this.numHit++,!1):(this.v0*b<0&&(this.u1>0?this.numRightCrossing++:this.numLeftCrossing++),this.updateUV01(M,b))}classifyCounts(){return this.numHit>0?0:1&~this.numLeftCrossing?-1:1}}class Nt{constructor(y,k,M,b,E){this.numStroke=y,this.curveLength=k,this.a0=M,this.a1=b,this.componentData=E}static createWithCurvePrimitive(y,k,M,b,E,D){const R=new Nt(k,M,b,E,D);return R.primitive=y,R}static createWithComponentIndex(y=0,k=0,M=0,b=0,E=0){const D=new Nt(k,M,b,E);return D.componentIndex=y,D}static createWithCurvePrimitiveAndOptionalParent(y,k,M){const b=k?k.a1:0,E=new Nt(0,0,b,b,M);return E.primitive=y,E}addToCountAndLength(y,k){const M=this.a1+k;this.componentData&&this.componentData.push(new Nt(y,k,this.a1,M)),this.numStroke+=y,this.curveLength+=k,this.a1=M}isCompatibleComponentStructure(y,k){if(k&&this.numStroke!==y.numStroke)return!1;if(void 0===this.componentData&&void 0===y.componentData)return!0;if(this.componentData&&y.componentData){if(this.componentData.length!==y.componentData.length)return!1;const M=this.componentData.length;for(let b=0;b<M;b++)if(!this.componentData[b].isCompatibleComponentStructure(y.componentData[b],k))return!1;return!0}return!1}clone(){const y=new Nt(this.numStroke,this.curveLength,this.a0,this.a1);if(this.componentData){y.componentData=[];for(const k of this.componentData)y.componentData.push(k.clone())}return y}fractionToA(y){return Q.interpolate(this.a0,y,this.a1)}}class Ot{range(y,k){k&&k.setNull();const M=k||ut.createNull();return this.extendRange(M,y),M}tryTranslateInPlace(y,k=0,M=0){return this.tryTransformInPlace(pt.createTranslationXYZ(y,k,M))}get children(){}isAlmostEqual(y){if(this.isSameGeometryClass(y)){const k=this.children,M=y.children;if(k&&M){if(k.length!==M.length)return!1;for(let y=0;y<k.length;y++)if(!k[y].isAlmostEqual(M[y]))return!1;return!0}return!k&&!M}return!1}static areAlmostEqual(y,k){return y instanceof Ot&&k instanceof Ot?y.isAlmostEqual(k):void 0===y&&void 0===k}}class Yt{static getRow(y){const k=Yt._allRows;for(0===k.length&&(k.push(new Float64Array([1])),k.push(new Float64Array([1,1])),k.push(new Float64Array([1,2,1])),k.push(new Float64Array([1,3,3,1])),k.push(new Float64Array([1,4,6,4,1])),k.push(new Float64Array([1,5,10,10,5,1])),k.push(new Float64Array([1,6,15,20,15,6,1])),k.push(new Float64Array([1,7,21,35,35,21,7,1])));k.length<=y;){const y=k.length,M=k[y-1],b=new Float64Array(y+1);b[0]=1;for(let k=1;k<y;k++)b[k]=M[k-1]+M[k];b[y]=1,k.push(b)}return k[y]}static getBezierBasisValues(y,k,M){const b=y-1,E=Yt.getRow(b);(void 0===M||M.length<y)&&(M=new Float64Array(y));for(let X=0;X<y;X++)M[X]=E[X];let D=k;for(let X=1;X<y;X++,D*=k)M[X]*=D;const R=1-k;D=R;for(let X=y-2;X>=0;X--,D*=R)M[X]*=D;return M}static getBezierBasisDerivatives(y,k,M){(void 0===M||M.length<y)&&(M=new Float64Array(y));const b=y-1;(M=this.getBezierBasisValues(y-1,k,M))[y-1]=b*M[y-2];for(let E=y-2;E>0;E--)M[E]=b*(M[E-1]-M[E]);return M[0]=-b*M[0],M}}Yt._allRows=[];class Bt{constructor(y){if(y instanceof Float64Array)this.coffs=y.slice();else if(Array.isArray(y)){this.coffs=new Float64Array(y.length);let k=0;for(const M of y)this.coffs[k++]=M}else this.coffs=new Float64Array(y)}allocateToOrder(y){this.coffs.length!==y?this.coffs=new Float64Array(y):this.coffs.fill(0)}createPeer(){return new Lt(this.order)}get order(){return this.coffs.length}copyFrom(y){if(this.order===y.order)for(let k=0;k<this.coffs.length;k++)this.coffs[k]=y.coffs[k];else this.coffs=y.coffs.slice()}scaleInPlace(y){for(let k=0;k<this.coffs.length;k++)this.coffs[k]*=y}addInPlace(y){for(let k=0;k<this.coffs.length;k++)this.coffs[k]+=y}roots(y,k){const M=Lt.create(this);M.addInPlace(-y);const b=Lt.deflateRoots(M);return this.filter01(b,!0)}filter01(y,k=!1){if(!y||!k)return y;let M=!1;for(const b of y)if(Q.isIn01(b)){M=!0;break}if(M){const k=[];for(const M of y)Q.isIn01(M)&&k.push(M);return k}}zero(){this.coffs.fill(0)}subdivide(y,k,M){const b=this.order;if(k.order!==b||M.order!==b)return!1;const E=1-y;M.copyFrom(this);let D=b-1;for(let R=0;R<b;R++){k.coffs[R]=M.coffs[0];for(let k=0;k<D;k++)M.coffs[k]=E*M.coffs[k]+y*M.coffs[k+1];D--}return!0}static maxAbsDiff(y,k){const M=y.order;if(k.order!==M)return;let b,E=0;for(let D=0;D<M;D++)b=Math.abs(y.coffs[D]-k.coffs[D]),b>E&&(E=b);return E}}class Vt{static accumulateScaledShiftedComponentTimesComponentDelta(y,k,M,b,E,D,R,X){const z=b-1,N=b,Y=b+z-1;if(y.length!==Y)return;const O=Yt.getRow(N-1),B=Yt.getRow(z-1),V=Yt.getRow(Y-1);let U;for(let L=0;L<N;L++){U=E*(R+k[D+L*M])*O[L];for(let b=0,E=X;b<z;b++,E+=M)y[L+b]+=U*B[b]*(k[E+M]-k[E])/V[L+b]}}static scaledComponentSum(y,k,M,b,E,D,R,X){const z=b;if(y.length===z)for(let N=0,Y=0;N<z;N++,Y+=M)y[N]=D*k[Y+E]+X*k[Y+R]}static componentDifference(y,k,M,b,E){const D=b-1;if(y.length===D)for(let R=0,X=E;R<D;X+=M,R++)y[R]=k[X+M]-k[X]}static accumulateProduct(y,k,M,b=1){const E=k.length,D=M.length,R=E+D-1;if(y.length!==R)return;let X,z,N;const Y=Yt.getRow(E-1),O=Yt.getRow(D-1),B=Yt.getRow(R-1);for(X=0;X<E;X++)for(N=b*Y[X]*k[X],z=0;z<D;z++)y[X+z]+=N*O[z]*M[z]/B[X+z]}static accumulateProductWithDifferences(y,k,M,b=1){const E=k.length-1,D=M.length,R=E+D-1;if(y.length!==R)return;let X,z,N;const Y=Yt.getRow(E-1),O=Yt.getRow(D-1),B=Yt.getRow(R-1);for(X=0;X<E;X++)for(N=b*Y[X]*(k[X+1]-k[X]),z=0;z<D;z++)y[X+z]+=N*O[z]*M[z]/B[X+z]}static univariateDifference(y,k){const M=k.length;if(k.length+1!==M)for(let b=0;b<M;b++)k[b]=y[b+1]-y[b]}static accumulate(y,k,M){if(M.length===k)for(let b=0;b<k;b++)M[b]+=y[b]}}class Lt extends Bt{get order(){return this._order}constructor(y){super(y),this._order=super.order}allocateOrder(y){this._order!==y&&(super.allocateToOrder(y),this._order=y),this.coffs.fill(0)}clone(y=!1){if(y){const y=new Lt(this.order);return y.coffs=this.coffs.slice(0,this.order),y}const k=new Lt(this.coffs.length);return k._order=this._order,k.coffs=this.coffs.slice(),k}static create(y){const k=new Lt(y.order);return k.coffs=y.coffs.slice(),k}static createCoffs(y){return new Lt(y)}static createArraySubset(y,k,M,b){b?b.order!==M&&b.allocateToOrder(M):b=new Lt(M);for(let E=0;E<M;E++)b.coffs[E]=y[k+E];return b}static createProduct(y,k){const M=new Lt(y.order+k.order-1),b=Yt.getRow(y.order-1),E=Yt.getRow(k.order-1),D=Yt.getRow(y.order+k.order-2);for(let R=0;R<y.order;R++){const X=y.coffs[R]*b[R];for(let y=0;y<k.order;y++){const b=k.coffs[y]*E[y],z=R+y,N=D[z];M.coffs[z]+=X*b/N}}return M}addSquaredSquaredBezier(y,k){const M=y.length,b=this.order;if(2*M!==b+1)return!1;const E=Yt.getRow(M-1),D=Yt.getRow(b-1),R=this.coffs;for(let X=0;X<M;X++){const b=y[X]*E[X]*k;for(let k=0;k<M;k++){const M=y[k]*E[k],z=X+k,N=D[z];R[z]+=b*M/N}}return!0}addConstant(y){for(let k=0;k<this.coffs.length;k++)this.coffs[k]+=y}basisFunctions(y,k){this._basisValues=Yt.getBezierBasisValues(this.order,y,this._basisValues),(!k||k.length<this.order)&&(k=new Float64Array(this.order));let M=0;for(const b of this._basisValues)k[M++]=b;return k}static sumWeightedBlocks(y,k,M,b,E){for(let X=0;X<b;X++)E[X]=0;let D,R=0;for(let X=0;X<k;X++){const k=y[X];for(D=0;D<b;D++)E[D]+=k*M[R++]}}sumBasisFunctions(y,k,M,b){return(!b||b.length<M)&&(b=new Float64Array(M)),this._basisValues=Yt.getBezierBasisValues(this.order,y,this._basisValues),Lt.sumWeightedBlocks(this._basisValues,this.order,k,M,b),b}sumBasisFunctionDerivatives(y,k,M,b){return(!b||b.length<M)&&(b=new Float64Array(M)),this._basisValues=Yt.getBezierBasisDerivatives(this.order,y,this._basisValues),Lt.sumWeightedBlocks(this._basisValues,this.order,k,M,b),b}evaluate(y){this._basisValues=Yt.getBezierBasisValues(this.order,y,this._basisValues);let k=0;for(let M=0;M<this.order;M++)k+=this._basisValues[M]*this.coffs[M];return k}deflateLeft(){const y=this.order,k=y-1,M=Yt.getRow(k-1),b=Yt.getRow(y-1);let E;for(let D=0;D<k;D++)E=this.coffs[D+1],this.coffs[D]=E*b[D+1]/M[D];this._order--}deflateRight(){const y=this.order,k=y-1,M=Yt.getRow(k-1),b=Yt.getRow(y-1);let E,D;for(let R=0;R<k;R++)E=this.coffs[R],D=E*b[R]/M[R],this.coffs[R]=D;this._order--}deflateRoot(y){const k=this.order,M=k-1;if(1===k)return this._order=0,this.coffs[0];if(k<1)return this._order=0,0;const b=Yt.getRow(k-1),E=Yt.getRow(M-1),D=-y,R=1-y;let X=0;if(y>.5){let y,z,N=this.coffs[0]/D;this.coffs[0]=N;for(let k=1;k<M;k++)z=this.coffs[k]*b[k],y=(z-N*R)/D,this.coffs[k]=y/E[k],N=y;X=this.coffs[k-1]-N*R}else{let y,z,N=this.coffs[k-1]/R;this.coffs[k-1]=N;for(let M=k-2;M>0;M--)z=this.coffs[M]*b[M],y=(z-N*D)/R,this.coffs[M]=y/E[M-1],N=y;X=this.coffs[0]-N*D;for(let k=0;k<M;k++)this.coffs[k]=this.coffs[k+1]}return this._order=M,X}runNewton(y,k=1e-11){const M=this.order-1;let b,E,D=0,R=y;const X=this.order,z=this.coffs,N=X-1;for(let Y=0;Y++<10;){Lt._basisBuffer=Yt.getBezierBasisValues(X,R,Lt._basisBuffer),b=0;for(let k=0;k<X;k++)b+=z[k]*Lt._basisBuffer[k];Lt._basisBuffer1=Yt.getBezierBasisValues(N,R,Lt._basisBuffer1),E=0;for(let k=0;k<N;k++)E+=(z[k+1]-z[k])*Lt._basisBuffer1[k];if(E*=M,Math.abs(b)>10*Math.abs(E))return;const y=b/E;if(Math.abs(y)<k){if(D++,D>=2)return R-y}else D=0;R-=y}}static deflateRoots(y){const k=[],M=y.coffs;let b,E,D,R,X;for(;y.order>1;){const z=y.order;if(0===M[0]){y.deflateLeft(),k.push(0);continue}let N=0,Y=0;for(let O=1;O<z;O++)if(b=M[O-1],E=M[O],b*E<=0&&(N++,D=-b/(E-b),R=(O-1+D)/(z-1),X=y.runNewton(R,1e-10),void 0!==X)){k.push(X),y.deflateRoot(X),Y++;break}if(!Y)return k}return k}}class Ut extends Bt{constructor(y=0,k=0){super(2),this.coffs[0]=y,this.coffs[1]=k}clone(){return new Ut(this.coffs[0],this.coffs[1])}static solveCoffs(y,k){return Q.conditionalDivideFraction(-y,k-y)}basisFunctions(y,k){return(!k||k.length<2)&&(k=new Float64Array(2)),k[0]=1-y,k[1]=y,k}sumBasisFunctions(y,k,M,b){(!b||b.length<M)&&(b=new Float64Array(M));const E=1-y;for(let D=0;D<M;D++)b[D]=E*k[D]+y*k[D+M];return b}sumBasisFunctionDerivatives(y,k,M,b){(!b||b.length<M)&&(b=new Float64Array(M));for(let E=0;E<M;E++)b[E]=k[E+M]-k[E];return b}evaluate(y){return(1-y)*this.coffs[0]+y*this.coffs[1]}solve(y){const k=this.coffs[1]-this.coffs[0];return Q.conditionalDivideFraction(y-this.coffs[0],k)}roots(y,k){const M=this.solve(y);if(void 0!==M)return!k||Q.isIn01(M)?[M]:void 0}}class Zt{constructor(y=1e-11,k=2,M=15){this._numAccepted=0,this.numIterations=0,this._stepSizeTolerance=y,this._successiveConvergenceTarget=k,this._maxIterations=M}testConvergence(y){return Math.abs(y)<this._stepSizeTolerance?(this._numAccepted++,this._numAccepted>=this._successiveConvergenceTarget):(this._numAccepted=0,!1)}runIterations(){for(this._numAccepted=0,this.numIterations=0;this.numIterations++<this._maxIterations&&this.computeStep();){if(this.testConvergence(this.currentStepSize())&&this.applyCurrentStep(!0))return!0;this.applyCurrentStep(!1)}return!1}}class qt{}class Wt extends Zt{constructor(y,k){super(void 0,void 0,k),this._func=y,this.setTarget(0)}setX(y){return this._currentX=y,!0}getX(){return this._currentX}setTarget(y){this._target=y}applyCurrentStep(){return this.setX(this._currentX-this._currentStep)}computeStep(){if(this._func.evaluate(this._currentX)){const y=Q.conditionalDivideFraction(this._func.currentF-this._target,this._func.currentdFdX);if(void 0!==y)return this._currentStep=y,!0}return!1}currentStepSize(){return Math.abs(this._currentStep/(1+Math.abs(this._currentX)))}}class Gt{}class Ht extends Zt{constructor(y,k){super(void 0,void 0,k),this._func=y,this.derivativeH=1e-8}setX(y){return this._currentX=y,!0}getX(){return this._currentX}applyCurrentStep(){return this.setX(this._currentX-this._currentStep)}computeStep(){if(this._func.evaluate(this._currentX)){const y=this._func.currentF;if(this._func.evaluate(this._currentX+this.derivativeH)){const k=this._func.currentF,M=Q.conditionalDivideFraction(y,(k-y)/this.derivativeH);if(void 0!==M)return this._currentStep=M,!0}}return!1}currentStepSize(){return Math.abs(this._currentStep/(1+Math.abs(this._currentX)))}}class Jt{constructor(){this.currentF=Et.createXYPlane()}}class Qt extends Zt{constructor(y,k){super(void 0,void 0,k),this._func=y,this._currentStep=J.createZero(),this._currentUV=H.createZero()}setUV(y,k){return this._currentUV.set(y,k),!0}getU(){return this._currentUV.x}getV(){return this._currentUV.y}applyCurrentStep(){return this.setUV(this._currentUV.x-this._currentStep.x,this._currentUV.y-this._currentStep.y)}computeStep(){if(!this._func.evaluate(this._currentUV.x,this._currentUV.y))return!1;const y=this._func.currentF,k=y.vectorU,M=y.vectorV,b=y.origin;return!!Mt.linearSystem2d(k.x,M.x,k.y,M.y,b.x,b.y,this._currentStep)}currentStepSize(){return Q.maxAbsXY(this._currentStep.x/(1+Math.abs(this._currentUV.x)),this._currentStep.y/(1+Math.abs(this._currentUV.y)))}}class Kt extends Jt{constructor(y,k){super(),this._curveP=y,this._curveQ=k,this._rayP=bt.createZero(),this._rayQ=bt.createZero()}evaluate(y,k){return this._curveP.fractionToPointAndDerivative(y,this._rayP),this._curveQ.fractionToPointAndDerivative(k,this._rayQ),this.currentF.setOriginAndVectorsXYZ(this._rayP.origin.x-this._rayQ.origin.x,this._rayP.origin.y-this._rayQ.origin.y,0,this._rayP.direction.x,this._rayP.direction.y,0,-this._rayQ.direction.x,-this._rayQ.direction.y,0),!0}}class jt extends qt{constructor(y,k){super(),this._curveP=y,this._pointQ=k,this._planeP=Et.createXYPlane()}evaluate(y){this._curveP.fractionToPointAnd2Derivatives(y,this._planeP);const k=this._planeP.origin.x-this._pointQ.x,M=this._planeP.origin.y-this._pointQ.y,b=this._planeP.vectorU.x,E=this._planeP.vectorU.y,D=this._planeP.vectorV.x,R=this._planeP.vectorV.y;return this.currentF=b*k+E*M,this.currentdFdX=D*k+b*b+R*M+E*E,!0}}class $t extends Jt{constructor(y,k){super(),this._curveP=y,this._curveQ=k,this._planeP=Et.createXYPlane(),this._planeQ=Et.createXYPlane()}evaluate(y,k){this._curveP.fractionToPointAnd2Derivatives(y,this._planeP),this._curveQ.fractionToPointAnd2Derivatives(k,this._planeQ);const M=this._planeP.origin.x-this._planeQ.origin.x,b=this._planeP.origin.y-this._planeQ.origin.y,E=this._planeP.vectorU.x,D=this._planeP.vectorU.y,R=this._planeQ.vectorU.x,X=this._planeQ.vectorU.y,z=this._planeP.vectorV.x,N=this._planeP.vectorV.y,Y=this._planeQ.vectorV.x,O=this._planeQ.vectorV.y;return this.currentF.setOriginAndVectorsXYZ(E*M+D*b,R*M+X*b,0,z*M+N*b+E*E+D*D,R*E+X*D,0,-(E*R+D*X),Y*M+O*b-R*R-X*X,0),!0}}class te extends Gt{constructor(){super(),this._parentCurvePrimitive=void 0}startParentCurvePrimitive(y){this._parentCurvePrimitive=y}endParentCurvePrimitive(y){this._parentCurvePrimitive=void 0}}class ee extends te{effectiveCurve(){return this._parentCurvePrimitive?this._parentCurvePrimitive:this._curve}get getDerivativeB(){return this._derivativeB}constructor(y,k){super(),this._fractionA=0,this._functionA=0,this._functionB=0,this._fractionB=0,this._derivativeB=0,this._numThisCurve=0,this._plane=y,this._intersections=k,this.startCurvePrimitive(void 0),this._ray=bt.createZero(),this._newtonSolver=new Ht(this)}startCurvePrimitive(y){this._curve=y,this._fractionA=0,this._numThisCurve=0,this._functionA=0}endCurvePrimitive(){}announceIntervalForUniformStepStrokes(y,k,M,b){this.startCurvePrimitive(y),k<1&&(k=1);const E=1/k;for(let D=0;D<=k;D++){const k=Q.interpolate(M,D*E,b);y.fractionToPointAndDerivative(k,this._ray),this.announcePointTangent(this._ray.origin,k,this._ray.direction)}}announceSegmentInterval(y,k,M,b,E,D){const R=this._plane.altitude(k),X=this._plane.altitude(M);if(R*X>0)return;const z=Ut.solveCoffs(R,X);if(void 0!==z){const y=Q.interpolate(E,z,D);this._newtonSolver.setX(y),this._newtonSolver.runIterations()&&this.announceSolutionFraction(this._newtonSolver.getX())}}announceSolutionFraction(y){const k=this.effectiveCurve();k&&(this._ray=k.fractionToPointAndDerivative(y,this._ray),this._intersections.push(vt.createCurveFractionPoint(k,y,this._ray.origin)))}evaluate(y){const k=this.effectiveCurve();return!!k&&(this.currentF=this._plane.altitude(k.fractionToPoint(y)),!0)}searchInterval(){if(!(this._functionA*this._functionB>0)&&(0===this._functionA&&this.announceSolutionFraction(this._fractionA),0===this._functionB&&this.announceSolutionFraction(this._fractionB),this._functionA*this._functionB<0)){const y=Q.inverseInterpolate(this._fractionA,this._functionA,this._fractionB,this._functionB);y&&(this._newtonSolver.setX(y),this._newtonSolver.runIterations()&&this.announceSolutionFraction(this._newtonSolver.getX()))}}evaluateB(y,k,M){this._functionB=this._plane.altitude(y),this._derivativeB=this._plane.velocity(M),this._fractionB=k}announcePointTangent(y,k,M){this.evaluateB(y,k,M),this._numThisCurve++>0&&this.searchInterval(),this._functionA=this._functionB,this._fractionA=this._fractionB}}!function(y){y[y.None=0]="None",y[y.OnTangent=1]="OnTangent",y[y.OnCurve=2]="OnCurve"}(U||(U={}));class ie{static resolveVariantCurveExtendParameterToCurveExtendMode(y,k){return!1===y?U.None:!0===y?U.OnCurve:Array.isArray(y)?y.length>k?y[k]:U.None:y}static correctFraction(y,k){return k<0?ie.resolveVariantCurveExtendParameterToCurveExtendMode(y,0)===U.None&&(k=0):k>1&&ie.resolveVariantCurveExtendParameterToCurveExtendMode(y,1)===U.None&&(k=1),k}static resolveRadiansToSweepFraction(y,k,M){let b=M.radiansToSignedPeriodicFraction(k);if(!M.isRadiansInSweep(k)){const E=M.fractionPeriod(),D=ie.resolveVariantCurveExtendParameterToCurveExtendMode(y,0),R=ie.resolveVariantCurveExtendParameterToCurveExtendMode(y,1);D!==U.None?R!==U.None?b=M.radiansToSignedPeriodicFraction(k):b>1&&(b-=E):R!==U.None?b<0&&(b+=E):b=Q.clamp(b,0,1)}return b}}class se extends te{constructor(y,k,M){super(),this._fractionA=0,this._functionA=0,this._functionB=0,this._fractionB=0,this._numThisCurve=0,this._spacePoint=y,this._workPoint=j.create(),this._workRay=bt.createZero(),this._closestPoint=M,this._extend=k,this.startCurvePrimitive(void 0),this._newtonSolver=new Ht(this)}claimResult(){if(this._closestPoint&&(this._newtonSolver.setX(this._closestPoint.fraction),this._curve=this._closestPoint.curve,this._newtonSolver.runIterations())){let y=this._newtonSolver.getX();y=ie.correctFraction(this._extend,y),this.announceSolutionFraction(y)}return this._closestPoint}needPrimaryGeometryForStrokes(){return!0}startCurvePrimitive(y){this._curve=y,this._fractionA=0,this._numThisCurve=0,this._functionA=0}endCurvePrimitive(){}announceIntervalForUniformStepStrokes(y,k,M,b){this.startCurvePrimitive(y),this.announceSolutionFraction(0),this.announceSolutionFraction(1),k<1&&(k=1);const E=1/k;for(let D=0;D<=k;D++){const k=Q.interpolate(M,D*E,b);y.fractionToPointAndDerivative(k,this._workRay),this.announceRay(k,this._workRay)}}announceCandidate(y,k,M){const b=this._spacePoint.distance(M);this._closestPoint&&b>this._closestPoint.a||(this._closestPoint=vt.createCurveFractionPoint(y,k,M,this._closestPoint),this._closestPoint.a=b,void 0!==this._parentCurvePrimitive&&(this._closestPoint.curve=this._parentCurvePrimitive))}announceSegmentInterval(y,k,M,b,E,D){let R=this._spacePoint.fractionOfProjectionToLine(k,M,0);this._extend?(0!==E&&(R=Math.max(R,0)),1!==D&&(R=Math.min(R,1))):R=Q.clampToStartEnd(R,0,1),this._workPoint=k.interpolate(R,M);const X=Q.interpolate(E,R,D);this.announceCandidate(y,X,this._workPoint)}searchInterval(){if(!(this._functionA*this._functionB>0)&&(0===this._functionA&&this.announceSolutionFraction(this._fractionA),0===this._functionB&&this.announceSolutionFraction(this._fractionB),this._functionA*this._functionB<0)){const y=Q.inverseInterpolate(this._fractionA,this._functionA,this._fractionB,this._functionB);y&&(this._newtonSolver.setX(y),this._newtonSolver.runIterations()&&this.announceSolutionFraction(this._newtonSolver.getX()))}}evaluateB(y,k){this._functionB=k.dotProductToPoint(this._spacePoint),this._fractionB=y}announceSolutionFraction(y){this._curve&&this.announceCandidate(this._curve,y,this._curve.fractionToPoint(y))}evaluate(y){let k=this._curve;return this._parentCurvePrimitive&&(k=this._parentCurvePrimitive),!!k&&(this._workRay=k.fractionToPointAndDerivative(y,this._workRay),this.currentF=this._workRay.dotProductToPoint(this._spacePoint),!0)}announceRay(y,k){this.evaluateB(y,k),this._numThisCurve++>0&&this.searchInterval(),this._functionA=this._functionB,this._fractionA=this._fractionB}announcePointTangent(y,k,M){this._workRay.set(y,M),this.announceRay(k,this._workRay)}}class ne{static mapWeights(y,k,M,b,E,D){const R=M.length;for(let X=0;X<R;X++)E[X]=y+k*M[X],D[X]=k*b[X];return R}static setupGauss1(y,k,M,b){return ne.mapWeights(y,k-y,ne.gaussX1Interval01,ne.gaussW1Interval01,M,b)}static setupGauss2(y,k,M,b){return ne.mapWeights(y,k-y,ne.gaussX2Interval01,ne.gaussW2Interval01,M,b)}static setupGauss3(y,k,M,b){return ne.mapWeights(y,k-y,ne.gaussX3Interval01,ne.gaussW3Interval01,M,b)}static setupGauss5(y,k,M,b){return ne.mapWeights(y,k-y,ne.gaussX5Interval01,ne.gaussW5Interval01,M,b)}static setupGauss4(y,k,M,b){return ne.mapWeights(y,k-y,ne.gaussX4Interval01,ne.gaussW4Interval01,M,b)}static sum1(y,k,M,b){let E=0;for(let D=0;D<M;D++)E+=k[D]*b(y[D]);return E}static doGaussIntegral(y,k,M,b,E=5){const D=new re(E);b<1&&(b=1);const R=1/b;let X=0;for(let z=1;z<=b;z++){const E=Q.interpolate(y,(z-1)*R,k),N=z===b?k:Q.interpolate(y,z*R,k),Y=D.mapXAndW(E,N);for(let y=0;y<Y;y++)X+=D.gaussW[y]*M(D.gaussX[y])}return X}}ne.gaussX1Interval01=new Float64Array([.5]),ne.gaussW1Interval01=new Float64Array([1]),ne.gaussX2Interval01=new Float64Array([.21132486540518708,.7886751345948129]),ne.gaussW2Interval01=new Float64Array([.5,.5]),ne.gaussX3Interval01=new Float64Array([.1127016653792583,.5,.8872983346207417]),ne.gaussW3Interval01=new Float64Array([.2777777777777778,.4444444444444444,.2777777777777778]),ne.gaussX4Interval01=new Float64Array([.06943184420297371,.33000947820757187,.6699905217924281,.9305681557970262]),ne.gaussW4Interval01=new Float64Array([.17392742256872692,.3260725774312731,.3260725774312731,.17392742256872692]),ne.gaussX5Interval01=new Float64Array([.04691007703066802,.23076534494715845,.5,.7692346550528415,.9530899229693319]),ne.gaussW5Interval01=new Float64Array([.11846344252809454,.23931433524968324,.28444444444444444,.23931433524968324,.11846344252809454]);class re{mapXAndW(y,k){return this.mapXAndWFunction(y,k,this.gaussX,this.gaussW)}constructor(y){switch(this.gaussX=new Float64Array(7),this.gaussW=new Float64Array(7),(y>5||y<1)&&(y=5),y){case 1:this.mapXAndWFunction=(y,k,M,b)=>ne.setupGauss1(y,k,M,b);break;case 2:this.mapXAndWFunction=(y,k,M,b)=>ne.setupGauss2(y,k,M,b);break;case 3:this.mapXAndWFunction=(y,k,M,b)=>ne.setupGauss3(y,k,M,b);break;case 4:this.mapXAndWFunction=(y,k,M,b)=>ne.setupGauss4(y,k,M,b);break;default:this.mapXAndWFunction=(y,k,M,b)=>ne.setupGauss5(y,k,M,b)}}}class oe{tangentMagnitude(y){return this._ray=this._curve.fractionToPointAndDerivative(y,this._ray),this._ray.direction.magnitude()}get getFraction0(){return this._fraction0}get getFraction1(){return this._fraction1}getSum(){return this._summedLength}constructor(y=0,k=1,M=5){this.startCurvePrimitive(void 0),this._summedLength=0,this._ray=bt.createZero(),y<k?(this._fraction0=y,this._fraction1=k):(this._fraction0=k,this._fraction1=y),this._gaussMapper=new re(M)}startCurvePrimitive(y){this._curve=y}startParentCurvePrimitive(y){}endParentCurvePrimitive(y){}endCurvePrimitive(){}announceIntervalForUniformStepStrokes(y,k,M,b){const E=ft.createXX(M,b);if(E.intersectRangeXXInPlace(this._fraction0,this._fraction1),!E.isNull){this.startCurvePrimitive(y),k<1&&(k=1);const M=1/k;for(let y=1;y<=k;y++){const b=E.fractionToPoint((y-1)*M),D=y===k?E.high:E.fractionToPoint(y*M),R=this._gaussMapper.mapXAndW(b,D);for(let y=0;y<R;y++)this._summedLength+=this._gaussMapper.gaussW[y]*this.tangentMagnitude(this._gaussMapper.gaussX[y])}}}announceSegmentInterval(y,k,M,b,E,D){const R=k.distance(M);if(this._fraction0<=E&&D<=this._fraction1)this._summedLength+=R;else{const y=ft.createXX(E,D);y.intersectRangeXXInPlace(this._fraction0,this._fraction1),y.isNull||(this._summedLength+=R*y.length()/(D-E))}}announcePointTangent(y,k,M){}}class ae extends Ot{constructor(){super(),this.geometryCategory="curvePrimitive"}fractionToPointAndUnitTangent(y,k){const M=this.fractionToPointAndDerivative(y,k);return M.trySetDirectionMagnitudeInPlace(1),M}fractionToCurvature(y){const k=this.fractionToPointAnd2Derivatives(y),M=k.vectorU.crossProduct(k.vectorV).magnitude(),b=k.vectorU.magnitude();return Q.conditionalDivideFraction(M,b*b*b)}fractionToFrenetFrame(y,k){const M=this.fractionToPointAnd2Derivatives(y);if(!M)return;let b=xt.createRigidFromColumns(M.vectorU,M.vectorV,E.XYZ);if(b)return pt.createRefs(M.origin,b,k);const D=xt.createPerpendicularVectorFavorXYPlane(M.vectorU,M.vectorV);return b=xt.createRigidFromColumns(M.vectorU,D,E.XYZ),b?pt.createRefs(M.origin,b,k):void 0}fractionToSignedXYRadiusOfCurvature(y){const k=this.fractionToPointAnd2Derivatives(y);if(!k)return 0;const M=k.vectorU.crossProductXY(k.vectorV),b=k.vectorU.magnitude();if(0===b)return 0;const E=Q.conditionalDivideCoordinate(b*b*b,M);return void 0!==E?E:0}fractionAndDistanceToPointOnTangent(y,k){return this.fractionToPointAndUnitTangent(y).fractionToPoint(k)}curveLength(){const y=new oe;return this.emitStrokableParts(y),y.getSum()}curveLengthBetweenFractions(y,k){if(y===k)return 0;if(void 0!==this.getFractionToDistanceScale()){const M=this.curveLength();return Math.abs((k-y)*M)}const M=new oe(y,k);return this.emitStrokableParts(M),Math.abs(M.getSum())}rangeBetweenFractions(y,k,M){return this.rangeBetweenFractionsByClone(y,k,M)}rangeBetweenFractionsByClone(y,k,M){if(y===k)return ut.create(this.fractionToPoint(y));const b=this.clonePartialCurve(y,k);return b?b.range(M):ut.createNull()}rangeBetweenFractionsByCount(y,k,M,b,E=0){const D=ut.createNull(),R=j.create();D.extendPoint(this.startPoint(R)),D.extendPoint(this.endPoint(R));const a=(y,k,M)=>{let E=y;for(let X=0;X<M;X++,E+=k)this.fractionToPoint(E,R),b?D.extendTransformedPoint(b,R):D.extendPoint(R)},X=M-2;if(X>0){const M=1/(X+1)*(k-y);a(y+M,M,X)}if(E>0){const M=D.clone(),b=X+1,R=.5/b*2*(k-y);a(y+.5*R,R,b),D.extendWhenLarger(M,E)}return D}curveLengthWithFixedIntervalCountQuadrature(y,k,M,b=5){if(y>k){const M=y;y=k,k=M}const E=new oe(y,k,b);return E.announceIntervalForUniformStepStrokes(this,M,y,k),Math.abs(E.getSum())}moveSignedDistanceFromFraction(y,k,M,b){if(void 0!==this.getFractionToDistanceScale()){const E=this.curveLength(),D=Q.conditionalDivideFraction(k,E);return void 0===D?vt.createCurveFractionPointDistanceCurveSearchStatus(this,y,this.fractionToPoint(y),0,B.error):vt.createConditionalMoveSignedDistance(M,this,y,y+D,k,b)}return this.moveSignedDistanceFromFractionGeneric(y,k,M,b)}moveSignedDistanceFromFractionGeneric(y,k,M,b){let E;if(0===k)return vt.createCurveEvaluatedFraction(this,y,b);if(k>0){if(E=1,y>=1){const M=.9;k+=this.curveLengthBetweenFractions(M,y),y=M}}else if(E=0,y<=0){const M=.1;k-=this.curveLengthBetweenFractions(y,M),y=M}const D=this.curveLengthBetweenFractions(y,E);e();const R=Math.abs(k);if(D<R&&!M)return vt.createConditionalMoveSignedDistance(M,this,y,E,k,b);const X=Q.conditionalDivideCoordinate(R,D);if(void 0===X)return(b=vt.createCurveEvaluatedFraction(this,y,b)).curveSearchStatus=B.error,b;const z=k<0?-1:1;let N=Q.interpolate(y,X,E),Y=y,O=0;const V=1e-12*D;let U=0;const L=bt.createXAxis();for(let B=0;B<10;B++){const y=O+(N>Y?z:-z)*this.curveLengthBetweenFractions(Y,N),k=R-y;if(Math.abs(k)<V){if(U++,U>1)break}else U=0;if(this.fractionToPointAndDerivative(N,L),Y=N,N=Y+z*k/L.direction.magnitude(),Y===N){U=100;break}O=y}return U>1?vt.createConditionalMoveSignedDistance(M,this,y,N,k,b):((b=vt.createCurveEvaluatedFraction(this,y,b)).curveSearchStatus=B.error,b)}get isExtensibleFractionSpace(){return!1}closestPoint(y,k,M){const b=new se(y,k,M);return this.emitStrokableParts(b),b.claimResult()}announceClipIntervals(y,k){return!1}clonePartialCurve(y,k){}getFractionToDistanceScale(){}appendPlaneIntersectionPoints(y,k){const M=new ee(y,k),b=k.length;return this.emitStrokableParts(M),k.length-b}static snapAndRestrictDetails(y,k=!0,M=!1,b=Q.smallAngleRadians,E=Q.smallMetricDistance){const D=y.length;let R=0;const X=j.create(),z=j.create();let N;for(let Y=0;Y<D;Y++){N=void 0;const D=y[Y];let B=D.fraction,V=k||Q.isIn01(B);D.curve&&(D.curve.startPoint(X),D.curve.endPoint(z)),b>0&&(Math.abs(B)<b&&(B=0,V=!0,D.intervalRole=O.isolatedAtVertex,N=X),Math.abs(B-1)<b&&(B=1,V=!0,D.intervalRole=O.isolatedAtVertex,N=z,D.curve&&(N=D.curve.startPoint(z)))),E>0&&void 0!==D.curve&&(D.point.distance(X)<=E?(B=0,D.intervalRole=O.isolatedAtVertex,N=X):D.point.distance(z)<=E&&(B=1,D.intervalRole=O.isolatedAtVertex,N=z)),V&&(M&&(D.fraction=B,void 0!==N&&D.point.setFrom(N)),R<Y&&(y[R]=D),R++)}R<D&&(y.length=R)}startPoint(y){return this.fractionToPoint(0,y)}endPoint(y){return this.fractionToPoint(1,y)}computeAndAttachRecursiveStrokeCounts(y,k){const M=this.computeStrokeCountForOptions(y),b=this.curveLength();ae.installStrokeCountMap(this,Nt.createWithCurvePrimitive(this,M,b,0,b),k)}addMappedStrokesToLineString3D(y,k){const M=k.numPoints();if(y.primitive&&y.primitive===this&&y.numStroke>0)for(let b=0;b<=y.numStroke;b++){const M=b/y.numStroke;k.appendFractionToPoint(this,M)}return k.numPoints()-M}static installStrokeCountMap(y,k,M){M&&M.addToCountAndLength(k.numStroke,k.curveLength),y.strokeData=k}collectCurvePrimitivesGo(y,k,M=!1){y.push(this)}collectCurvePrimitives(y,k=!1,M=!1){const b=void 0===y?[]:y;return this.collectCurvePrimitivesGo(b,k,M),b}projectedParameterRange(y,k){}}class ce extends st{constructor(y){super(),this.data=y}isValidIndex(y){return y>=0&&y<this.data.length}getPoint3dAtCheckedPointIndex(y,k){if(this.isValidIndex(y)){const M=this.data[y];return j.create(M.x,M.y,M.z,k)}}getPoint3dAtUncheckedPointIndex(y,k){const M=this.data[y];return j.create(M.x,M.y,M.z,k)}getVector3dAtCheckedVectorIndex(y,k){if(this.isValidIndex(y)){const M=this.data[y];return $.create(M.x,M.y,M.z,k)}}getXAtUncheckedPointIndex(y){return this.data[y].x}getYAtUncheckedPointIndex(y){return this.data[y].y}getZAtUncheckedPointIndex(y){return this.data[y].z}vectorIndexIndex(y,k,M){if(this.isValidIndex(y)&&this.isValidIndex(k))return $.createStartEnd(this.data[y],this.data[k],M)}vectorXYAndZIndex(y,k,M){if(this.isValidIndex(k))return $.createStartEnd(y,this.data[k],M)}crossProductXYAndZIndexIndex(y,k,M,b){if(this.isValidIndex(k)&&this.isValidIndex(M))return $.createCrossProductToPoints(y,this.data[k],this.data[M],b)}crossProductIndexIndexIndex(y,k,M,b){if(this.isValidIndex(y)&&this.isValidIndex(k)&&this.isValidIndex(M))return $.createCrossProductToPoints(this.data[y],this.data[k],this.data[M],b)}accumulateCrossProductIndexIndexIndex(y,k,M,b){const E=this.data;this.isValidIndex(y)&&this.isValidIndex(k)&&this.isValidIndex(M)&&b.addCrossProductToTargetsInPlace(E[y].x,E[y].y,E[y].z,E[k].x,E[k].y,E[k].z,E[M].x,E[M].y,E[M].z)}accumulateScaledXYZ(y,k,M){if(this.isValidIndex(y)){const b=this.data[y];M.x+=k*b.x,M.y+=k*b.y,M.z+=k*b.z}}get length(){return this.data.length}push(y){this.data.push(y.clone())}pushXYZ(y,k,M){this.data.push(j.create(void 0===y?0:y,void 0===k?0:k,void 0===M?0:M))}back(y){if(this.data.length>0)return this.data[this.data.length-1].clone(y)}front(y){if(this.data.length>0)return this.data[0].clone(y)}pop(){this.data.length>0&&this.data.pop()}clear(){this.data.length=0}reverseInPlace(){this.data.reverse()}distanceSquaredIndexIndex(y,k){const M=this.data.length;if(y>=0&&y<M&&k>=0&&k<M)return this.data[y].distanceSquared(this.data[k])}distanceIndexIndex(y,k){const M=this.data.length;if(y>=0&&y<M&&k>=0&&k<M)return this.data[y].distance(this.data[k])}cyclicIndex(y){return y%this.data.length}}function le(y,k,M){if(void 0!==k){const b=k*M;if(b>=0&&b<=y)return b}return y}class he{static preciseSum(y){const k=y.length;if(0===k)return 0;let M,b,E=y[0],D=0;for(let R=1;R<k;R++)M=y[R]-D,b=E+M,D=b-E-M,E=b;return E}static isExactEqual(y,k){if(y&&k){if(y.length!==k.length)return!1;for(let M=0;M<y.length;M++)if(y[M]!==k[M])return!1;return!0}return void 0===y&&void 0===k}static isAlmostEqual(y,k,M=Q.smallMetricDistance){if(y&&k){if(y.length!==k.length)return!1;for(let b=0;b<y.length;b++)if(Math.abs(y[b]-k[b])>M)return!1;return!0}return void 0===y&&void 0===k}static sum(y){let k=0;for(const M of y)k+=M;return k}static isCoordinateInArray(y,k){if(k)for(const M of k)if(Q.isSameCoordinate(y,M))return!0;return!1}static maxAbsArray(y){const k=y.length;if(0===k)return 0;let M=Math.abs(y[0]);for(let b=1;b<k;b++){const k=Math.abs(y[b]);M<k&&(M=k)}return M}static maxAbsTwo(y,k){return(y=Math.abs(y))>(k=Math.abs(k))?y:k}static maxAbsDiff(y,k){let M=0;const b=Math.min(y.length,k.length);for(let E=0;E<b;E++)M=Math.max(M,Math.abs(y[E]-k[E]));return M}static maxAbsDiffFloat64(y,k){let M=0;const b=Math.min(y.length,k.length);for(let E=0;E<b;E++)M=Math.max(M,Math.abs(y[E]-k[E]));return M}static createArrayWithMaxStepSize(y,k,M){if(y===k)return[y];const b=k-y,E=Math.max(1,Math.floor(Math.abs(b/M))),D=[];D.push(y);for(let R=1;R<E;R++)D.push(y+R/E*b);return D.push(k),D}static create(y){const k=[];for(const M of y)k.push(M);return k}static copy2d(y){const k=[];for(const M of y){const y=[];for(const k of M)y.push(k);k.push(y)}return k}static copy3d(y){const k=[];for(const M of y){const y=[];for(const k of M){const M=[];for(const y of k)M.push(y);y.push(M)}k.push(y)}return k}static unpack2d(y,k){if(!(k<1))return ue.unpackNumbersToNestedArrays(y,k)}static unpack3d(y,k,M){if(!(M<1||k<1))return ue.unpackNumbersToNestedArraysIJK(y,M,k)}static pack(y){const k=y.length;let M=0,b=0,E=0;k>0&&(E=k,Array.isArray(y[0])&&(M=y[0].length,M>0&&(E*=M,Array.isArray(y[0][0])&&(b=y[0][0].length,b>0&&(E*=b)))));const D=new Float64Array(E);if(b>0){const E=y;for(let y=0,R=0;y<k;++y)for(let k=0;k<M;++k)for(let M=0;M<b;++M)D[R++]=E[y][k][M]}else if(M>0){const b=y;for(let y=0,E=0;y<k;++y)for(let k=0;k<M;++k)D[E++]=b[y][k]}else if(k>0){const M=y;for(let y=0,b=0;y<k;++y)D[b++]=M[y]}return D}static cloneWithStartAndEndMultiplicity(y,k,M){const b=[];if(void 0===y||0===y.length)return b;let E=1;const D=y[0],R=y[y.length-1];for(;E<y.length&&y[E]===D;)E++;let X=1;const z=y.length-1;for(;z-X>=0&&y[z-X]===R;)X++;for(let N=0;N<k;N++)b.push(D);for(let N=E;N+X<y.length;N++)b.push(y[N]);for(let N=0;N<M;N++)b.push(R);return b}static linearCombination(y,k){const M=Math.min(y.length,k.length);let b=0;for(let E=0;E<M;++E)b+=k[E]*y[E];return b}static linearCombinationOfColors(y,k){const M=Math.min(y.length,k.length),b=[0,0,0,0];for(let E=0,D=0;E<4;++E,D+=8){for(let R=0;R<M;++R){const M=Q.clamp(k[R],0,1),X=y[R]>>>D&255;b[E]+=M*X}b[E]=(255&Math.floor(b[E]))<<D}return b[0]|b[1]|b[2]|b[3]}}class de{static packPointsAndWeightsToFloat64Array(y,k,M){let b;if(Array.isArray(y)&&y[0]instanceof j){if(b=y,b.length!==k.length)return;const E=4*b.length;(!M||M.length<E)&&(M=new Float64Array(E));for(let y=0,D=0;D<b.length;D++)M[y++]=b[D].x,M[y++]=b[D].y,M[y++]=b[D].z,M[y++]=k[D];return M}b=y;const E=k.length;if(b.length!==3*E)return;const D=4*E;(!M||M.length<D)&&(M=new Float64Array(D));for(let R=0,X=0;X<E;X++){const y=3*X;M[R++]=b[y],M[R++]=b[y+1],M[R++]=b[y+2],M[R++]=k[X]}return M}static packToFloat64Array(y,k){const M=4*y.length;(!k||k.length<M)&&(k=new Float64Array(M));let b=0;for(const E of y)k[b++]=E.x,k[b++]=E.y,k[b++]=E.z,k[b++]=E.w;return k}static unpackToPoint4dArray(y){const k=[];for(let M=0;M+3<y.length;M+=4)k.push(Dt.create(y[M],y[M+1],y[M+2],y[M+3]));return k}static unpackFloat64ArrayToPointsAndWeights(y,k,M,b=(y,k,M)=>j.create(y,k,M)){k.length=0,M.length=0;for(let E=0;E+3<y.length;E+=4)k.push(b(y[E],y[E+1],y[E+2])),M.push(y[E+3])}static multiplyInPlace(y,k){const M=k.length,b=de._workPoint4d;for(let E=0;E+3<M;E+=4)y.multiplyXYZW(k[E],k[E+1],k[E+2],k[E+3],b),k[E]=b.x,k[E+1]=b.y,k[E+2]=b.z,k[E+3]=b.w}static isAlmostEqual(y,k){if(y&&k){if(y instanceof Float64Array&&k instanceof Float64Array){if(y.length!==k.length)return!1;for(let M=0;M<y.length;M++)if(!Q.isSameCoordinate(y[M],k[M]))return!1}else if(Array.isArray(y)&&Array.isArray(k)){if(y.length!==k.length)return!1;for(let M=0;M<y.length;M++)if(!y[M].isAlmostEqual(k[M]))return!1}else{const M=y instanceof Float64Array?k:y,b=y instanceof Float64Array?y:k;if(b.length!==4*M.length)return!1;for(let y=0;y<M.length;++y)if(!(Q.isSameCoordinate(M[y].x,b[4*y])&&Q.isSameCoordinate(M[y].y,b[4*y+1])&&Q.isSameCoordinate(M[y].z,b[4*y+2])&&Q.isSameCoordinate(M[y].w,b[4*y+3])))return!1}return!0}return void 0===y&&void 0===k}static isCloseToPlane(y,k,M=Q.smallMetricDistance){if(Array.isArray(y)){for(const b of y)if(Math.abs(k.altitudeXYZW(b.x,b.y,b.z,b.w))>M)return!1}else if(y instanceof Float64Array){const b=y.length;for(let E=0;E+2<b;E+=4)if(Math.abs(k.altitudeXYZW(y[E],y[E+1],y[E+2],y[E+3]))>M)return!1}return!0}}de._workPoint4d=Dt.create();class ue{static packToFloat64Array(y,k){const M=3*y.length;(!k||k.length<M)&&(k=new Float64Array(M));let b=0;for(const E of y)k[b++]=E.x,k[b++]=E.y,k[b++]=E.z;return k}static packToNumberArray(y,k){const M=3*y.length;k||(k=Array(M)),k.length=M;let b=0;for(const E of y)k[b++]=E.x,k[b++]=E.y,k[b++]=E.z;return k}static evaluateTrilinearWeights(y,k,M,b,E,D,R){y[0]=k*b*D,y[1]=M*b*D,y[2]=k*E*D,y[3]=M*E*D,y[4]=k*b*R,y[5]=M*b*R,y[6]=k*E*R,y[7]=M*E*R}static sumWeightedX(y,k){let M=0;const b=y.length;for(let E=0;E<b;E++)M+=y[E]*k[E].x;return M}static sumWeightedY(y,k){let M=0;const b=y.length;for(let E=0;E<b;E++)M+=y[E]*k[E].y;return M}static sumWeightedZ(y,k){let M=0;const b=y.length;for(let E=0;E<b;E++)M+=y[E]*k[E].z;return M}static evaluateTrilinearPoint(y,k,M,b,E){let D;E||(E=j.create(0,0,0)),this.evaluateTrilinearWeights(this._weightUVW,1-k,k,1-M,M,1-b,b);for(let R=0;R<8;R++)D=this._weightUVW[R],E.x+=D*y[R].x,E.y+=D*y[R].y,E.z+=D*y[R].z;return E}static evaluateTrilinearDerivativeTransform(y,k,M,b,E){return this.evaluateTrilinearWeights(this._weightUVW,1-k,k,1-M,M,1-b,b),this.evaluateTrilinearWeights(this._weightDU,-1,1,1-M,M,1-b,b),this.evaluateTrilinearWeights(this._weightDV,1-k,k,-1,1,1-b,b),this.evaluateTrilinearWeights(this._weightDW,1-k,k,1-M,M,-1,1),pt.createRowValues(this.sumWeightedX(this._weightDU,y),this.sumWeightedX(this._weightDV,y),this.sumWeightedX(this._weightDW,y),this.sumWeightedX(this._weightUVW,y),this.sumWeightedY(this._weightDU,y),this.sumWeightedY(this._weightDV,y),this.sumWeightedY(this._weightDW,y),this.sumWeightedY(this._weightUVW,y),this.sumWeightedZ(this._weightDU,y),this.sumWeightedZ(this._weightDV,y),this.sumWeightedZ(this._weightDW,y),this.sumWeightedZ(this._weightUVW,y),E)}static unpackNumbersToPoint3dArray(y){const k=[];for(let M=0;M+2<y.length;M+=3)k.push(j.create(y[M],y[M+1],y[M+2]));return k}static unpackNumbersToNestedArrays(y,k){const M=[],b=y.length;let E=0,D=0;for(;E<b;){const R=[];for(D=E+k,D>b&&(D=b);E<D;E++)R.push(y[E]);M.push(R)}return M}static unpackNumbersToNestedArraysIJK(y,k,M){const b=[],E=y.length;let D,R=0,X=0;for(;R<E;){const z=[];for(D=R+k*M;R<D;){const M=[];for(X=R+k,X>E&&(X=E);R<X;R++)M.push(y[R]);z.push(M)}b.push(z)}return b}static multiplyInPlace(y,k){const M=j.create(),b=k.length;for(let E=0;E+2<b;E+=3)y.multiplyXYZ(k[E],k[E+1],k[E+2],M),k[E]=M.x,k[E+1]=M.y,k[E+2]=M.z}static isAlmostEqual(y,k){if(y&&k){if(y instanceof Float64Array&&k instanceof Float64Array){if(y.length!==k.length)return!1;for(let M=0;M<y.length;M++)if(!Q.isSameCoordinate(y[M],k[M]))return!1}else if(Array.isArray(y)&&Array.isArray(k)){if(y.length!==k.length)return!1;for(let M=0;M<y.length;M++)if(!y[M].isAlmostEqual(k[M]))return!1}else{const M=y instanceof Float64Array?k:y,b=y instanceof Float64Array?y:k;if(b.length!==3*M.length)return!1;for(let y=0;y<M.length;++y)if(!Q.isSameCoordinate(M[y].x,b[3*y])||!Q.isSameCoordinate(M[y].y,b[3*y+1])||!Q.isSameCoordinate(M[y].z,b[3*y+2]))return!1}return!0}return void 0===y&&void 0===k}static centroid(y,k){if(y instanceof it){k=j.create(0,0,0,k);const M=j.create();if(y.length>0){for(let b=0;b<y.length;b++)y.getPoint3dAtCheckedPointIndex(b,M),k.x+=M.x,k.y+=M.y,k.z+=M.z;k.scaleInPlace(1/y.length)}return k}const M=new ce(y);return this.centroid(M)}static indexOfMostDistantPoint(y,k,M){if(0===y.length)return;let b,E=-1,D=-1;for(let R=0;R<y.length;R++)b=k.distance(y[R]),b>E&&(k.vectorTo(y[R],M),E=b,D=R);return D}static indexOfPointWithMaxCrossProductMagnitude(y,k,M,b){if(0===y.length)return;let E,D,R=-1,X=-1;for(let z=0;z<y.length;z++)D=k.vectorTo(y[z],D),E=D.crossProductMagnitude(M),E>R&&(b.setFrom(D),R=E,X=z);return X}static closestPointIndex(y,k){let M,b=-1,E=Number.MAX_VALUE;const D=k.x,R=k.y,X=k.z;for(let z=0;z<y.length;z++)M=Q.distanceXYZXYZ(D,R,X,y[z].x,y[z].y,y[z].z),M<E&&(b=z,E=M);return b}static isCloseToPlane(y,k,M=Q.smallMetricDistance){if(Array.isArray(y)){let b;for(b of y)if(Math.abs(k.altitude(b))>M)return!1}else if(y instanceof Float64Array){const b=y.length;for(let E=0;E+2<b;E+=3)if(Math.abs(k.altitudeXYZ(y[E],y[E+1],y[E+2]))>M)return!1}return!0}static sumEdgeLengths(y,k=!1,M){let b=0;if(Array.isArray(y)){const E=le(y.length,M,1)-1;for(let k=0;k<E;k++)b+=y[k].distance(y[k+1]);k&&E>0&&(b+=y[0].distance(y[E]))}else if(y instanceof Float64Array){const E=le(y.length,M,3);let D=0;for(;D+5<E;D+=3)b+=Q.hypotenuseXYZ(y[D+3]-y[D],y[D+4]-y[D+1],y[D+5]-y[D+2]);k&&D>=3&&(b+=Q.hypotenuseXYZ(y[0]-y[D],y[1]-y[D+1],y[2]-y[D+2]))}return b}static countNonDuplicates(y,k=Q.smallMetricDistance){let M=y.length;for(;M>1&&y[0].isAlmostEqual(y[M-1],k);)M--;for(let b=0;b+1<M;b++)if(y[b].isAlmostEqual(y[b+1],k))return 0;return M}static clonePoint3dArray(y){const k=[];if(0===y.length)return k;if(y instanceof Float64Array){for(let M=0;M+2<y.length;M+=3)k.push(j.create(y[M],y[M+1],y[M+2]));return k}for(const M of y)Array.isArray(M)?k.push(j.create(M[0],M[1],M[2])):k.push(j.create(M.x,M.y,M.z));return k}static clonePoint2dArray(y){return y.map((y=>H.create(y.x,y.y)))}static cloneWithMaxEdgeLength(y,k){if(0===y.length)return[];const M=[y[0]];for(let b=1;b<y.length;b++){const E=y[b-1].distance(y[b]),D=Q.stepCount(k,E,1);for(let k=1;k<D;k++)M.push(y[b-1].interpolate(k/D,y[b]));M.push(y[b])}return M}static xyzToArray(y,k,M){return[y,k,M]}static cloneDeepJSONNumberArrays(y){const k=new lt(((y,k,M)=>this.xyzToArray(y,k,M)));return ht.streamXYZ(y,k),k.claimResult()}static cloneXYZPropsAsNumberArray(y){const k=[];for(const M of y)if(M instanceof j)k.push([M.x,M.y,M.z]);else if(Array.isArray(M)){const y=M.length>0?M[0]:0,b=M.length>1?M[1]:0,E=M.length>2?M[2]:0;k.push([y,b,E])}else{const y=void 0!==M.x?M.x:0,b=void 0!==M.y?M.y:0,E=void 0!==M.z?M.z:0;k.push([y,b,E])}return k}static cloneXYZPropsAsFloat64Array(y){const k=new Float64Array(3*y.length);let M=0;for(const b of y)b instanceof j?(k[M++]=b.x,k[M++]=b.y,k[M++]=b.z):Array.isArray(b)?(k[M++]=b.length>0?b[0]:0,k[M++]=b.length>1?b[1]:0,k[M++]=b.length>2?b[2]:0):(k[M++]=void 0!==b.x?b.x:0,k[M++]=void 0!==b.y?b.y:0,k[M++]=void 0!==b.z?b.z:0);return k}static cloneDeepXYZPoint3dArrays(y){const k=new lt(((y,k,M)=>j.create(y,k,M)));return ht.streamXYZ(y,k),k.claimResult()}static distanceIndexedPointBToSegmentAC(y,k,M,b,E){const D=$.createStartEnd(y[k],y[b]),R=$.createStartEnd(y[k],y[M]),X=D.dotProduct(D),z=D.dotProduct(R),N=Q.conditionalDivideFraction(z,X);if(void 0===N)return R.magnitude();if(!E){if(N>1)return y[M].distance(y[b]);if(N<0)return R.magnitude()}const Y=R.magnitudeSquared()-N*N*X;return Y<=0?0:Math.sqrt(Y)}static computeConvexHullXY(y,k,M,b=!1){k.length=0,M.length=0;let E=y.length;const D=y.slice(0,E);if(D.sort(((y,k)=>Q.lexicalXYLessThan(y,k))),E<3){for(const y of D)k.push(y);return void(b&&D.length>0&&k.push(D[0]))}k.push(D[0]),k.push(D[1]);let R=0;for(let z=2;z<E;z++){const y=D[z];let M=k.length-1;for(;M>=1&&k[M-1].crossProductToPointsXY(k[M],y)<=0;)D[R++]=k[M],M--,k.pop();k.push(y)}const X=k.length-1;D.length=R,D.push(k[0]),D.sort(((y,k)=>Q.lexicalXYLessThan(y,k))),E=D.length,k.push(D[E-1]);for(let z=E-1;z-- >0;){const y=D[z];let b=k.length-1;for(;b>X&&k[b-1].crossProductToPointsXY(k[b],y)<=0;)M.push(k[b]),b--,k.pop();z>0&&k.push(y)}b&&k.push(k[0])}static minMaxPoints(y){if(0===y.length)return;const k={minXPoint:y[0].clone(),maxXPoint:y[0].clone(),minYPoint:y[0].clone(),maxYPoint:y[0].clone()};let M;for(let b=1;b<y.length;b++)M=y[b],M.x<k.minXPoint.x&&k.minXPoint.setFromPoint3d(M),M.x>k.maxXPoint.x&&k.maxXPoint.setFromPoint3d(M),M.y<k.minYPoint.y&&k.minYPoint.setFromPoint3d(M),M.y>k.maxYPoint.y&&k.maxYPoint.setFromPoint3d(M);return k}}ue._weightUVW=new Float64Array(8),ue._weightDU=new Float64Array(8),ue._weightDV=new Float64Array(8),ue._weightDW=new Float64Array(8);class fe{static decomposeLU(y,k,M){const b=y-1,E=Math.floor(k/2);let D;for(let R=0;R<=b;R++){const y=Math.min(b,R+E);for(let b=R;b<=y;b++){D=0;for(let y=Math.max(0,b-E);y<R;y++)D+=M[R*k+y-R+E]*M[y*k+b-y+E];M[R*k+b-R+E]-=D}for(let b=R+1;b<=y;b++){D=0;for(let y=Math.max(0,b-E);y<R;y++)D+=M[b*k+y-b+E]*M[y*k+R-y+E];if(Math.abs(M[R*k+E])<1e-9)return!1;M[b*k+R-b+E]=(M[b*k+R-b+E]-D)/M[R*k+E]}}return!0}static arrayAddScaledBlock(y,k,M,b){const E=y.length;let D=E*M;for(let R=0;R<E;R++,D++)y[R]+=k[D]*b}static blockAssignBlockMinusArray(y,k,M,b,E){const D=E.length;let R=k*D,X=b*D;for(let z=0;z<D;z++,X++,R++)y[R]=M[X]-E[z]}static blockSumOfScaledBlockScaledArray(y,k,M,b,E,D,R){const X=D.length;let z=k*X,N=b*X;for(let Y=0;Y<X;Y++,N++,z++)y[z]=M[N]*E+D[Y]*R}static solveBandedSystemMultipleRHS(y,k,M,b,E){if(!this.decomposeLU(y,k,M))return;const D=y-1,R=Math.floor(k/2),X=new Float64Array(b),z=new Float64Array(b*y),N=new Float64Array(b*y);for(let Y=0;Y<=D;Y++){X.fill(0);for(let y=Math.max(0,Y-R);y<Y;y++)this.arrayAddScaledBlock(X,z,y,M[Y*k+y-Y+R]);this.blockAssignBlockMinusArray(z,Y,E,Y,X)}for(let Y=D;Y>=0;Y--){const y=Q.conditionalDivideCoordinate(1,M[Y*k+R]);if(void 0===y)return;X.fill(0);const b=Math.min(D,Y+R);for(let E=Y+1;E<=b;E++)this.arrayAddScaledBlock(X,N,E,M[Y*k+E-Y+R]);this.blockSumOfScaledBlockScaledArray(N,Y,z,Y,y,X,-y)}return N}static multiplyBandedTimesFull(y,k,M,b,E){const D=new Float64Array(E.length),R=Math.floor(k/2);let X,z,N,Y;for(let O=0;O<y;O++){z=O-R,z<0&&(z=0),N=O+R+1,N>y&&(N=y),Y=R+O*(k-1);for(let y=0;y<b;y++){X=0;for(let k=z;k<N;k++)X+=M[Y+k]*E[k*b+y];D[O*b+y]=X}}return D}}!function(y){y[y.None=0]="None",y[y.OpenByAddingControlPoints=1]="OpenByAddingControlPoints",y[y.OpenByRemovingKnots=2]="OpenByRemovingKnots"}(L||(L={}));class ge{get leftKnot(){return this._knot0}get rightKnot(){return this._knot1}get leftKnotIndex(){return this.degree-1}get rightKnotIndex(){return this.knots.length-this.degree}get wrappable(){return void 0===this._wrapMode?L.None:this._wrapMode}set wrappable(y){this._wrapMode=y}get numSpans(){return this.rightKnotIndex-this.leftKnotIndex}constructor(y,k,M){this.degree=k,this._wrapMode=M,this._knot0=0,this._knot1=1,Array.isArray(y)?(this.knots=new Float64Array(y.length),this.setKnots(y),this.setupFixedValues()):y instanceof Float64Array?(this.knots=y.slice(),this.setupFixedValues()):this.knots=new Float64Array(y)}clone(){return new ge(this.knots,this.degree,this.wrappable)}setupFixedValues(){this.degree>0&&this.knots.length>this.degree&&(this._knot0=this.knots[this.degree-1],this._knot1=this.knots[this.knots.length-this.degree])}get knotLength01(){return this._knot1-this._knot0}testClosable(y){void 0===y&&(y=this.wrappable);const k=this.degree,M=this.leftKnotIndex,b=this.rightKnotIndex;if(y===L.OpenByAddingControlPoints){const y=this.rightKnot-this.leftKnot,E=b-M;for(let b=0;b<M+k;b++){const k=b+E;if(Math.abs(this.knots[b]+y-this.knots[k])>=ge.knotTolerance)return!1}return!0}if(y===L.OpenByRemovingKnots){const y=k-1,E=this.leftKnot,D=this.rightKnot;for(let k=0;k<y;k++){if(Math.abs(E-this.knots[M-k-1])>=ge.knotTolerance)return!1;if(Math.abs(D-this.knots[b+k+1])>=ge.knotTolerance)return!1}return!0}return!1}isAlmostEqual(y){return this.degree===y.degree&&he.isAlmostEqual(this.knots,y.knots,ge.knotTolerance)}getKnotMultiplicity(y){let k=0;for(const M of this.knots)if(Math.abs(M-y)<ge.knotTolerance)++k;else if(y<M)break;return k}getKnotMultiplicityAtIndex(y){let k=0;if(y>=0&&y<this.knots.length){const M=this.knots[y];++k;for(let b=y-1;b>=0;--b){const y=this.knots[b];if(Math.abs(y-M)<ge.knotTolerance)++k;else if(M>y)break}for(let b=y+1;b<this.knots.length;++b){const y=this.knots[b];if(Math.abs(y-M)<ge.knotTolerance)++k;else if(M<y)break}}return k}normalize(){if(this.knotLength01<ge.knotTolerance)return!1;const y=1/this.knotLength01,k=this.leftKnot;for(let M=0;M<this.knots.length;++M)this.knots[M]=(this.knots[M]-k)*y;for(let M=this.rightKnotIndex-1;M>this.leftKnotIndex&&this.knots[M]===this.knots[this.rightKnotIndex];--M)this.knots[M]=1;for(let M=this.rightKnotIndex+1;M<this.knots.length&&this.knots[M]===this.knots[this.rightKnotIndex];++M)this.knots[M]=1;return this.knots[this.rightKnotIndex]=1,this.setupFixedValues(),!0}setKnots(y,k){const M=k?y.length-2:y.length;if(M!==this.knots.length&&(this.knots=new Float64Array(M)),k)for(let b=1;b+1<y.length;b++)this.knots[b-1]=y[b];else for(let b=0;b<y.length;b++)this.knots[b]=y[b];this.setupFixedValues()}setKnotsCapture(y){this.knots=y,this.setupFixedValues()}static createUniformClamped(y,k,M,b){const E=new ge(y+k-1,k);let D=0;for(let X=0;X<k;X++)E.knots[D++]=M;const R=1/(y-k);for(let X=1;X+k<y;X++)E.knots[D++]=M+X*R*(b-M);for(let X=0;X<k;X++)E.knots[D++]=b;return E.setupFixedValues(),E}static createUniformWrapped(y,k,M,b){const E=new ge(y+2*k-1,k),D=1/y;for(let R=1-k,X=0;R<y+k;R++,X++)E.knots[X]=Q.interpolate(M,R*D,b);return E.setupFixedValues(),E}static create(y,k,M){const b=M?y.length-2:y.length,E=new ge(b,k);return E.setKnots(y,M),E}grevilleKnot(y){if(y<0)return this.leftKnot;if(y>this.rightKnotIndex)return this.rightKnot;let k=0;for(let M=y;M<y+this.degree;M++)k+=this.knots[M];return k/this.degree}createBasisArray(){return new Float64Array(this.degree+1)}baseKnotFractionToKnot(y,k){const M=this.knots[y];return M+(k=Q.clamp(k,0,1))*(this.knots[y+1]-M)}spanFractionToKnot(y,k){const M=this.spanIndexToLeftKnotIndex(y);return k=Q.clamp(k,0,1),this.knots[M]+k*(this.knots[M+1]-this.knots[M])}spanFractionToFraction(y,k){return(this.spanFractionToKnot(y,k)-this.leftKnot)/(this.rightKnot-this.leftKnot)}fractionToKnot(y){return y=Q.clamp(y,0,1),Q.interpolate(this.knots[this.degree-1],y,this.knots[this.knots.length-this.degree])}evaluateBasisFunctions(y,k,M){if(M.length<this.degree+1)return!1;if(M[0]=1,this.degree<1)return!0;const b=this.knots[y],E=this.knots[y+1];if(M[1]=(k-b)/(E-b),M[0]=1-M[1],this.degree<2)return!0;for(let D=1;D<this.degree;D++){let b=y-D,E=b+D+1,R=0;for(let y=0;y<=D;y++){const D=this.knots[b++],X=(k-D)/(this.knots[E++]-D),z=M[y]*X,N=M[y]*(1-X);M[y]=R+N,R=z}M[D+1]=R}return!0}evaluateBasisFunctions1(y,k,M,b,E){if(M.length<this.degree+1)return!1;if(b.length<this.degree+1)return!1;if(E&&E.length<this.degree+1)return!1;if(M[0]=1,b[0]=0,this.degree<1)return!0;const D=this.knots[y];let R=1/(this.knots[y+1]-D);if(M[1]=(k-D)*R,M[0]=1-M[1],b[0]=-R,b[1]=R,E&&(E[0]=0,E[1]=0),this.degree<2)return!0;for(let X=1;X<this.degree;X++){let D=y-X,z=D+X+1,N=0,Y=0,O=0;for(let y=0;y<=X;y++){const X=this.knots[D++];R=1/(this.knots[z++]-X);const B=(k-X)*R,V=1-B,U=M[y]*B,L=M[y]*V,Z=b[y]*B+M[y]*R,q=b[y]*V-M[y]*R,jr=2*b[y]*R;if(M[y]=N+L,b[y]=Y+q,N=U,Y=Z,E){const k=E[y]*B+jr,M=E[y]*V-jr;E[y]=O+M,O=k}}M[X+1]=N,b[X+1]=Y,E&&(E[X+1]=O)}return!0}knotToLeftKnotIndex(y){for(let k=this.leftKnotIndex;k<this.rightKnotIndex;++k)if(y<this.knots[k+1])return k;for(let k=this.rightKnotIndex;k>this.leftKnotIndex;--k)if(this.knots[k]-this.knots[k-1]>=ge.knotTolerance)return k-1;return this.rightKnotIndex-1}spanIndexToLeftKnotIndex(y){const k=this.degree;return y<=0?k-1:Math.min(y+k-1,this.knots.length-k-1)}spanIndexToSpanLength(y){const k=this.spanIndexToLeftKnotIndex(y);return this.knots[k+1]-this.knots[k]}isIndexOfRealSpan(y){return y>=0&&y<this.numSpans&&!Q.isSmallMetricDistance(this.spanIndexToSpanLength(y))}reflectKnots(){const y=this.leftKnot,k=this.rightKnot,M=this.knots.length;for(let b=0;b<M;b++)this.knots[b]=y+(k-this.knots[b]);this.knots.reverse()}static copyKnots(y,k,M,b){const E=M&&b===L.OpenByAddingControlPoints,D=k-1,R=y.length-k,X=y[D],z=y[R]-X,N=[];M&&(E?N.push(y[R-k]-z):N.push(y[0]));for(const Y of y)N.push(Y);return M&&(E?N.push(y[D+k]+z):N.push(y[y.length-1])),N}copyKnots(y){const k=y&&this.testClosable()?this.wrappable:void 0;return ge.copyKnots(this.knots,this.degree,y,k)}}ge.knotTolerance=1e-9;class pe{static createThroughPoints(y,k){const M=y.length;if(k>M||k<2)return;const b=k-1,E=1+2*b,D=new Float64Array(E*M),R=new Float64Array(k),X=new nt,z=ge.createUniformClamped(M,k-1,0,1),N=j.create();for(let O=0;O<M;O++){const Y=z.grevilleKnot(O),B=z.knotToLeftKnotIndex(Y);z.evaluateBasisFunctions(B,Y,R);let V=0;for(let y=1;y<k;y++)R[y]>R[V]&&(V=y);const U=b-V,L=O*E;for(let y=0;y<k;y++){const k=O-b+U+y;L+k>=0&&k<M&&(D[L+U+y]=R[y])}y instanceof it?X.push(y.getPoint3dAtUncheckedPointIndex(O,N)):X.push(y[O].clone())}const Y=fe.solveBandedSystemMultipleRHS(M,E,D,3,X.float64Data());return Y?Be.create(Y,z.knots,k):void 0}static createThroughPointsC2Cubic(y){const k=y.clone();if(!this.C2CubicFit.validateOptions(k))return;const M=this.C2CubicFit.constructPoles(k);if(void 0===M)return;const b=this.C2CubicFit.convertFitParamsToCubicKnotVector(k.knots,k.closed);if(void 0===b)return;const E=Be.create(M,b,k.order);return k.closed&&E?.setWrappable(L.OpenByAddingControlPoints),E}}!function(y){y.C2CubicFit=class{static normalizeKnots(y){if(void 0===y||y.length<2)return y=void 0,!1;const k=ge.create(y,1,!1);if(!k.normalize())return y=void 0,!1;for(let M=0;M<y.length;++M)y[M]=k.knots[M];return!0}static constructChordLengthParameters(y){if(y.length<2)return;const k=[0];for(let M=1;M<y.length;++M)k[M]=k[M-1]+y[M].distance(y[M-1]);return this.normalizeKnots(k)?k:void 0}static constructUniformParameters(y){if(y<2)return;const k=ge.createUniformClamped(y+2,3,0,1),M=[];for(let b=k.leftKnotIndex;b<=k.rightKnotIndex;++b)M.push(k.knots[b]);return M}static removeDuplicateFitPoints(y){void 0!==y.knots&&y.knots.length!==y.fitPoints.length&&(y.knots=void 0);const k=nt.create(y.fitPoints),M=k.findOrderedDuplicates();k.clear();for(let b=0,E=0;b<y.fitPoints.length;++b)b===M[E]?++E:k.push(y.fitPoints[b].clone());if(y.fitPoints=k.getPoint3dArray(),void 0!==y.knots){const k=[];for(let b=0,E=0;b<y.knots.length;++b)b===M[E]?++E:k.push(y.knots[b]);y.knots=k.slice()}return!0}static constructFitParametersFromPoints(y,k,M){let b;return!k&&M||(b=this.constructChordLengthParameters(y)),void 0===b&&(b=this.constructUniformParameters(y.length)),b}static constructFitParameters(y){return void 0===y.knots&&(y.knots=this.constructFitParametersFromPoints(y.fitPoints,y.isChordLenKnots,y.closed)),y.knots?.length===y.fitPoints.length}static computeAlphaBetaGamma(y,k,M,b,E,D,R,X){let z=1/(X+R+D);y[b]=D*D*z,k[b]=D*(X+R)*z,z=1/(R+D+E),k[b]+=R*(D+E)*z,M[b]=R*R*z,z=1/(R+D),y[b]*=z,k[b]*=z,M[b]*=z}static setUpSystem2Points(y,k,M){return 2===y.length&&2===k.length&&2===M.length&&(y[0]=y[1]=M[0]=M[1]=0,k[0]=k[1]=1,!0)}static setUpSystem3Points(y,k,M,b,E,D){if(void 0===b.knots)return!1;if(3!==y.length||3!==k.length||3!==M.length)return!1;if(3!==b.knots.length||3!==b.fitPoints.length)return!1;let R=0,X=0,z=0,N=0,Y=0,O=0;return E?(y[0]=0,X=b.knots[1]-b.knots[0],R=b.knots[2]-b.knots[1],Y=X+R,O=1/Y,k[0]=(X+Y)*O,M[0]=-X*O):(y[0]=M[0]=0,k[0]=1),z=b.knots[1]-b.knots[0],X=b.knots[2]-b.knots[1],O=1/(z+X),O*=O,y[1]=X*X*O,k[1]=X*z*2*O,M[1]=z*z*O,D?(z=b.knots[2]-b.knots[1],N=b.knots[1]-b.knots[0],Y=N+z,O=1/Y,y[2]=-z*O,k[2]=(z+Y)*O,M[2]=0):(y[2]=M[2]=0,k[2]=1),!0}static setUpSystem4PointsOrMore(y,k,M,b,E,D){if(void 0===b.knots)return!1;if(y.length!==k.length||y.length!==M.length||y.length!==b.knots.length)return!1;if(b.knots.length!==b.fitPoints.length)return!1;const R=b.fitPoints.length-1,X=R-1;let z=0,N=0,Y=0,O=0,B=0,V=0;b.closed?(N=b.knots[1]-b.knots[0],O=b.knots[X]-b.knots[X-1],Y=b.knots[X+1]-b.knots[X],z=b.knots[2]-b.knots[1],this.computeAlphaBetaGamma(y,k,M,0,z,N,Y,O),O=Y,Y=N,N=b.knots[2]-b.knots[1],z=b.knots[3]-b.knots[2],this.computeAlphaBetaGamma(y,k,M,1,z,N,Y,O),z=Y,N=b.knots[X+1]-b.knots[X],O=b.knots[X-1]-b.knots[X-2],Y=b.knots[X]-b.knots[X-1],this.computeAlphaBetaGamma(y,k,M,X,z,N,Y,O)):(E?(y[0]=0,N=b.knots[1]-b.knots[0],z=b.knots[2]-b.knots[1],B=N+z,V=1/B,k[0]=(N+B)*V,M[0]=-N*V):(y[0]=M[0]=0,k[0]=1),N=b.knots[2]-b.knots[1],Y=b.knots[1]-b.knots[0],O=0,z=b.knots[3]-b.knots[2],this.computeAlphaBetaGamma(y,k,M,1,z,N,Y,O),N=b.knots[X+1]-b.knots[X],Y=b.knots[X]-b.knots[X-1],O=b.knots[X-1]-b.knots[X-2],z=0,this.computeAlphaBetaGamma(y,k,M,X,z,N,Y,O),D?(Y=b.knots[R]-b.knots[R-1],O=b.knots[R-1]-b.knots[R-2],B=O+Y,V=1/B,y[R]=-Y*V,k[R]=(Y+B)*V,M[R]=0):(y[R]=M[R]=0,k[R]=1));for(let U=2;U<X;++U)N=b.knots[U+1]-b.knots[U],O=b.knots[U-1]-b.knots[U-2],Y=b.knots[U]-b.knots[U-1],z=b.knots[U+2]-b.knots[U+1],this.computeAlphaBetaGamma(y,k,M,U,z,N,Y,O);return!0}static setUpSystem(y,k,M,b){let E=!1,D=!1;b.isNaturalTangents&&!b.closed&&(E=void 0===b.startTangent,D=void 0===b.endTangent);let R=!1;return 2===b.fitPoints.length?R=this.setUpSystem2Points(y,k,M):3===b.fitPoints.length?R=this.setUpSystem3Points(y,k,M,b,E,D):4<=b.fitPoints.length&&(R=this.setUpSystem4PointsOrMore(y,k,M,b,E,D)),R}static setBesselEndCondition(y,k,M){if(y.length!==k.fitPoints.length+2)return!1;if(void 0===k.knots)return!1;const b=1/3,E=k.fitPoints.length-1;if(1===E)return M?y[0].interpolate(b,y[3],y[1]):y[3].interpolate(b,y[0],y[2]),!0;if(2===E){const E=(k.knots[2]-k.knots[1])/(k.knots[2]-k.knots[0]),D=1-E,R=y[2].plus2Scaled(y[0],-E*E,y[4],-D*D);return M?j.createAdd2Scaled(R,1/(2*E),y[0],E).interpolate(b,y[0],y[1]):j.createAdd2Scaled(R,1/(2*D),y[4],D).interpolate(b,y[4],y[3]),!0}if(M){const M=(k.knots[2]-k.knots[1])/(k.knots[2]-k.knots[0]),E=1-M,D=y[2].plus2Scaled(y[0],-M*M,y[3],-E*E);j.createAdd2Scaled(D,1/(2*M),y[0],M).interpolate(b,y[0],y[1])}else{const M=(k.knots[E]-k.knots[E-1])/(k.knots[E]-k.knots[E-2]),D=1-M,R=y[E].plus2Scaled(y[E-1],-M*M,y[E+2],-D*D);j.createAdd2Scaled(R,1/(2*D),y[E+2],D).interpolate(b,y[E+2],y[E+1])}return!0}static setNaturalEndCondition(y,k,M){return y.length===k.fitPoints.length+2&&(1==k.fitPoints.length-1?this.setBesselEndCondition(y,k,M):(M?y[1]=y[0]:y[y.length-2]=y[y.length-1],!0))}static setChordLengthScaledEndCondition(y,k,M){if(y.length!==k.fitPoints.length+2)return!1;const b=M?k.startTangent:k.endTangent;if(void 0===b)return!1;let E=0,D=0,R=0;const X=k.fitPoints.length-1;1===X?M?(E=0,D=1,R=3):(E=3,D=2,R=0):M?(E=0,D=1,R=2):(E=X+2,D=X+1,R=X);const z=y[R].distance(y[E]);return y[E].plusScaled(b,z/3,y[D]),!0}static setBesselLengthScaledEndCondition(y,k,M){if(y.length!==k.fitPoints.length+2)return!1;const b=M?k.startTangent:k.endTangent;if(void 0===b)return!1;if(!this.setBesselEndCondition(y,k,M))return!1;const E=k.fitPoints.length-1,D=M?0:E+2,R=M?1:E+1;return y[D].plusScaled(b,y[D].distance(y[R]),y[R]),!0}static setPhysicallyClosedEndCondition(y,k){const M=k.fitPoints.length-1;if(!k.isColinearTangents||M<=2||void 0!==k.startTangent&&void 0!==k.endTangent||k.isNaturalTangents||!y[0].isAlmostEqual(y[M+2]))return!0;if(void 0!==k.startTangent){const k=$.createStartEnd(y[1],y[0]).normalize();if(void 0!==k){const b=y[M+2].distance(y[M+1]);y[M+2].plusScaled(k,b,y[M+1])}}else if(void 0!==k.endTangent){const k=$.createStartEnd(y[M+1],y[M+2]).normalize();if(void 0!==k){const M=y[0].distance(y[1]);y[0].plusScaled(k,M,y[1])}}else{const k=$.createStartEnd(y[M+1],y[1]).normalize();if(void 0!==k){const b=y[0].distance(y[1]);y[0].plusScaled(k,b,y[1]);const E=y[M+2].distance(y[M+1]);y[M+2].plusScaled(k,-E,y[M+1])}}return!0}static setEndConditions(y,k){if(y.length!==k.fitPoints.length)return!1;const M=j.createZero(),b=j.createZero();y.splice(1,0,M),y.splice(y.length-1,0,b);let E=!1;return E=void 0===k.startTangent?k.isNaturalTangents?this.setNaturalEndCondition(y,k,!0):this.setBesselEndCondition(y,k,!0):k.isChordLenTangents?this.setChordLengthScaledEndCondition(y,k,!0):this.setBesselLengthScaledEndCondition(y,k,!0),E=void 0===k.endTangent?k.isNaturalTangents?this.setNaturalEndCondition(y,k,!1):this.setBesselEndCondition(y,k,!1):k.isChordLenTangents?this.setChordLengthScaledEndCondition(y,k,!1):this.setBesselLengthScaledEndCondition(y,k,!1),E&&(E=this.setPhysicallyClosedEndCondition(y,k)),E}static solveNearTridiagonal(y,k,M,b){if(k.length!==M.length||k.length!==b.length||k.length!==y.length)return;const E=[],D=y.length-1,R=y.slice(0,-1);let X=0;for(let z=1;z<D;++z){if(void 0===(X=Q.conditionalDivideFraction(-k[z],M[z-1])))return;M[z]+=X*b[z-1],k[z]=X*k[z-1],R[z].addScaledInPlace(R[z-1],X)}if(void 0!==(X=Q.conditionalDivideFraction(1,M[D-1]+k[D-1]))){b[D-1]*=X,R[D-1].scaleInPlace(X);for(let y=D-2;y>=0;--y){if(void 0===(X=Q.conditionalDivideFraction(1,M[y])))return;j.createScale(R[y].plus2Scaled(R[y+1],-b[y],R[D-1],-k[y]),X,R[y]),b[y]=-(b[y]*b[y+1]+k[y]*b[D-1])*X}if(void 0!==(X=Q.conditionalDivideFraction(1,1+b[0]))){E.push(j.createScale(R[0],X));for(let y=1;y<D;++y)E.push(R[y].plusScaled(E[0],-b[y]));return E}}}static validateOptions(y){if(y.order=4,y.knots=this.convertCubicKnotVectorToFitParams(y.knots,y.fitPoints.length,!0),!this.removeDuplicateFitPoints(y))return!1;let k=y.fitPoints[0].isAlmostEqual(y.fitPoints[y.fitPoints.length-1]);if(3===y.fitPoints.length&&k&&(y.fitPoints.pop(),void 0!==y.knots&&y.knots.pop(),k=y.fitPoints[0].isAlmostEqual(y.fitPoints[y.fitPoints.length-1])),y.fitPoints.length<=2){if(k)return!1;y.closed=!1}return y.closed&&(k||(y.fitPoints.push(y.fitPoints[0].clone()),void 0!==y.knots&&y.knots.push(y.knots[y.knots.length-1]+(y.knots[y.knots.length-1]-y.knots[0])/(y.knots.length-1))),y.fitPoints.length<=4&&(y.closed=!1)),!(y.fitPoints.length<2||(void 0!==y.startTangent&&(y.startTangent.isAlmostZero?y.startTangent=void 0:y.startTangent.normalizeInPlace()),void 0!==y.endTangent&&(y.endTangent.isAlmostZero?y.endTangent=void 0:y.endTangent.normalizeInPlace()),0))}static convertCubicKnotVectorToFitParams(y,k,M){let b=y?.slice();if(void 0!==b){const y=b.length-k;switch(y){case 0:break;case 4:case 6:for(let k=0;k<y/2;++k)b.pop(),b.shift();break;default:b=void 0}M&&!this.normalizeKnots(b)&&(b=void 0)}return b}static convertFitParamsToCubicKnotVector(y,k,M){const b=y?.slice();if(void 0!==b){const y=M?6:4;if(k){const k=b.length-2;for(let M=2;M<=y;M+=2)b.unshift(b[k]-1),b.push(1+b[M])}else for(let k=0;k<y/2;++k)b.unshift(0),b.push(1)}return b}static convertToJsonKnots(y){void 0!==y.knots?(y.knots=this.convertCubicKnotVectorToFitParams(y.knots,y.fitPoints.length,!1),y.knots=this.convertFitParamsToCubicKnotVector(y.knots,y.closed,!0)):(y.knots=this.constructFitParametersFromPoints(ue.clonePoint3dArray(y.fitPoints),y.isChordLenKnots,y.closed),y.knots=this.convertFitParamsToCubicKnotVector(y.knots,y.closed,!0))}static constructPoles(y){if(!this.constructFitParameters(y)||void 0===y.knots)return;const k=y.fitPoints.length,M=Array(k),b=Array(k),E=Array(k);if(!this.setUpSystem(M,b,E,y))return;let D=[];if(y.closed){if(void 0!==(D=this.solveNearTridiagonal(y.fitPoints,M,b,E))&&D.length>2){D.unshift(D.pop());for(let k=0;k<y.order-1;++k)D.push(D[k].clone())}}else{const R=y.fitPoints.slice();if(!this.setEndConditions(R,y))return;if(R.length!==k+2)return;const X=new Float64Array(3*k),z=new Float64Array(3*k);for(let y=0,D=0,O=0;y<k;++y)X[D++]=M[y],X[D++]=b[y],X[D++]=E[y],z[O++]=R[y+1].x,z[O++]=R[y+1].y,z[O++]=R[y+1].z;const N=fe.solveBandedSystemMultipleRHS(k,3,X,3,z);if(void 0===N)return;D=new Float64Array(3+N.length+3);let Y=0;D[Y++]=y.fitPoints[0].x,D[Y++]=y.fitPoints[0].y,D[Y++]=y.fitPoints[0].z;for(let y=0;y<N.length;)D[Y++]=N[y++];D[Y++]=y.fitPoints[y.fitPoints.length-1].x,D[Y++]=y.fitPoints[y.fitPoints.length-1].y,D[Y++]=y.fitPoints[y.fitPoints.length-1].z}return D}}}(pe||(pe={}));class me extends ae{dispatchToGeometryHandler(y){return this._proxyCurve.dispatchToGeometryHandler(y)}constructor(y){super(),this._proxyCurve=y}get proxyCurve(){return this._proxyCurve}computeStrokeCountForOptions(y){return this._proxyCurve.computeStrokeCountForOptions(y)}emitStrokableParts(y,k){this._proxyCurve.emitStrokableParts(y,k)}cloneTransformed(y){const k=this.clone();if(k.tryTransformInPlace(y))return k}clonePartialCurve(y,k){return this._proxyCurve.clonePartialCurve(y,k)}emitStrokes(y,k){this._proxyCurve.emitStrokes(y,k)}extendRange(y,k){this._proxyCurve.extendRange(y,k)}range(y,k){return this._proxyCurve.range(y,k)}fractionToPoint(y,k){return this._proxyCurve.fractionToPoint(y,k)}fractionToPointAndDerivative(y,k){return this._proxyCurve.fractionToPointAndDerivative(y,k)}fractionToPointAnd2Derivatives(y,k){return this._proxyCurve.fractionToPointAnd2Derivatives(y,k)}isInPlane(y){return this._proxyCurve.isInPlane(y)}quickLength(){return this._proxyCurve.quickLength()}constructOffsetXY(y){return this._proxyCurve.constructOffsetXY(y)}projectedParameterRange(y,k){return this._proxyCurve.projectedParameterRange(y,k)}}class xe{constructor(y,k){this._fitPoints=y||[],this._knots=k}get order(){return Q.resolveNumber(this._order,4)}set order(y){this._order=y}get closed(){return Q.resolveValue(this._closed,!1)}set closed(y){this._closed=y}get isChordLenKnots(){return Q.resolveNumber(this._isChordLenKnots,0)}set isChordLenKnots(y){this._isChordLenKnots=y}get isColinearTangents(){return Q.resolveNumber(this._isColinearTangents,0)}set isColinearTangents(y){this._isColinearTangents=y}get isChordLenTangents(){return Q.resolveNumber(this._isChordLenTangents,0)}set isChordLenTangents(y){this._isChordLenTangents=y}get isNaturalTangents(){return Q.resolveNumber(this._isNaturalTangents,0)}set isNaturalTangents(y){this._isNaturalTangents=y}get startTangent(){return this._startTangent}set startTangent(y){this._startTangent=y}get endTangent(){return this._endTangent}set endTangent(y){this._endTangent=y}get fitPoints(){return this._fitPoints}set fitPoints(y){this._fitPoints=y}get knots(){return this._knots}set knots(y){this._knots=y}captureOptionalProps(y,k,M,b,E,D,R,X){this._order=Q.resolveToUndefined(y,0),this._closed=Q.resolveToUndefined(k,!1),this._isChordLenKnots=Q.resolveToUndefined(M,0),this._isColinearTangents=Q.resolveToUndefined(b,0),this._isChordLenTangents=Q.resolveToUndefined(E,0),this._isNaturalTangents=Q.resolveToUndefined(D,0),this._startTangent=R,this._endTangent=X}cloneAsInterpolationCurve3dProps(){const y={fitPoints:ue.cloneDeepJSONNumberArrays(this.fitPoints),knots:this._knots?.slice()};return void 0!==this._order&&(y.order=this._order),void 0!==this._closed&&(y.closed=this._closed),void 0!==this._isChordLenKnots&&(y.isChordLenKnots=this._isChordLenKnots),void 0!==this._isColinearTangents&&(y.isColinearTangents=this._isColinearTangents),void 0!==this._isChordLenTangents&&(y.isChordLenTangents=this._isChordLenTangents),void 0!==this._isNaturalTangents&&(y.isNaturalTangents=this._isNaturalTangents),void 0!==this._startTangent&&(y.startTangent=this._startTangent?.toArray()),void 0!==this._endTangent&&(y.endTangent=this._endTangent?.toArray()),y}clone(){const y=new xe(ue.clonePoint3dArray(this.fitPoints),this.knots?.slice());return y._order=this.order,y._closed=this.closed,y._isChordLenKnots=this.isChordLenKnots,y._isColinearTangents=this.isColinearTangents,y._isChordLenTangents=this.isChordLenTangents,y._isNaturalTangents=this.isNaturalTangents,y._startTangent=this._startTangent?.clone(),y._endTangent=this._endTangent?.clone(),y}static create(y){const k=new xe(ue.clonePoint3dArray(y.fitPoints),y.knots?.slice());return k._order=y.order,k._closed=y.closed,k._isChordLenKnots=y.isChordLenKnots,k._isColinearTangents=y.isColinearTangents,k._isChordLenTangents=y.isChordLenTangents,k._isNaturalTangents=y.isNaturalTangents,k._startTangent=y.startTangent?$.fromJSON(y.startTangent):void 0,k._endTangent=y.endTangent?$.fromJSON(y.endTangent):void 0,k}static areAlmostEqualAllow000AsUndefined(y,k){return void 0!==y&&0===y.maxAbs()&&(y=void 0),void 0!==k&&0===k.maxAbs()&&(k=void 0),void 0!==y&&void 0!==k?y.isAlmostEqual(k):void 0===y&&void 0===k}static areAlmostEqual(y,k){if(void 0===y&&void 0===k)return!0;if(void 0!==y&&void 0!==k&&Q.areEqualAllowUndefined(y.order,k.order)&&Q.areEqualAllowUndefined(y.closed,k.closed)&&Q.areEqualAllowUndefined(y.isChordLenKnots,k.isChordLenKnots)&&Q.areEqualAllowUndefined(y.isColinearTangents,k.isColinearTangents)&&Q.areEqualAllowUndefined(y.isNaturalTangents,k.isNaturalTangents)&&this.areAlmostEqualAllow000AsUndefined(y.startTangent,k.startTangent)&&this.areAlmostEqualAllow000AsUndefined(y.endTangent,k.endTangent)&&Q.almostEqualArrays(y.fitPoints,k.fitPoints,((y,k)=>y.isAlmostEqual(k)))){if(Q.almostEqualNumberArrays(y.knots,k.knots,((y,k)=>y===k)))return!0;if(void 0===y.knots&&void 0===k.knots)return!0;let M=y.knots,b=k.knots;return void 0===y.knots?M=pe.C2CubicFit.constructFitParametersFromPoints(y.fitPoints,y.isChordLenKnots,y.closed):void 0===k.knots&&(b=pe.C2CubicFit.constructFitParametersFromPoints(k.fitPoints,k.isChordLenKnots,k.closed)),M=pe.C2CubicFit.convertCubicKnotVectorToFitParams(M,y.fitPoints.length,!1),b=pe.C2CubicFit.convertCubicKnotVectorToFitParams(b,k.fitPoints.length,!1),Q.almostEqualNumberArrays(M,b,((y,k)=>Q.isAlmostEqualNumber(y,k)))}return!1}reverseInPlace(){this.fitPoints.reverse(),this.knots&&this.knots.reverse();const y=this._startTangent;this._startTangent=this.endTangent,this._endTangent=y}}class _e extends me{constructor(y,k){super(k),this.curvePrimitiveType="interpolationCurve",this._options=y}dispatchToGeometryHandler(y){let k=y.handleInterpolationCurve3d(this);return void 0===k&&(k=this._proxyCurve.dispatchToGeometryHandler(y)),k}static create(y){let k;return k=y instanceof xe?y.clone():xe.create(y),_e.createCapture(k)}static createCapture(y){const k=Be.createFromInterpolationCurve3dOptions(y);if(k)return new _e(y,k)}copyFitPointsFloat64Array(){return ue.cloneXYZPropsAsFloat64Array(this._options.fitPoints)}toJSON(){return this._options.cloneAsInterpolationCurve3dProps()}cloneProps(){return this._options.cloneAsInterpolationCurve3dProps()}get options(){return this._options}reverseInPlace(){this._proxyCurve.reverseInPlace(),this._options.reverseInPlace()}tryTransformInPlace(y){const k=this._proxyCurve.tryTransformInPlace(y);return k&&(y.multiplyPoint3dArrayInPlace(this._options.fitPoints),this._options.startTangent&&y.multiplyVectorInPlace(this._options.startTangent),this._options.endTangent&&y.multiplyVectorInPlace(this._options.endTangent)),k}clone(){return new _e(this._options.clone(),this._proxyCurve.clone())}isAlmostEqual(y){return y instanceof _e&&xe.areAlmostEqual(this._options,y._options)}isSameGeometryClass(y){return y instanceof _e}}class ye{constructor(y,k){this._p0=j.createZero(),this._p1=j.createZero(),this._v0=$.createZero(),this._v1=$.createZero(),this._r0=bt.createZero(),this._offsetDistance=k,this._fitOptions=new xe;const M=y.fractionToPointAndUnitTangent(0,this._r0).direction.clone(),b=y.fractionToPointAndUnitTangent(1,this._r0).direction.negate();this._fitOptions.startTangent=M,this._fitOptions.endTangent=b,(this._fitOptions.closed=y.startPoint(this._p0).isAlmostEqual(y.endPoint(this._p1))&&M.isParallelTo(b,!0))&&(this._fitOptions.isChordLenKnots=1)}pushOffsetPoint(y,k){Q.isSmallMetricDistance(k.x)&&Q.isSmallMetricDistance(k.y)||this._fitOptions.fitPoints.push(y.plusScaled(k.unitPerpendicularXY(this._v0),this._offsetDistance))}needPrimaryGeometryForStrokes(){return!0}startParentCurvePrimitive(y){}startCurvePrimitive(y){}endCurvePrimitive(y){}endParentCurvePrimitive(y){}announceIntervalForUniformStepStrokes(y,k,M,b){for(let E=0;E<=k;++E){const D=Q.interpolate(M,E/k,b),R=y.fractionToPointAndDerivative(D,this._r0);this.pushOffsetPoint(R.origin,R.direction)}}announceSegmentInterval(y,k,M,b,E,D){if(b>0){const y=$.createStartEnd(k,M,this._v1);for(let E=0;E<=b;++E)this.pushOffsetPoint(k.interpolate(E/b,M,this._p0),y)}}announcePointTangent(y,k,M){this.pushOffsetPoint(y,M)}claimResult(){return pe.createThroughPointsC2Cubic(this._fitOptions)}}class ve{handleCurveCollection(y){}handlePath(y){return this.handleCurveCollection(y)}handleLoop(y){return this.handleCurveCollection(y)}handleParityRegion(y){return this.handleCurveCollection(y)}handleUnionRegion(y){return this.handleCurveCollection(y)}handleBagOfCurves(y){return this.handleCurveCollection(y)}handleCurveChainWithDistanceIndex(y){return this.handlePath(y.path)}}class Pe extends ve{handleLineSegment3d(y){}handleLineString3d(y){}handleArc3d(y){}handleCurveCollection(y){}handleCurveChainWithDistanceIndex(y){}handleBSplineCurve3d(y){}handleInterpolationCurve3d(y){}handleAkimaCurve3d(y){}handleBSplineCurve3dH(y){}handleBSplineSurface3d(y){}handleCoordinateXYZ(y){}handleBSplineSurface3dH(y){}handleIndexedPolyface(y){}handleTransitionSpiral(y){}handlePath(y){}handleLoop(y){}handleParityRegion(y){}handleUnionRegion(y){}handleBagOfCurves(y){}handleSphere(y){}handleCone(y){}handleBox(y){}handleTorusPipe(y){}handleLinearSweep(y){}handleRotationalSweep(y){}handleRuledSweep(y){}handlePointString3d(y){}handleBezierCurve3d(y){}handleBezierCurve3dH(y){}}class Ae extends ve{handleLineSegment3d(y){}handleLineString3d(y){}handleArc3d(y){}handleBSplineCurve3d(y){}handleInterpolationCurve3d(y){}handleAkimaCurve3d(y){}handleBSplineCurve3dH(y){}handleBSplineSurface3d(y){}handleCoordinateXYZ(y){}handleBSplineSurface3dH(y){}handleIndexedPolyface(y){}handleTransitionSpiral(y){}handleChildren(y){const k=y.children;if(k)for(const M of k)M.dispatchToGeometryHandler(this)}handleCurveCollection(y){return this.handleChildren(y)}handleSphere(y){}handleCone(y){}handleBox(y){}handleTorusPipe(y){}handleLinearSweep(y){}handleRotationalSweep(y){}handleRuledSweep(y){}handlePointString3d(y){}handleBezierCurve3d(y){}handleBezierCurve3dH(y){}}class Ie{constructor(){this.shouldTriangulate=!1,this.defaultCircleStrokes=16}get needParams(){return void 0!==this._needParams&&this._needParams}set needParams(y){this._needParams=y}get needNormals(){return void 0!==this._needNormals&&this._needNormals}set needNormals(y){this._needNormals=y}get needTwoSided(){return void 0!==this._needTwoSided&&this._needTwoSided}set needTwoSided(y){this._needTwoSided=y}get hasAngleTol(){return void 0!==this.angleTol&&Math.abs(this.angleTol.radians)>0}get hasChordTol(){return void 0!==this.chordTol&&this.chordTol>0}get hasMaxEdgeLength(){return void 0!==this.maxEdgeLength&&this.maxEdgeLength>0}get maximizeConvexFacets(){return this._maximizeConvexFacets??!1}set maximizeConvexFacets(y){this._maximizeConvexFacets=y,y&&(this.shouldTriangulate=y)}clone(){const y=new Ie;return y.chordTol=this.chordTol,y.angleTol=this.angleTol?.clone(),y.maxEdgeLength=this.maxEdgeLength,y.minStrokesPerPrimitive=this.minStrokesPerPrimitive,y.shouldTriangulate=this.shouldTriangulate,y._needNormals=this._needNormals,y._needTwoSided=this._needTwoSided,y._needParams=this._needParams,y.needColors=this.needColors,y.defaultCircleStrokes=this.defaultCircleStrokes,y._maximizeConvexFacets=this._maximizeConvexFacets,y}applyMaxEdgeLength(y,k){return k=Math.abs(k),this.maxEdgeLength&&this.maxEdgeLength>0&&y*this.maxEdgeLength<k&&(y=Q.stepCount(this.maxEdgeLength,k,y)),y}applyAngleTol(y,k,M){return Ie.applyAngleTol(this,y,k,M)}static applyAngleTol(y,k,M,b){M=Math.abs(M);let E=b||Math.PI/8;return y&&y.angleTol&&y.angleTol.radians>0&&(E=y.angleTol.radians),k*E<M&&(k=Q.stepCount(E,M,k)),k}static applyMaxEdgeLength(y,k,M){return M<0&&(M=-M),k<1&&(k=1),y&&y.maxEdgeLength&&y.maxEdgeLength*k<M&&(k=Q.stepCount(y.maxEdgeLength,M,k)),k}applyTolerancesToArc(y,k=2*Math.PI){let M=1;return M=this.applyAngleTol(M,k,.25*Math.PI),M=this.applyMaxEdgeLength(M,k*y),M=this.applyChordTol(M,y,k),M=this.applyMinStrokesPerPrimitive(M),M}applyChordTol(y,k,M){if(this.chordTol&&this.chordTol>0&&this.chordTol<k){const b=this.chordTol,E=2*Math.acos(1-b/k);y=Q.stepCount(E,M,y)}return y}applyChordTolToLengthAndRadians(y,k,M){if(this.chordTol&&this.chordTol>0){const b=Q.conditionalDivideFraction(k,M);if(void 0!==b)return this.applyChordTol(y,b,M)}return y}applyMinStrokesPerPrimitive(y){return void 0!==this.minStrokesPerPrimitive&&Number.isFinite(this.minStrokesPerPrimitive)&&this.minStrokesPerPrimitive>y&&(y=this.minStrokesPerPrimitive),y}static createForCurves(){const y=new Ie;return y.angleTol=W.createDegrees(15),y}static createForFacets(){const y=new Ie;return y.angleTol=W.createDegrees(22.5),y}}class Se{constructor(y,k=180,M=91,b=!1,E=!1){this.minArcDegrees=180,this.maxChamferTurnDegrees=91,this.allowSharpestCorners=!1,this.leftOffsetDistance=0,this.preserveEllipticalArcs=!1,this.leftOffsetDistance=y,this.minArcDegrees=k,this.maxChamferTurnDegrees=M,this.preserveEllipticalArcs=b,this.allowSharpestCorners=E}clone(){return new Se(this.leftOffsetDistance,this.minArcDegrees,this.maxChamferTurnDegrees,this.preserveEllipticalArcs,this.allowSharpestCorners)}setFrom(y){this.leftOffsetDistance=y.leftOffsetDistance,this.minArcDegrees=y.minArcDegrees,this.maxChamferTurnDegrees=y.maxChamferTurnDegrees,this.preserveEllipticalArcs=y.preserveEllipticalArcs,this.allowSharpestCorners=y.allowSharpestCorners}static create(y){return y instanceof Se?y:new Se(y)}needArc(y){return Math.abs(y.degrees)>=this.minArcDegrees-Q.smallAngleDegrees}numChamferPoints(y){const k=Math.abs(y.degrees);let M=120;this.allowSharpestCorners&&(M=this.maxChamferTurnDegrees);const b=Q.clamp(this.maxChamferTurnDegrees,10,M);return k<=b+Q.smallAngleDegrees?1:Math.ceil(k/b)}}class we{constructor(y,k){this.jointOptions=Se.create(y),this.strokeOptions=void 0!==k?k:Ie.createForCurves()}get minArcDegrees(){return this.jointOptions.minArcDegrees}set minArcDegrees(y){this.jointOptions.minArcDegrees=y}get maxChamferTurnDegrees(){return this.jointOptions.maxChamferTurnDegrees}set maxChamferTurnDegrees(y){this.jointOptions.maxChamferTurnDegrees=y}get allowSharpestCorners(){return this.jointOptions.allowSharpestCorners}set allowSharpestCorners(y){this.jointOptions.allowSharpestCorners=y}get leftOffsetDistance(){return this.jointOptions.leftOffsetDistance}set leftOffsetDistance(y){this.jointOptions.leftOffsetDistance=y}get preserveEllipticalArcs(){return this.jointOptions.preserveEllipticalArcs}set preserveEllipticalArcs(y){this.jointOptions.preserveEllipticalArcs=y}static create(y){return y instanceof we?y:new we(y)}static getOffsetDistance(y){return"number"==typeof y?y:y.leftOffsetDistance}clone(){return new we(this.jointOptions.clone(),this.strokeOptions.clone())}}class Ce extends ae{isSameGeometryClass(y){return y instanceof Ce}get point0Ref(){return this._point0}get point1Ref(){return this._point1}get isExtensibleFractionSpace(){return!0}constructor(y,k){super(),this.curvePrimitiveType="lineSegment",this._point0=y,this._point1=k}setRefs(y,k){this._point0=y,this._point1=k}set(y,k){this._point0=y.clone(),this._point1=k.clone()}setFrom(y){this._point0.setFrom(y._point0),this._point1.setFrom(y._point1)}startPoint(y){return y?(y.setFrom(this._point0),y):this._point0.clone()}endPoint(y){return y?(y.setFrom(this._point1),y):this._point1.clone()}fractionToPointAndDerivative(y,k){return(k=k||bt.createZero()).direction.setStartEnd(this._point0,this._point1),this._point0.interpolate(y,this._point1,k.origin),k}fractionToPointAnd2Derivatives(y,k){return(k=k||Et.createXYPlane()).vectorU.setStartEnd(this._point0,this._point1),k.vectorV.set(0,0,0),this._point0.interpolate(y,this._point1,k.origin),k}clone(){return Ce.create(this._point0,this._point1)}cloneTransformed(y){const k=this.clone();return k.tryTransformInPlace(y),k}static create(y,k,M){return M?(M.set(y,k),M):new Ce(y.clone(),k.clone())}static createCapture(y,k){return new Ce(y,k)}static createXYXY(y,k,M,b,E=0,D){return D?(D._point0.set(y,k,E),D._point1.set(M,b,E),D):new Ce(j.create(y,k,E),j.create(M,b,E))}static createXYZXYZ(y,k,M,b,E,D,R){return R?(R._point0.set(y,k,M),R._point1.set(b,E,D),R):new Ce(j.create(y,k,M),j.create(b,E,D))}fractionToPoint(y,k){return this._point0.interpolate(y,this._point1,k)}curveLength(){return this._point0.distance(this._point1)}curveLengthBetweenFractions(y,k){return Math.abs(k-y)*this._point0.distance(this._point1)}quickLength(){return this.curveLength()}closestPoint(y,k,M){let b=y.fractionOfProjectionToLine(this._point0,this._point1,0);return b=ie.correctFraction(k,b),(M=vt.create(this,M)).fraction=b,this._point0.interpolate(b,this._point1,M.point),M.vectorInCurveLocationDetail=void 0,M.a=M.point.distance(y),M}static closestApproach(y,k,M,b,E){const D=J.create();if(void 0===E&&(E=Pt.createCapture(vt.create(),vt.create())),Mt.lineSegment3dClosestApproachUnbounded(y._point0,y._point1,M._point0,M._point1,D)){const R=ie.correctFraction(k,D.x),X=ie.correctFraction(b,D.y);if(R===D.x&&X===D.y)return vt.createCurveEvaluatedFraction(y,R,E.detailA),vt.createCurveEvaluatedFraction(M,X,E.detailB),E.detailA.a=E.detailB.a=E.detailA.point.distance(E.detailB.point),E;if(R!==D.x&&X!==D.y){const D=R<.5?y._point0:y._point1,z=X<.5?M._point0:M._point1;M.closestPoint(D,b,E.detailB),y.closestPoint(z,k,E.detailA),E.detailA.a<=E.detailB.a?vt.createCurveFractionPoint(M,X,z,E.detailB):vt.createCurveFractionPoint(y,R,D,E.detailA)}else if(X!==D.y){const b=X<.5?M._point0:M._point1;y.closestPoint(b,k,E.detailA),E.detailB.setCurve(M),E.detailB.point.setFrom(b),E.detailB.fraction=X}else{const k=R<.5?y._point0:y._point1;M.closestPoint(k,b,E.detailB),E.detailA.setCurve(y),E.detailA.point.setFrom(k),E.detailA.fraction=R}return E.detailA.a=E.detailB.a=E.detailA.point.distance(E.detailB.point),E}const R=[y.closestPoint(M._point0,k),y.closestPoint(M._point1,k),M.closestPoint(y._point0,b),M.closestPoint(y._point1,b)];let X=R[0].a,z=0;for(let N=1;N<4;N++)R[N].a<X&&(z=N,X=R[N].a);return 0===z?(R[0].clone(E.detailA),vt.createCurveEvaluatedFraction(M,0,E.detailB),E.detailB.a=E.detailA.a):1===z?(R[1].clone(E.detailA),vt.createCurveEvaluatedFraction(M,1,E.detailB),E.detailB.a=E.detailA.a):2===z?(R[2].clone(E.detailB),vt.createCurveEvaluatedFraction(y,0,E.detailA),E.detailA.a=E.detailB.a):(e(),R[3].clone(E.detailB),vt.createCurveEvaluatedFraction(y,1,E.detailA),E.detailA.a=E.detailB.a),E}reverseInPlace(){const y=this._point0;this._point0=this._point1,this._point1=y}tryTransformInPlace(y){return this._point0=y.multiplyPoint3d(this._point0,this._point0),this._point1=y.multiplyPoint3d(this._point1,this._point1),!0}isInPlane(y){return Q.isSmallMetricDistance(y.altitude(this._point0))&&Q.isSmallMetricDistance(y.altitude(this._point1))}appendPlaneIntersectionPoints(y,k){const M=y.altitude(this._point0),b=y.altitude(this._point1),E=Ut.solveCoffs(M,b);let D=0;if(void 0!==E){D++;const y=vt.createCurveFractionPoint(this,E,this.fractionToPoint(E));y.intervalRole=O.isolated,k.push(y)}return D}extendRange(y,k){k?(y.extendTransformedPoint(k,this._point0),y.extendTransformedPoint(k,this._point1)):(y.extendPoint(this._point0),y.extendPoint(this._point1))}setFromJSON(y){if(!y)return this._point0.set(0,0,0),void this._point1.set(1,0,0);y.startPoint&&y.endPoint?(this._point0.setFromJSON(y.startPoint),this._point1.setFromJSON(y.endPoint)):Array.isArray(y)&&y.length>1&&(this._point0.setFromJSON(y[0]),this._point1.setFromJSON(y[1]))}getFractionToDistanceScale(){return this.curveLength()}toJSON(){return[this._point0.toJSON(),this._point1.toJSON()]}static fromJSON(y){const k=new Ce(j.createZero(),j.create());return k.setFromJSON(y),k}isAlmostEqual(y){if(y instanceof Ce){const k=y;return this._point0.isAlmostEqual(k._point0)&&this._point1.isAlmostEqual(k._point1)}return!1}emitStrokes(y,k){const M=this.computeStrokeCountForOptions(k);y.appendFractionalStrokePoints(this,M,0,1)}emitStrokableParts(y,k){y.startCurvePrimitive(this);const M=this.computeStrokeCountForOptions(k);y.announceSegmentInterval(this,this._point0,this._point1,M,0,1),y.endCurvePrimitive(this)}computeStrokeCountForOptions(y){let k=1;return y&&(y.maxEdgeLength&&(k=y.applyMaxEdgeLength(k,this.curveLength())),k=y.applyMinStrokesPerPrimitive(k)),k}dispatchToGeometryHandler(y){return y.handleLineSegment3d(this)}announceClipIntervals(y,k){return y.announceClippedSegmentIntervals(0,1,this._point0,this._point1,k?(y,M)=>k(y,M,this):void 0)}clonePartialCurve(y,k){return Ce.create(this.fractionToPoint(y),this.fractionToPoint(k))}rangeBetweenFractions(y,k,M){if(!M){const M=ut.create();return M.extendInterpolated(this._point0,y,this._point1),M.extendInterpolated(this._point0,k,this._point1),M}const b=this.fractionToPoint(y),E=this.fractionToPoint(k);return M&&(M.multiplyPoint3d(b,b),M.multiplyPoint3d(E,E)),ut.create(b,E)}constructOffsetXY(y){const k=$.createStartEnd(this._point0,this._point1);if(k.normalizeInPlace()){k.rotate90CCWXY(k);const M=we.getOffsetDistance(y);return Ce.create(this._point0.plusScaled(k,M),this._point1.plusScaled(k,M))}}projectedParameterRange(y,k){return Ee.findExtremeFractionsAlongDirection(this,y,k)}}class Te{getXAtUncheckedPointIndex(y){const k=this.getPoint2dAtCheckedPointIndex(y,Te._workPoint);return void 0===Te._workPoint&&(Te._workPoint=k),k?k.x:0}getYAtUncheckedPointIndex(y){const k=this.getPoint2dAtCheckedPointIndex(y,Te._workPoint);return void 0===Te._workPoint&&(Te._workPoint=k),k?k.y:0}linearCombination(y,k){const M=Math.min(this.length,y.length),b=k instanceof J?J.createZero(k):H.createZero(k);for(let E=0;E<M;++E)b.x+=y[E]*this.getXAtUncheckedPointIndex(E),b.y+=y[E]*this.getYAtUncheckedPointIndex(E);return b}}class Fe extends Te{constructor(y=8,k){super(),this._data=new Float64Array(2*y),this._xyInUse=0,this._xyCapacity=y,this._growthFactor=void 0!==k&&k>=1?k:1.5}copyData(y,k,M){let b=void 0!==M?2*M:0;if(b<0&&(b=0),b>=this._data.length)return{count:0,offset:0};let E=void 0!==k?2*k:y.length;return E>0&&(E>y.length&&(E=y.length),b+E>this._data.length&&(E=this._data.length-b),E%2!=0&&(E-=E%2)),E<=0?{count:0,offset:0}:(E===y.length?this._data.set(y,b):y instanceof Float64Array?this._data.set(y.subarray(0,E),b):this._data.set(y.slice(0,E),b),{count:E/2,offset:b/2})}get length(){return this._xyInUse}set length(y){this.resize(y,!0)}get float64Length(){return 2*this._xyInUse}float64Data(){return this._data}ensureCapacity(y,k=!0){if(y>this._xyCapacity){k&&(y*=this._growthFactor);const M=this._data;this._data=new Float64Array(2*y),this.copyData(M,this._xyInUse),this._xyCapacity=y}}resize(y,k){y>=0&&y<this._xyInUse?this._xyInUse=y:y>this._xyInUse&&(this.ensureCapacity(y,!1),k&&this._data.fill(0,2*this._xyInUse),this._xyInUse=y)}clone(){const y=new Fe(this.length);return y.copyData(this._data,this.length),y._xyInUse=this.length,y}static create(y,k){if(k)k.clear();else{const M="number"==typeof y[0]?y.length/2:y.length;k=new Fe(M)}return k.pushFrom(y),k}static createArrayOfGrowableXYZArray(y){return nt.createArrayOfGrowableXYZArray(y)}push(y){this.pushXY(y.x,y.y)}pushAll(y){this.ensureCapacity(this._xyInUse+y.length,!1);for(const k of y)this.push(k)}pushAllXYAndZ(y){if(this.ensureCapacity(this._xyInUse+y.length,!1),y instanceof nt){const k=y.float64Data(),M=3*y.length;for(let y=0;y+2<M;y+=3)this.pushXY(k[y],k[y+1])}else for(const k of y)this.pushXY(k.x,k.y)}pushFrom(y){if(y instanceof j)this.pushXY(y.x,y.y);else if(y instanceof nt)this.pushAllXYAndZ(y);else if(y instanceof H)this.pushXY(y.x,y.y);else if(Q.isNumberArray(y,3)||y instanceof Float64Array){const k=Math.trunc(y.length/2);this.ensureCapacity(this._xyInUse+k,!1),this.copyData(y,k,this._xyInUse),this._xyInUse+=k}else if(Q.isNumberArray(y,2))this.pushXY(y[0],y[1]);else if(Array.isArray(y))for(const k of y)this.pushFrom(k);else if(j.isXAndY(y))this.pushXY(y.x,y.y);else if(y instanceof Te){const k=y.length;this.ensureCapacity(this._xyInUse+k,!1);for(let M=0;M<k;M++)this.pushXY(y.getXAtUncheckedPointIndex(M),y.getYAtUncheckedPointIndex(M))}}pushWrap(y){if(this._xyInUse>=y){this.ensureCapacity(this._xyInUse+y,!1);for(let k=0;k<y;k++){const y=2*k;this.pushXY(this._data[y],this._data[y+1])}}}pushXY(y,k){this.ensureCapacity(this._xyInUse+1);const M=2*this._xyInUse;this._data[M]=y,this._data[M+1]=k,this._xyInUse++}pop(){this._xyInUse>0&&this._xyInUse--}isIndexValid(y){return!(y>=this._xyInUse||y<0)}clear(){this._xyInUse=0}getPoint2dAtUncheckedPointIndex(y,k){const M=2*y;return H.create(this._data[M],this._data[M+1],k)}getXAtUncheckedPointIndex(y){return this._data[2*y]}getYAtUncheckedPointIndex(y){return this._data[2*y+1]}getPoint2dArray(){const y=2*this._xyInUse,k=[],M=this._data;for(let b=0;b<y;b+=2)k.push(H.create(M[b],M[b+1]));return k}getPoint2dAtCheckedPointIndex(y,k){if(this.isIndexValid(y)){const M=2*y;return H.create(this._data[M],this._data[M+1],k)}}getVector2dAtCheckedVectorIndex(y,k){if(this.isIndexValid(y)){const M=2*y;return J.create(this._data[M],this._data[M+1],k)}}transferFromGrowableXYArray(y,k,M){if(this.isIndexValid(y)&&k.isIndexValid(M)){const b=2*y,E=2*M;return this._data[b]=k._data[E],this._data[b+1]=k._data[E+1],!0}return!1}pushFromGrowableXYArray(y,k){if(void 0===k){const k=y.length;return this.ensureCapacity(this.length+k,!1),this.copyData(y._data,k,this.length),this._xyInUse+=k,k}if(y.isIndexValid(k)){const M=2*k;return this.pushXY(y._data[M],y._data[M+1]),1}return 0}pushInterpolatedFromGrowableXYArray(y,k,M,b){if(y.isIndexValid(k)&&y.isIndexValid(b)){const E=1-M,D=y._data;k*=2,b*=2,this.pushXY(E*D[k]+M*D[b],E*D[k+1]+M*D[b+1])}}static createFromGrowableXYZArray(y,k,M){const b=y.length;if(M?(M.ensureCapacity(b,!1),M.clear()):M=new Fe(b),k){const E=y.float64Data(),D=3*b;let R,X,z;for(let y=0;y<D;y+=3)R=E[y],X=E[y+1],z=E[y+2],M.pushXY(k.multiplyComponentXYZ(0,R,X,z),k.multiplyComponentXYZ(1,R,X,z))}else M.pushAllXYAndZ(y);return M}front(y){if(0!==this._xyInUse)return this.getPoint2dAtUncheckedPointIndex(0,y)}back(y){if(!(this._xyInUse<1))return this.getPoint2dAtUncheckedPointIndex(this._xyInUse-1,y)}setAtCheckedPointIndex(y,k){if(!this.isIndexValid(y))return!1;const M=2*y;return this._data[M]=k.x,this._data[M+1]=k.y,!0}setXYAtCheckedPointIndex(y,k,M){if(!this.isIndexValid(y))return!1;const b=2*y;return this._data[b]=k,this._data[b+1]=M,!0}setXYZAtCheckedPointIndex(y,k,M){return this.setXYAtCheckedPointIndex(y,k,M)}getPoint3dArray(y=0){const k=2*this._xyInUse,M=[],b=this._data;for(let E=0;E<k;E+=2)M.push(j.create(b[E],b[E+1],y));return M}reverseInPlace(){const y=this.length;let k,M,b;const E=this._data;for(let D=0,R=y-1;D<R;D++,R--)k=2*D,M=2*R,b=E[k],E[k]=E[M],E[M]=b,k++,M++,b=E[k],E[k]=E[M],E[M]=b}multiplyTransformInPlace(y){const k=this._data,M=this.float64Length,b=y.matrix.coffs,E=y.origin,D=E.x,R=E.y;let X=0,z=0;for(let N=0;N+1<M;N+=2)X=k[N],z=k[N+1],k[N]=b[0]*X+b[1]*z+D,k[N+1]=b[3]*X+b[4]*z+R}multiplyMatrix3dInPlace(y){const k=this._data,M=this.float64Length,b=y.coffs;let E=0,D=0;for(let R=0;R+1<M;R+=2)E=k[R],D=k[R+1],k[R]=b[0]*E+b[1]*D,k[R+1]=b[3]*E+b[4]*D}tryTransformInverseInPlace(y){const k=this._data,M=this.float64Length,b=y.matrix;b.computeCachedInverse(!0);const E=b.inverseCoffs;if(!E)return!1;const D=y.origin,R=D.x,X=D.y;let z=0,N=0;for(let Y=0;Y+1<M;Y+=2)z=k[Y]-R,N=k[Y+1]-X,k[Y]=E[0]*z+E[1]*N,k[Y+1]=E[3]*z+E[4]*N;return!0}extendRange(y,k){const M=this.float64Length,b=this._data;if(k)for(let E=0;E+1<M;E+=2)y.extendTransformedXY(k,b[E],b[E+1]);else for(let E=0;E+1<M;E+=2)y.extendXY(b[E],b[E+1])}sumLengths(){let y=0;const k=2*(this._xyInUse-1),M=this._data;for(let b=0;b<k;b+=2)y+=Q.hypotenuseXY(M[b+2]-M[b],M[b+3]-M[b+1]);return y}scaleInPlace(y){if(this._data){const k=this.float64Length;for(let M=0;M<k;M++)this._data[M]=this._data[M]*y}}interpolate(y,k,M,b){if(this.isIndexValid(y)&&this.isIndexValid(M)){const E=1-k,D=this._data;return y*=2,M*=2,H.create(E*D[y]+k*D[M],E*D[y+1]+k*D[M+1],b)}}areaXY(){let y=0;const k=2*this._xyInUse;if(k>4){const M=this._data[k-2],b=this._data[k-1];let E=this._data[0]-M,D=this._data[1]-b,R=0,X=0;for(let z=2;z<k;z+=2,E=R,D=X)R=this._data[z]-M,X=this._data[z+1]-b,y+=Q.crossProductXYXY(E,D,R,X)}return.5*y}vectorIndexIndex(y,k,M){if(!this.isIndexValid(y)||!this.isIndexValid(k))return;const b=this._data;return y*=2,k*=2,J.create(b[k]-b[y],b[k+1]-b[y+1],M)}vectorXAndYIndex(y,k,M){if(this.isIndexValid(k)){const b=this._data;return k*=2,J.create(b[k]-y.x,b[k+1]-y.y,M)}}crossProductIndexIndexIndex(y,k,M){if(this.isIndexValid(y)&&this.isIndexValid(k)&&this.isIndexValid(M)){const b=2*y,E=2*k,D=2*M,R=this._data;return Q.crossProductXYXY(R[E]-R[b],R[E+1]-R[b+1],R[D]-R[b],R[D+1]-R[b+1])}}crossProductXAndYIndexIndex(y,k,M){if(this.isIndexValid(k)&&this.isIndexValid(M)){const b=2*k,E=2*M,D=this._data;return Q.crossProductXYXY(D[b]-y.x,D[b+1]-y.y,D[E]-y.x,D[E+1]-y.y)}}distance(y,k){if(this.isIndexValid(y)&&this.isIndexValid(k)){const M=2*y,b=2*k;return Q.hypotenuseXY(this._data[b]-this._data[M],this._data[b+1]-this._data[M+1])}}distanceIndexToPoint(y,k){if(this.isIndexValid(y)){const M=2*y;return Q.hypotenuseXY(k.x-this._data[M],k.y-this._data[M+1])}}static isAlmostEqual(y,k){if(y&&k){if(y.length!==k.length)return!1;for(let M=0;M<y.length;M++)if(!y.getPoint2dAtUncheckedPointIndex(M).isAlmostEqual(k.getPoint2dAtUncheckedPointIndex(M)))return!1;return!0}return!y&&!k}sortIndicesLexical(){const y=this._xyInUse,k=new Uint32Array(y);for(let M=0;M<y;M++)k[M]=M;return k.sort(((y,k)=>this.compareLexicalBlock(y,k))),k}compareLexicalBlock(y,k){let M=0,b=0;for(let E=0;E<2;E++){if(M=this._data[2*y+E],b=this._data[2*k+E],M>b)return 1;if(M<b)return-1}return y-k}component(y,k){return this._data[2*y+k]}isAlmostEqual(y,k=Q.smallMetricDistance){const M=this._xyInUse;if(y._xyInUse!==M)return!1;const b=this._data,E=y._data;for(let D=0;D<2*M;D++)if(Math.abs(b[D]-E[D])>k)return!1;return!0}}function ke(y,k,M,b,E,D,R){const X=y.length;if(b>0){for(let z=M;z+1<X;z++)if(y.vectorIndexIndex(z,z+1,R),k.crossProduct(R,R),R.normalizeInPlace())return D.addScaledInPlace(R,E),D.isAlmostEqualXYZ(0,0,0,Q.smallFraction)&&R.scale(-E,D),!0}else{M+1>=X&&(M=X-2);for(let b=M;b>=0;b--)if(y.vectorIndexIndex(b,b+1,R),R.crossProduct(k,R),R.normalizeInPlace())return D.addScaledInPlace(R,E),D.isAlmostEqualXYZ(0,0,0,Q.smallFraction)&&R.scale(-E,D),!0}return!1}class Me extends ae{isSameGeometryClass(y){return y instanceof Me}get isExtensibleFractionSpace(){return!0}get points(){return this._points.getPoint3dArray()}get packedPoints(){return this._points}get fractions(){return this._fractions}get packedDerivatives(){return this._derivatives}get packedUVParams(){return this._uvParams}get packedSurfaceNormals(){return this._surfaceNormals}get normalIndices(){return this._normalIndices}get paramIndices(){return this._uvIndices}get pointIndices(){return this._pointIndices}constructor(y){super(),this.curvePrimitiveType="lineString",this._points=y||new nt}cloneTransformed(y){const k=this.clone();return k.tryTransformInPlace(y),k}static create(...y){const k=new Me;return k.addPoints(y),k}static createCapture(y){return new Me(y)}static createXY(y,k,M=!1){const b=new Me,E=b._points;for(const D of y)E.pushXYZ(D.x,D.y,k);if(M&&y.length>1){const y=E.distanceIndexIndex(0,E.length-1);if(void 0!==y&&0!==y&&Q.isSameCoordinate(0,y)){E.pop();const y=E.front();E.push(y)}}return b}addPoints(...y){this._points.pushFrom(y)}addSteppedPoints(y,k,M,b){this._points.addSteppedPoints(y,k,M,b)}addPoint(y){this._points.push(y)}addPointXYZ(y,k,M=0){this._points.pushXYZ(y,k,M)}addFraction(y){this._fractions||(this._fractions=new It),this._fractions.push(y)}ensureEmptyFractions(){const y=this.numPoints();return this._fractions?(this._fractions.clear(),this._fractions.ensureCapacity(y),this._fractions):(this._fractions=new It(y),this._fractions)}ensureEmptyUVParams(){const y=this.numPoints();return this._uvParams?(this._uvParams.clear(),this._uvParams.ensureCapacity(y),this._uvParams):(this._uvParams=new Fe(y),this._uvParams)}ensureEmptySurfaceNormals(){const y=this.numPoints();return this._surfaceNormals?(this._surfaceNormals.clear(),this._surfaceNormals.ensureCapacity(y),this._surfaceNormals):(this._surfaceNormals=new nt(y),this._surfaceNormals)}ensureEmptyDerivatives(){const y=this.numPoints();return this._derivatives?(this._derivatives.clear(),this._derivatives.ensureCapacity(y),this._derivatives):(this._derivatives=new nt(y),this._derivatives)}ensureEmptyNormalIndices(){const y=this.numPoints();return this._normalIndices?(this._normalIndices.clear(),this._normalIndices.ensureCapacity(y),this._normalIndices):(this._normalIndices=new It(y),this._normalIndices)}ensureEmptyUVIndices(){const y=this.numPoints();return this._uvIndices?(this._uvIndices.clear(),this._uvIndices.ensureCapacity(y),this._uvIndices):(this._uvIndices=new It(y),this._uvIndices)}ensureEmptyPointIndices(){const y=this.numPoints();return this._pointIndices?(this._pointIndices.clear(),this._pointIndices.ensureCapacity(y),this._pointIndices):(this._pointIndices=new It(y),this._pointIndices)}addUVParam(y){this._uvParams||(this._uvParams=new Fe),this._uvParams.pushXY(y.x,y.y)}addUVParamAsUV(y,k){this._uvParams||(this._uvParams=new Fe),this._uvParams.pushXY(y,k)}addDerivative(y){this._derivatives||(this._derivatives=new nt),this._derivatives.push(y)}addSurfaceNormal(y){this._surfaceNormals||(this._surfaceNormals=new nt),this._surfaceNormals.push(y)}addClosurePoint(){const y=this._points.distanceIndexIndex(0,this._points.length-1);void 0===y||Q.isSameCoordinate(y,0)||this._points.pushWrap(1)}popPoint(){this._points.pop()}computeUVFromXYZTransform(y){this._uvParams=Fe.createFromGrowableXYZArray(this._points,y)}static createRectangleXY(y,k,M,b=!0){const E=Me.create(),D=y.x,R=y.x+k,X=y.y,z=y.y+M,N=y.z;return E.addPointXYZ(D,X,N),E.addPointXYZ(R,X,N),E.addPointXYZ(R,z,N),E.addPointXYZ(D,z,N),b&&E.addClosurePoint(),E}static createRegularPolygonXY(y,k,M,b=!0){k<3&&(k=3);const E=Me.create(),D=b?0:-1,R=Math.PI/k;let X,z,N;b||(M/=Math.cos(R));for(let Y=0;Y<k;Y++)N=(D+2*Y)*R,X=W.cleanupTrigValue(Math.cos(N)),z=W.cleanupTrigValue(Math.sin(N)),E.addPointXYZ(y.x+M*X,y.y+M*z,y.z);return E.addClosurePoint(),E}setFrom(y){this._points=y._points.clone(this._points),y._derivatives?this._derivatives=y._derivatives.clone(this._derivatives):this._derivatives=void 0,y._fractions?this._fractions=y._fractions.clone(!1):this._fractions=void 0,y._surfaceNormals?this._surfaceNormals=y._surfaceNormals.clone(this._surfaceNormals):this._surfaceNormals=void 0,y._uvParams?this._uvParams=y._uvParams.clone():this._uvParams=void 0}static createPoints(y){const k=new Me;let M;for(M of y)k._points.push(M);return k}static createIndexedPoints(y,k,M=!1){const b=new Me;for(const E of k)b._points.push(y[E]);return M&&k.length>1&&b._points.push(y[k[0]]),b}static createFloat64Array(y){const k=new Me;for(let M=0;M+3<=y.length;M+=3)k._points.push(j.create(y[M],y[M+1],y[M+2]));return k}clone(){const y=new Me;return y.setFrom(this),y}setFromJSON(y){if(this._points.clear(),Array.isArray(y)){let k;for(k of y)this._points.push(j.fromJSON(k))}}toJSON(){const y=[];let k=0;for(;this._points.isIndexValid(k);)y.push(this._points.getPoint3dAtUncheckedPointIndex(k).toJSON()),k++;return y}static fromJSON(y){const k=new Me;return k.setFromJSON(y),k}fractionToPoint(y,k){const M=this._points.length;if(0===M)return j.createZero();if(1===M)return j.createFrom(this._points.getPoint3dAtUncheckedPointIndex(0),k);const b=1/(M-1);if(y<=b)return this._points.interpolate(0,y/b,1,k);if(y+b>=1)return this._points.interpolate(M-1,(1-y)/b,M-2,k);const E=Math.floor(y/b);return this._points.interpolate(E,(y-E*b)/b,E+1,k)}fractionToPointAndDerivative(y,k){k=k||bt.createZero();const M=this._points.length;if(M<=1)return k.direction.setZero(),1===M?k.origin.setFrom(this._points.getPoint3dAtUncheckedPointIndex(0)):k.origin.setZero(),k;const b=1/(M-1);if(y<=b)return k=k||bt.createZero(),this._points.interpolate(0,y/b,1,k.origin),this._points.vectorIndexIndex(0,1,k.direction),k.direction.scaleInPlace(1/b),k;if(y+b>=1)return k=k||bt.createZero(),this._points.interpolate(M-2,1-(1-y)/b,M-1,k.origin),this._points.vectorIndexIndex(M-2,M-1,k.direction),k.direction.scaleInPlace(1/b),k;k=k||bt.createZero();const E=Math.floor(y/b),D=(y-E*b)/b;return this._points.interpolate(E,D,E+1,k.origin),this._points.vectorIndexIndex(E,E+1,k.direction),k.direction.scaleInPlace(1/b),k}fractionToPointAnd2Derivatives(y,k){const M=this.fractionToPointAndDerivative(y);return Et.createCapture(M.origin,M.direction,$.createZero(),k)}static mapLocalToGlobalFraction(y,k,M){return M<1?0:(y+k)/M}segmentIndexAndLocalFractionToGlobalFraction(y,k){return Me.mapLocalToGlobalFraction(y,k,this._points.length-1)}static mapGlobalToLocalFraction(y,k){if(k<1)return{index:0,fraction:0};const M=y*k;let b;return b=y<=0?0:y>=1?k-1:Math.floor(M),{index:b,fraction:M-b}}globalFractionToSegmentIndexAndLocalFraction(y){return Me.mapGlobalToLocalFraction(y,this._points.length-1)}fractionToFrenetFrame(y,k){const M=this._points.length;if(M<=1)return 1===M?pt.createTranslation(this._points.getPoint3dAtUncheckedPointIndex(0),k):pt.createIdentity(k);if(2===M)return pt.createRefs(this._points.interpolate(0,y,1),xt.createRigidHeadsUp(this._points.vectorIndexIndex(0,1),E.XYZ));const b=M-1,D=1/b;let R=0,X=0;y<=D?(X=y/D,R=0):y+D>=1?(R=M-2,X=1-(1-y)/D):(R=Math.floor(y/D),X=y*b-R);const z=this._points.interpolate(R,X,R+1),N=this._points.vectorIndexIndex(R,R+1),Y=$.create(),O=$.create();0===R?ke(this._points,N,R+1,1,1,Y,O):R+2>=M?ke(this._points,N,R-1,-1,1,Y,O):(ke(this._points,N,R-1,-1,1-X,Y,O),ke(this._points,N,R+1,1,X,Y,O));const B=xt.createRigidFromColumns(Y,N,E.ZXY);return B?pt.createOriginAndMatrix(z,B,k):pt.createTranslation(z,k)}startPoint(){return 0===this._points.length?j.createZero():this._points.getPoint3dAtUncheckedPointIndex(0)}pointAt(y,k){if(this._points.isIndexValid(y))return this._points.getPoint3dAtUncheckedPointIndex(y,k)}vectorBetween(y,k,M){return this._points.vectorIndexIndex(y,k,M)}derivativeAt(y,k){if(this._derivatives&&this._derivatives.isIndexValid(y))return this._derivatives.getVector3dAtCheckedVectorIndex(y,k)}surfaceNormalAt(y,k){if(this._surfaceNormals&&this._surfaceNormals.isIndexValid(y))return this._surfaceNormals.getVector3dAtCheckedVectorIndex(y,k)}numPoints(){return this._points.length}numEdges(){return this._points.length>0?this._points.length-1:0}endPoint(){return 0===this._points.length?j.createZero():this._points.getPoint3dAtUncheckedPointIndex(this._points.length-1)}reverseInPlace(){this._points.length>=2&&(this._points.reverseInPlace(),this._uvParams&&this._uvParams.reverseInPlace())}tryTransformInPlace(y){return this._points.multiplyTransformInPlace(y),this._derivatives&&this._derivatives.multiplyMatrix3dInPlace(y.matrix),this._surfaceNormals&&this._surfaceNormals.multiplyAndRenormalizeMatrix3dInverseTransposeInPlace(y.matrix),!0}curveLength(){return this._points.sumLengths()}curveLengthBetweenFractions(y,k){const M=this._points.length-1;if(k===y||M<1)return 0;if(k<y)return this.curveLengthBetweenFractions(k,y);const b=y*M,E=k*M,D=Math.max(1,Math.ceil(b)),R=Math.min(Math.floor(E),M-1),X=D-b,z=E-R;if(D>R)return Math.abs(E-b)*this._points.distanceIndexIndex(D-1,D);{let y=X*this._points.distanceIndexIndex(D-1,D)+z*this._points.distanceIndexIndex(R,R+1);for(let k=D;k<R;k++)y+=this._points.distanceIndexIndex(k,k+1);return y}}rangeBetweenFractions(y,k,M){const b=ut.create();if(this.points.length<1)return b;if(k<y)return this.rangeBetweenFractions(k,y,M);const E=this._points.length-1,D=y*E,R=Math.max(0,Math.floor(D)),X=D-R,z=j.create();if(this._points.interpolate(R,X,R+1,z),b.extendPoint(z,M),k===y)return b;const N=k*E,Y=Math.min(Math.floor(N),E-1),O=N-Y;this._points.interpolate(Y,O,Y+1,z),b.extendPoint(z,M);for(let B=R+1;B<=Y;B++)this._points.getPoint3dAtUncheckedPointIndex(B,z),b.extendPoint(z,M);return b}moveSignedDistanceFromFraction(y,k,M,b){const E=this._points.length-1,D=y*E;let R=Q.restrictToInterval(Math.floor(D),0,E-1);const X=D-R,z=this._points.interpolate(R,X,R+1,Me._workPointA),N=Me._workPointB,Y=new be(z,y,k);if(k>0){for(;R<=E;)if(R++,this._points.getPoint3dAtCheckedPointIndex(R,N),Y.announcePoint(N,R/E))return vt.createCurveFractionPointDistanceCurveSearchStatus(this,Y.fraction0,Y.point0,k,B.success,b);return M&&Y.announceExtrapolation(this._points,E-1,E,(E-1)/E,1),vt.createCurveFractionPointDistanceCurveSearchStatus(this,Y.fraction0,Y.point0,k,Y.distanceStatus(),b)}for(X<=0&&R--;R>=0;R--)if(this._points.getPoint3dAtCheckedPointIndex(R,N),Y.announcePoint(N,R/E))return vt.createCurveFractionPointDistanceCurveSearchStatus(this,Y.fraction0,Y.point0,k,B.success,b);return M&&Y.announceExtrapolation(this._points,1,0,1/E,0),vt.createCurveFractionPointDistanceCurveSearchStatus(this,Y.fraction0,Y.point0,-Y.distance0,Y.distanceStatus(),b)}quickLength(){return this.curveLength()}quickUnitNormal(y){let k=Math.floor(this._points.length/3);if(k<1&&(k=1),(y=this._points.crossProductIndexIndexIndex(0,k,k+k))&&y.normalizeInPlace())return y}closestPoint(y,k,M){M=vt.create(this,M);const b=ie.resolveVariantCurveExtendParameterToCurveExtendMode(k,0),E=ie.resolveVariantCurveExtendParameterToCurveExtendMode(k,1),D=this._points.length;if(D>0){const k=D-1;if(M.setFP(1,this._points.getPoint3dAtUncheckedPointIndex(k),void 0),M.setDistanceTo(y),D>1){let R=0,X=0;for(let z=1;z<D;z++)R=y.fractionOfProjectionToLine(this._points.getPoint3dAtUncheckedPointIndex(z-1),this._points.getPoint3dAtUncheckedPointIndex(z)),R<0?(!b||z>1)&&(R=0):R>1&&(!E||z<k)&&(R=1),this._points.getPoint3dAtUncheckedPointIndex(z-1).interpolate(R,this._points.getPoint3dAtUncheckedPointIndex(z),M.pointQ),X=M.pointQ.distance(y),X<M.a&&M.setFP(this.segmentIndexAndLocalFractionToGlobalFraction(z-1,R),M.pointQ,void 0,X)}}return M}isInPlane(y){return this._points.isCloseToPlane(y,Q.smallMetricDistance)}static pushVertexHit(y,k,M,b,E){const D=vt.createCurveFractionPoint(M,b,E);y.push(D),0===k?D.setIntervalRole(O.isolatedAtVertex):1===k?(y[y.length-2].setIntervalRole(O.intervalStart),D.setIntervalRole(O.intervalEnd)):(y[y.length-2].setIntervalRole(O.intervalInterior),D.setIntervalRole(O.intervalEnd))}appendPlaneIntersectionPoints(y,k){if(this._points.length<1)return 0;const M=k.length,b=this._points.length,E=1===b?1:b-1,D=Me._workPointA,R=Me._workPointB,X=Me._workPointC;this._points.getPoint3dAtUncheckedPointIndex(0,D);let z=0,N=0,Y=0,B=0;for(let V=0;V<this._points.length;V++,D.setFrom(R),Y=z)if(this._points.getPoint3dAtUncheckedPointIndex(V,R),z=Q.correctSmallMetricDistance(y.altitude(R)),0===z)Me.pushVertexHit(k,N++,this,V/E,R);else if(Y*z<0){B=Y/(Y-z),D.interpolate(B,R,X);const y=vt.createCurveFractionPoint(this,(V-1+B)/E,X);y.setIntervalRole(O.isolated),k.push(y),N=0}return k.length-M}extendRange(y,k){this._points.extendRange(y,k)}isAlmostEqual(y){return y instanceof Me&&!!nt.isAlmostEqual(this._points,y._points)}appendStrokePoint(y,k){const M=this._points.length;let b=!0;const E=void 0!==k&&void 0!==this._fractions;M>0&&(E&&Q.isSameCoordinate(k,this._fractions.back())&&(b=!1),y.isAlmostEqual(this._points.getPoint3dAtUncheckedPointIndex(M-1))&&(b=!1)),b&&(this._points.push(y),E&&this.addFraction(k))}removeDuplicatePoints(y=Q.smallMetricDistance){const k=this._points.length;if(k<2)return;let M=1;for(let b=1;b<k;b++){const k=this._points.distanceIndexIndex(b,M-1);void 0!==k&&k>y&&(this._points.moveIndexToIndex(b,M),void 0!==this._fractions&&this._fractions.setAtUncheckedIndex(M,this._fractions.atUncheckedIndex(b)),this._derivatives&&this._derivatives.moveIndexToIndex(b,M),M++)}this._points.resize(M),this._fractions&&this._fractions.resize(M),this._derivatives&&this._derivatives.resize(M)}appendFractionToPoint(y,k){if(this._derivatives){const M=y.fractionToPointAndDerivative(k,Me._workRay);this._fractions&&this._fractions.push(k),this._points.push(M.origin),this._derivatives&&this._derivatives.push(M.direction)}else{const M=y.fractionToPoint(k,Me._workPointA);this._fractions&&this._fractions.push(k),this._points.push(M)}}clear(){this._points.clear(),this._fractions&&this._fractions.clear(),this._derivatives&&this._derivatives.clear()}static createForStrokes(y=0,k){const M=Me.create();return y>0&&M._points.ensureCapacity(y),k&&(k.needParams&&(M._fractions=new It(y),M._uvParams=new Fe(y)),k.needNormals&&(M._derivatives=new nt(y),M._surfaceNormals=new nt(y))),M}appendFractionalStrokePoints(y,k,M=0,b=1,E=!0){let D=1,R=k-1;if(E&&(D=0,R=k),k>=1){const E=(b-M)/k;for(let k=D;k<=R;k++)this.appendFractionToPoint(y,M+k*E)}}appendInterpolatedStrokePoints(y,k,M,b){if(b&&this.appendStrokePoint(k,0),y>1){const b=1/y;for(let E=1;E<y;E++){const y=E*b;this.appendStrokePoint(k.interpolate(y,M),y)}}b&&this.appendStrokePoint(M,1)}emitStrokes(y,k){const M=this._points.length,b=Me._workPointA,E=Me._workPointB;if(M>0)if(k&&k.hasMaxEdgeLength){y.appendStrokePoint(this._points.getPoint3dAtUncheckedPointIndex(0));for(let D=1;D<M;D++){this._points.getPoint3dAtUncheckedPointIndex(D-1,b),this._points.getPoint3dAtUncheckedPointIndex(D,E);const M=k.applyMaxEdgeLength(1,b.distance(E));M>1&&y.appendInterpolatedStrokePoints(M,b,E,!1),y.appendStrokePoint(E)}}else for(let D=0;D<M;D++)y.appendStrokePoint(this._points.getPoint3dAtUncheckedPointIndex(D))}emitStrokableParts(y,k){const M=this._points.length;if(y.startCurvePrimitive(this),M>1){const b=1/(M-1);if(k&&k.hasMaxEdgeLength)for(let E=1;E<M;E++){const M=k.applyMaxEdgeLength(1,this._points.getPoint3dAtUncheckedPointIndex(E-1).distance(this._points.getPoint3dAtUncheckedPointIndex(E)));y.announceSegmentInterval(this,this._points.getPoint3dAtUncheckedPointIndex(E-1),this._points.getPoint3dAtUncheckedPointIndex(E),M,(E-1)*b,E*b)}else for(let k=1;k<M;k++)y.announceSegmentInterval(this,this._points.getPoint3dAtUncheckedPointIndex(k-1),this._points.getPoint3dAtUncheckedPointIndex(k),1,(k-1)*b,k*b)}y.endCurvePrimitive(this)}computeStrokeCountForOptions(y){const k=this._points.length;let M=k-1;if(y&&y.hasMaxEdgeLength){M=0;for(let b=1;b<k;b++)M+=y.applyMaxEdgeLength(1,this._points.distanceIndexIndex(b-1,b))}return M}computeAndAttachRecursiveStrokeCounts(y,k){const M=this._points.length,b=void 0!==y&&y.hasMaxEdgeLength,E=Nt.createWithCurvePrimitiveAndOptionalParent(this,k,[]);for(let D=1;D<M;D++){const k=this._points.distanceIndexIndex(D-1,D),M=b?y.applyMaxEdgeLength(1,k):1;E.addToCountAndLength(M,k)}ae.installStrokeCountMap(this,E,k)}dispatchToGeometryHandler(y){return y.handleLineString3d(this)}announceClipIntervals(y,k){const M=this._points.length;if(M<2)return!1;let b=0,E=1;const r=(y,M)=>{k&&k(Q.interpolate(b,y,E),Q.interpolate(b,M,E),this)},D=Me._workPointA,R=Me._workPointB;this._points.getPoint3dAtUncheckedPointIndex(0,D);let X=!1;for(let z=1;z<M;z++,D.setFrom(R),b=E)this._points.getPoint3dAtUncheckedPointIndex(z,R),E=z/(M-1),y.announceClippedSegmentIntervals(0,1,D,R,r)&&(X=!0);return X}addResolvedPoint(y,k,M){const b=this._points.length;if(0!==b){if(1===b)return this._points.getPoint3dAtUncheckedPointIndex(0,Me._indexPoint),void M.push(Me._indexPoint);y<0&&(y=0),y>b-2&&(y=b-2,k+=1),this._points.interpolate(y,k,y+1,Me._indexPoint),M.push(Me._indexPoint)}}clonePartialCurve(y,k){if(k<y){const M=this.clonePartialCurve(k,y);return M&&M.reverseInPlace(),M}const M=this._points.length;if(M<2)return this.clone();let b,E;M>2&&this.isPhysicallyClosed&&(y<0&&(y=0),k>1&&(k=1));const D=this.globalFractionToSegmentIndexAndLocalFraction(y),R=this.globalFractionToSegmentIndexAndLocalFraction(k);b=y<0?1:0<=y&&y<=1?Q.isSmallRelative(1-D.fraction)?D.index+2:D.index+1:M,E=k<0?-1:0<=k&&k<=1?Q.isSmallRelative(R.fraction)?R.index-1:R.index:M-2;const X=Me.create();this.addResolvedPoint(D.index,D.fraction,X._points);for(let z=b;z<=E;z++)this._points.isIndexValid(z)&&(this._points.getPoint3dAtUncheckedPointIndex(z,Me._workPointA),X._points.push(Me._workPointA));return this.addResolvedPoint(R.index,R.fraction,X._points),X}getIndexedSegment(y,k){if(y>=0&&y+1<this._points.length)return Ce.create(this._points.getPoint3dAtCheckedPointIndex(y),this._points.getPoint3dAtCheckedPointIndex(y+1),k)}get isPhysicallyClosed(){return this._points.length>0&&Q.isSmallMetricDistance(this._points.distanceIndexIndex(0,this._points.length-1))}addMappedStrokesToLineString3D(y,k){const M=k.numPoints(),b=void 0!==k._fractions,E=void 0!==k._derivatives,D=this._points,R=Me._workPointA,X=Me._workPointB,z=Me._workPointC,N=D.length;if(y.primitive&&y.primitive===this&&y.componentData&&y.componentData.length+1===N){D.getPoint3dAtUncheckedPointIndex(0,R);for(let M=0;M+1<N;M++,R.setFromPoint3d(X)){D.getPoint3dAtUncheckedPointIndex(M+1,X);const N=y.componentData[M],Y=N.numStroke,O=R.vectorTo(X);O.scale(Y);for(let y=0;y<=Y;y++){const M=y/Y,D=N.fractionToA(M);k.addPoint(R.interpolate(M,X,z)),b&&k._fractions.push(D),E&&k._derivatives.push(O)}}}return k.numPoints()-M}static createArrayOfLineString3d(y){const k=new at;ht.streamXYZ(y,k);const M=k.claimArrayOfGrowableXYZArray(),b=[];if(void 0!==M)for(const E of M)b.push(Me.createCapture(E));return b}collectCurvePrimitivesGo(y,k,M=!1){if(M){let k;for(let M=0;void 0!==(k=this.getIndexedSegment(M));M++)y.push(k)}else y.push(this)}constructOffsetXY(y){const k=we.create(y),M=[];for(const b of this.collectCurvePrimitives(void 0,!0,!0)){const y=b.constructOffsetXY(k);void 0!==y&&(y instanceof ae?M.push(y):Array.isArray(y)&&y.forEach((y=>M.push(y))))}return M}projectedParameterRange(y,k){return Ee.findExtremeFractionsAlongDirection(this,y,k)}static convertLocalToGlobalDetail(y,k,M,b,E){return y.childDetail=y.clone(E),y.childDetail.a=k,y.fraction=this.mapLocalToGlobalFraction(k,y.fraction,M),y.curve=b,y}}Me._workPointA=j.create(),Me._workPointB=j.create(),Me._workPointC=j.create(),Me._workRay=bt.createXAxis(),Me._indexPoint=j.create();class be{constructor(y,k,M){this.point0=y,this.distance0=0,this.targetDistance=Math.abs(M),this.fraction0=k}distanceStatus(){return Q.isSameCoordinate(this.distance0,this.targetDistance)?B.success:B.stoppedAtBoundary}announcePoint(y,k){const M=this.point0.distance(y),b=this.distance0+M;if(b<this.targetDistance&&!Q.isSameCoordinate(b,this.targetDistance))return this.point0.setFromPoint3d(y),this.distance0=b,this.fraction0=k,!1;const E=this.targetDistance-this.distance0,D=Q.safeDivideFraction(E,M,0);return this.point0.interpolate(D,y,this.point0),this.fraction0=Q.interpolate(this.fraction0,D,k),this.distance0=this.targetDistance,!0}announceExtrapolation(y,k,M,b,E){const D=this.targetDistance-this.distance0,R=y.distanceIndexIndex(k,M);if(!R)return!1;const X=Q.conditionalDivideFraction(D,R);return void 0!==X&&(y.interpolate(M,-X,k,this.point0),this.distance0=this.targetDistance,this.fraction0=Q.interpolate(E,-X,b),!0)}}class Ee extends Ae{constructor(y){super(),this.plane=y,this.range=ft.createNull(),this.resetRange()}resetRange(){this.range.setNull()}announcePoint(y){const k=this.plane.altitude(y);this.range.extendLow(k)&&(this.lowPoint=y.clone(this.lowPoint)),this.range.extendHigh(k)&&(this.highPoint=y.clone(this.highPoint))}announcePoints(y){for(let k=0;k<y.length;k++){const M=y.evaluateUncheckedIndexPlaneAltitude(k,this.plane);this.range.extendLow(M)&&(this.lowPoint=y.getPoint3dAtUncheckedPointIndex(k,this.lowPoint)),this.range.extendHigh(M)&&(this.highPoint=y.getPoint3dAtUncheckedPointIndex(k,this.highPoint))}}static createCapture(y){return new Ee(y)}handleLineSegment3d(y){this.announcePoint(y.point0Ref),this.announcePoint(y.point1Ref)}handleLineString3d(y){this.announcePoints(y.packedPoints)}initStrokeOptions(){void 0===this._strokeOptions&&(this._strokeOptions=new Ie,this._strokeOptions.angleTol=W.createDegrees(1))}handleBSplineCurve3d(y){this.initStrokeOptions();const k=Me.create();y.emitStrokes(k,this._strokeOptions),this.handleLineString3d(k)}handleBSplineCurve3dH(y){this.initStrokeOptions();const k=Me.create();y.emitStrokes(k,this._strokeOptions),this.handleLineString3d(k)}handleArc3d(y){this._sineCosinePolynomial=y.getPlaneAltitudeSineCosinePolynomial(this.plane,this._sineCosinePolynomial);let k=this._sineCosinePolynomial.referenceMinMaxRadians();y.sweep.isRadiansInSweep(k)&&this.announcePoint(this._workPoint=y.radiansToPoint(k,this._workPoint)),k+=Math.PI,y.sweep.isRadiansInSweep(k)&&this.announcePoint(this._workPoint=y.radiansToPoint(k,this._workPoint)),this.announcePoint(this._workPoint=y.startPoint(this._workPoint)),this.announcePoint(this._workPoint=y.endPoint(this._workPoint))}static findExtremesInDirection(y,k){const M=k instanceof bt?k.origin:j.createZero(),b=k instanceof bt?k.direction:k,E=_t.create(M,b);if(E){const k=new Ee(E);if(y instanceof Ot)y.dispatchToGeometryHandler(k);else if(y instanceof nt)k.announcePoints(y);else for(const M of y)k.announcePoint(M);return k}}static findExtremePointsInDirection(y,k,M){const b=this.findExtremesInDirection(y,k);if(b&&b.highPoint&&b.lowPoint)return Ce.create(b.lowPoint,b.highPoint,M)}static findExtremeAltitudesInDirection(y,k,M){const b=this.findExtremesInDirection(y,k);if(b&&!b.range.isNull)return ft.createFrom(b.range,M)}static findExtremeFractionsAlongDirection(y,k,M){const b=this.findExtremeAltitudesInDirection(y,k,M);if(void 0!==b){const y=k instanceof $?k.magnitude():k.direction.magnitude(),M=Q.conditionalDivideCoordinate(1,y);if(void 0!==M)return b.low*=M,b.high*=M,b}}}class Re{constructor(y,k){this.x0=y,this.x1=k}set(y,k){this.x0=y,this.x1=k}shift(y){this.x0+=y,this.x1+=y}static create(y=0,k=1,M){return M?(M.set(y,k),M):new Re(y,k)}setFrom(y){this.x0=y.x0,this.x1=y.x1}clone(){return new Re(this.x0,this.x1)}get isIn01(){return Q.isIn01(this.x0)&&Q.isIn01(this.x1)}fractionToPoint(y){return Q.interpolate(this.x0,y,this.x1)}signedDelta(){return this.x1-this.x0}absoluteDelta(){return Math.abs(this.x1-this.x0)}reverseInPlace(){const y=this.x0;this.x0=this.x1,this.x1=y}reverseIfNeededForDeltaSign(y=1){y*(this.x1-this.x0)<0&&this.reverseInPlace()}isAlmostEqual(y){return Q.isSameCoordinate(this.x0,y.x0)&&Q.isSameCoordinate(this.x1,y.x1)}get isExact01(){return 0===this.x0&&1===this.x1}get isExact01Reversed(){return 1===this.x0&&0===this.x1}clipBy01FunctionValuesPositive(y,k){const M=k-y,b=y+this.x0*M,E=y+this.x1*M,D=E-b;if(b>0){if(E>=0)return!0;const y=-b/D;return this.x1=this.x0+y*(this.x1-this.x0),!0}if(b<0){if(E<0)return!1;const y=-b/D;return this.x0=this.x0+y*(this.x1-this.x0),!0}return E>0}clampDirectedTo01(y=!0,k=!0,M=!1){let b=this.x0,E=this.x1;if(E>b){if(b<0&&y&&(b=0),E>1&&k&&(E=1),b>E||b===E&&!M)return!1}else if(b>1&&k&&(b=1),E<0&&y&&(E=0),b<E||b===E&&!M)return!1;return this.set(b,E),!0}}class De{constructor(y,k){this._blockSize=y,this._order=Math.floor(k.length/y),this._packedData=k,this._basis=new Lt(this._order)}clonePolygon(y){const k=this._packedData.length;if(!y||y.length!==k)return this._packedData.slice();for(let M=0;M<k;M++)y[M]=this._packedData[M];return y}get order(){return this._order}get packedData(){return this._packedData}static create(y){if(!(y.length<1)){if(y[0]instanceof j){const k=new Float64Array(3*y.length);let M=0;for(const b of y)k[M++]=b.x,k[M++]=b.y,k[M++]=b.z;return new De(3,k)}if(y[0]instanceof Dt){const k=new Float64Array(4*y.length);let M=0;for(const b of y)k[M++]=b.x,k[M++]=b.y,k[M++]=b.z,k[M++]=b.w;return new De(4,k)}if(y[0]instanceof H){const k=new Float64Array(2*y.length);let M=0;for(const b of y)k[M++]=b.x,k[M++]=b.y;return new De(2,k)}}}evaluate(y,k){return this._basis.sumBasisFunctions(y,this._packedData,this._blockSize,k)}evaluateDerivative(y,k){return this._basis.sumBasisFunctionDerivatives(y,this._packedData,this._blockSize,k)}getPolygonPoint(y,k){if((!k||k.length<this._blockSize)&&(k=new Float64Array(this._blockSize)),y>=0&&y<this._order){const M=this._blockSize*y;for(let y=0;y<this._blockSize;y++)k[y]=this._packedData[M+y];return k}}setPolygonPoint(y,k){if(y>=0&&y<this._order){const M=this._blockSize*y;for(let y=0;y<this._blockSize;y++)this._packedData[M+y]=k[y]}}loadSpanPoles(y,k){let M=k*this._blockSize;for(let b=0;b<this._packedData.length;b++)this._packedData[b]=y[M++]}loadSpanPolesWithWeight(y,k,M,b){let E=0;const D=this._order;let R=M*k;for(let X=0;X<D;X++){for(let M=0;M<k;M++)this._packedData[E++]=y[R++];this._packedData[E++]=b}}unpackToJsonArrays(){return ue.unpackNumbersToNestedArrays(this._packedData,this._blockSize)}isAlmostEqual(y){if(y instanceof De){if(this._blockSize!==y._blockSize)return!1;if(this._order!==y._order)return!1;if(this._packedData.length!==y._packedData.length)return!1;for(let k=0;k<this._packedData.length;k++)if(!Q.isSameCoordinate(this._packedData[k],y._packedData[k]))return!1;return!0}return!1}reverseInPlace(){const y=this._blockSize;let k,M,b;for(k=0,M=(this._order-1)*y;k<M;k+=y,M-=y)for(let E=0;E<y;E++)b=this._packedData[k+E],this._packedData[k+E]=this._packedData[M+E],this._packedData[M+E]=b}interpolatePoleInPlace(y,k,M){let b=y*this._blockSize,E=M*this._blockSize;const D=this._packedData;for(let R=0;R<this._blockSize;R++,b++,E++)D[b]+=k*(D[E]-D[b])}saturateInPlace(y,k){const M=y.degree,b=k+M-1,E=b+1;if(k<0||k>=y.numSpans)return!1;const D=y.knots,R=D[b],X=D[E];if(this.setInterval(R,X),X<=R+ge.knotTolerance)return!1;for(let z=M-1;z>0;z--){let y=b-z;if(D[y]<R){let k=E;for(let M=0;M<z;M++,y++,k++){const b=D[y],E=(R-b)/(D[k]-b);this.interpolatePoleInPlace(M,E,M+1)}}}for(let z=M-1;z>0;z--){let y=E+z;if(D[y]>X)for(let k=0;k<z;k++,y--){const b=D[y],E=(X-b)/(R-b);this.interpolatePoleInPlace(M-k,E,M-k-1)}}return!0}static saturate1dInPlace(y,k,M){const b=k.degree,E=M+b-1,D=E+1;if(M<0||M>=k.numSpans)return!1;const R=k.knots,X=R[E],z=R[D];if(z<=X+ge.knotTolerance)return!1;for(let N=b-1;N>0;N--){let k=E-N;if(R[k]<X){let M=D;for(let b=0;b<N;b++,k++,M++){const E=R[k],D=(X-E)/(R[M]-E);y[b]=y[b]+D*(y[b+1]-y[b])}}}for(let N=b-1;N>0;N--){let k,M=D+N;if(R[M]>z)for(let E=0;E<N;E++,M--){const D=R[M],N=(z-D)/(X-D);k=b-E,y[k]+=N*(y[k-1]-y[k])}}return!0}subdivideInPlaceKeepLeft(y){if(Q.isAlmostEqualNumber(y,1))return!0;if(Q.isAlmostEqualNumber(y,0))return!1;const k=1-y,M=this.order;for(let b=1;b<M;b++)for(let y=M-1;y>=b;y--)this.interpolatePoleInPlace(y,k,y-1);return!0}subdivideInPlaceKeepRight(y){if(Q.isAlmostEqualNumber(y,0))return!0;if(Q.isAlmostEqualNumber(y,1))return!1;const k=this.order;for(let M=1;M<k;M++)for(let b=0;b+M<k;b++)this.interpolatePoleInPlace(b,y,b+1);return!0}subdivideToIntervalInPlace(y,k){return!Q.isAlmostEqualNumber(y,k)&&(k<y?(this.subdivideToIntervalInPlace(k,y),this.reverseInPlace(),!0):(this.subdivideInPlaceKeepLeft(k),this.subdivideInPlaceKeepRight(y/k),!0))}setInterval(y,k){this.interval=Re.create(y,k,this.interval)}fractionToParentFraction(y){return this.interval?this.interval.fractionToPoint(y):y}}class Xe extends ae{constructor(y,k){super(),this.curvePrimitiveType="bezierCurve",this._polygon=new De(y,k),this._workPoint0=j.create(),this._workPoint1=j.create(),this._workData0=new Float64Array(y),this._workData1=new Float64Array(y)}reverseInPlace(){this._polygon.reverseInPlace()}saturateInPlace(y,k){const M=this._polygon.saturateInPlace(y,k);return M&&this.setInterval(y.spanFractionToFraction(k,0),y.spanFractionToFraction(k,1)),M}get degree(){return this._polygon.order-1}get order(){return this._polygon.order}get numPoles(){return this._polygon.order}setInterval(y,k){this._polygon.setInterval(y,k)}fractionToParentFraction(y){return this._polygon.fractionToParentFraction(y)}emitStrokes(y,k){const M=this.computeStrokeCountForOptions(k),b=1/M;for(let E=0;E<=M;E++){const k=E*b;this.fractionToPoint(k,this._workPoint0),y.appendStrokePoint(this._workPoint0)}}emitStrokableParts(y,k){const M=this.computeStrokeCountForOptions(k);y.announceIntervalForUniformStepStrokes(this,M,0,1)}copyPolesAsJsonArray(){return this._polygon.unpackToJsonArrays()}isInPlane(y){let k=this._workPoint0;for(let M=0;;M++){if(k=this.getPolePoint3d(M,k),!k)return!0;if(!y.isPointInPlane(k))break}return!1}polygonLength(){if(!this.getPolePoint3d(0,this._workPoint0))return 0;let y=0,k=0;for(;this.getPolePoint3d(++y,this._workPoint1);)k+=this._workPoint0.distance(this._workPoint1),this._workPoint0.setFrom(this._workPoint1);return k}startPoint(){return this.getPolePoint3d(0)}endPoint(){return this.getPolePoint3d(this.order-1)}quickLength(){return this.polygonLength()}allocateAndZeroBezierWorkData(y,k,M){y>0&&(void 0!==this._workBezier&&this._workBezier.order===y?this._workBezier.zero():this._workBezier=new Lt(y)),k>0&&(void 0!==this._workCoffsA&&this._workCoffsA.length===k?this._workCoffsA.fill(0):this._workCoffsA=new Float64Array(k)),M>0&&(void 0!==this._workCoffsB&&this._workCoffsB.length===M?this._workCoffsB.fill(0):this._workCoffsB=new Float64Array(M))}computeStrokeCountForOptions(y){this.getPolePoint3d(0,this._workPoint0),this.getPolePoint3d(1,this._workPoint1);let k=1;if(this._workPoint0&&this._workPoint1){let M,b,E,D=this._workPoint1.x-this._workPoint0.x,R=this._workPoint1.y-this._workPoint0.y,X=this._workPoint1.z-this._workPoint0.z,z=0,N=Q.hypotenuseXYZ(D,R,X);this._workPoint1.setFromPoint3d(this._workPoint0);let Y,O=N,B=N,V=0;for(let y=2;this.getPolePoint3d(y,this._workPoint1);y++)M=this._workPoint1.x-this._workPoint0.x,b=this._workPoint1.y-this._workPoint0.y,E=this._workPoint1.z-this._workPoint0.z,Y=W.radiansBetweenVectorsXYZ(D,R,X,M,b,E),z+=Y,V=Q.maxAbsXY(Y,V),N=Q.hypotenuseXYZ(M,b,E),O+=N,B=Q.maxXY(B,N),D=M,R=b,X=E,this._workPoint0.setFrom(this._workPoint1);const U=B*this.degree,L=Math.sqrt(U*O);let Z=V*(this.degree-1);this.degree<3&&(Z*=3);const q=Math.sqrt(Z*z),jr=this.degree;k=Ie.applyAngleTol(y,Ie.applyMaxEdgeLength(y,jr,L),q,.1),y&&(k=y.applyChordTolToLengthAndRadians(k,O,Z))}return k}cloneTransformed(y){const k=this.clone();return k.tryTransformInPlace(y),k}constructOffsetXY(y){const k=we.create(y),M=new ye(this,k.leftOffsetDistance);return this.emitStrokableParts(M,k.strokeOptions),M.claimResult()}clonePartialCurve(y,k){const M=this.clone();return M._polygon.subdivideToIntervalInPlace(y,k),M}projectedParameterRange(y,k){return Ee.findExtremeFractionsAlongDirection(this,y,k)}}class ze extends Xe{isSameGeometryClass(y){return y instanceof ze}tryTransformInPlace(y){const k=this._workData0;for(let M=0;M<this._polygon.order;M++)this._polygon.getPolygonPoint(M,k),y.multiplyXYZToFloat64Array(k[0],k[1],k[2],k),this._polygon.setPolygonPoint(M,k);return!0}getPolePoint3d(y,k){const M=this._polygon.getPolygonPoint(y,this._workData0);if(M)return j.create(M[0],M[1],M[2],k)}getPolePoint4d(y,k){const M=this._polygon.getPolygonPoint(y,this._workData0);if(M)return Dt.create(M[0],M[1],M[2],1,k)}constructor(y){super(3,y),this._workRay0=bt.createXAxis(),this._workRay1=bt.createXAxis()}copyPointsAsLineString(){const y=Me.create();for(let k=0;k<this._polygon.order;k++)y.addPoint(this.getPolePoint3d(k));return y}static create(y){if(y.length<1)return;const k=new Float64Array(3*y.length);if(y[0]instanceof j){let M=0;for(const b of y)k[M++]=b.x,k[M++]=b.y,k[M++]=b.z;return new ze(k)}if(y[0]instanceof H){let M=0;for(const b of y)k[M++]=b.x,k[M++]=b.y,k[M++]=0;return new ze(k)}}static createOrder(y){const k=new Float64Array(3*y);return new ze(k)}loadSpanPoles(y,k){this._polygon.loadSpanPoles(y,k)}clone(){return new ze(this._polygon.clonePolygon())}fractionToPoint(y,k){return this._polygon.evaluate(y,this._workData0),j.create(this._workData0[0],this._workData0[1],this._workData0[2],k)}fractionToPointAndDerivative(y,k){return this._polygon.evaluate(y,this._workData0),this._polygon.evaluateDerivative(y,this._workData1),bt.createXYZUVW(this._workData0[0],this._workData0[1],this._workData0[2],this._workData1[0],this._workData1[1],this._workData1[2],k)}fractionToPointAnd2Derivatives(y,k){const M=1/2e-8;k||(k=Et.createXYPlane());const b=this.fractionToPointAndDerivative(y,this._workRay0);k.origin.setFrom(b.origin),k.vectorU.setFrom(b.direction);const E=this.fractionToPointAndDerivative(y-1e-8,this._workRay0),D=this.fractionToPointAndDerivative(y+1e-8,this._workRay1);return $.createAdd2Scaled(E.direction,-M,D.direction,M,k.vectorV),k}isAlmostEqual(y){return y instanceof ze&&this._polygon.isAlmostEqual(y._polygon)}dispatchToGeometryHandler(y){return y.handleBezierCurve3d(this)}extendRange(y,k){const M=this.order;if(k){this.allocateAndZeroBezierWorkData(M-1,M,0);const b=this._workBezier,E=this._workCoffsA;this.getPolePoint3d(0,this._workPoint0),y.extendTransformedPoint(k,this._workPoint0),this.getPolePoint3d(M-1,this._workPoint0),y.extendTransformedPoint(k,this._workPoint0);const D=this._polygon.packedData;for(let R=0;R<3;R++){for(let y=0,b=0;y<M;y++,b+=3)E[y]=k.multiplyComponentXYZ(R,D[b],D[b+1],D[b+2]);Vt.univariateDifference(E,b.coffs);const X=b.roots(0,!0);if(X&&X.length>0)for(const M of X)this.fractionToPoint(M,this._workPoint0),y.extendTransformedPoint(k,this._workPoint0)}}else{this.allocateAndZeroBezierWorkData(M-1,0,0);const k=this._workBezier;this.getPolePoint3d(0,this._workPoint0),y.extend(this._workPoint0),this.getPolePoint3d(M-1,this._workPoint0),y.extend(this._workPoint0);for(let b=0;b<3;b++){Vt.componentDifference(k.coffs,this._polygon.packedData,3,M,b);const E=k.roots(0,!0);if(E)for(const k of E)this.fractionToPoint(k,this._workPoint0),y.extend(this._workPoint0)}}}}class Ne extends Xe{isSameGeometryClass(y){return y instanceof Ne}tryTransformInPlace(y){const k=this._workData0;for(let M=0;M<this._polygon.order;M++)this._polygon.getPolygonPoint(M,k),y.multiplyXYZWToFloat64Array(k[0],k[1],k[2],k[3],k),this._polygon.setPolygonPoint(M,k);return!0}tryMultiplyMatrix4dInPlace(y){y.multiplyBlockedFloat64ArrayInPlace(this._polygon.packedData)}getPolePoint4d(y,k){const M=this._polygon.getPolygonPoint(y,this._workData0);if(M)return Dt.create(M[0],M[1],M[2],M[3],k)}getPolePoint3d(y,k){const M=this._polygon.getPolygonPoint(y,this._workData0);if(M)return j.createFromPackedXYZW(M,0,k)}isUnitWeight(y){void 0===y&&(y=Q.smallAngleRadians);const k=1-y,M=1+y,b=this._polygon.packedData,E=b.length;let D;for(let R=3;R<E;R+=4)if(D=b[R],D<k||D>M)return!1;return!0}constructor(y){super(4,y),this._workRay0=bt.createXAxis(),this._workRay1=bt.createXAxis()}static create(y){if(y.length<1)return;const k=new Float64Array(4*y.length);if(y[0]instanceof j){let M=0;for(const b of y)k[M++]=b.x,k[M++]=b.y,k[M++]=b.z,k[M++]=1;return new Ne(k)}if(y[0]instanceof Dt){let M=0;for(const b of y)k[M++]=b.x,k[M++]=b.y,k[M++]=b.z,k[M++]=b.w;return new Ne(k)}if(y[0]instanceof H){let M=0;for(const b of y)k[M++]=b.x,k[M++]=b.y,k[M++]=0,k[M++]=1;return new Ne(k)}}static createOrder(y){const k=new Float64Array(4*y);return new Ne(k)}loadSpan3dPolesWithWeight(y,k,M){this._polygon.loadSpanPolesWithWeight(y,3,k,M)}loadSpan4dPoles(y,k){this._polygon.loadSpanPoles(y,k)}clone(){return new Ne(this._polygon.clonePolygon())}fractionToPoint(y,k){return this._polygon.evaluate(y,this._workData0),(k=j.createFromPackedXYZW(this._workData0,0,k))||j.createZero()}fractionToPoint4d(y,k){return this._polygon.evaluate(y,this._workData0),(k=Dt.createFromPacked(this._workData0,0,k))||Dt.createZero()}fractionToPointAndDerivative(y,k){return this._polygon.evaluate(y,this._workData0),this._polygon.evaluateDerivative(y,this._workData1),(k=bt.createWeightedDerivative(this._workData0,this._workData1,k))||bt.createXAxis()}fractionToPointAnd2Derivatives(y,k){const M=1/2e-8;k||(k=Et.createXYPlane());const b=this.fractionToPointAndDerivative(y,this._workRay0);k.origin.setFrom(b.origin),k.vectorU.setFrom(b.direction);const E=this.fractionToPointAndDerivative(y-1e-8,this._workRay0),D=this.fractionToPointAndDerivative(y+1e-8,this._workRay1);return $.createAdd2Scaled(E.direction,-M,D.direction,M,k.vectorV),k}isAlmostEqual(y){return y instanceof Ne&&this._polygon.isAlmostEqual(y._polygon)}dispatchToGeometryHandler(y){return y.handleBezierCurve3dH(this)}poleProductsXYZW(y,k,M,b,E){const D=this.numPoles,R=this._polygon.packedData;for(let X=0,z=0;X<D;X++,z+=4)y[X]=k*R[z]+M*R[z+1]+b*R[z+2]+E*R[z+3]}updateClosestPointByTruePerpendicular(y,k,M=!1,b=!1){let E,D=0;if(this.isUnitWeight()){const k=2*this.order-2;this.allocateAndZeroBezierWorkData(k,0,0);const M=this._workBezier;Vt.accumulateScaledShiftedComponentTimesComponentDelta(M.coffs,this._polygon.packedData,4,this.order,1,0,-y.x,0),Vt.accumulateScaledShiftedComponentTimesComponentDelta(M.coffs,this._polygon.packedData,4,this.order,1,1,-y.y,1),Vt.accumulateScaledShiftedComponentTimesComponentDelta(M.coffs,this._polygon.packedData,4,this.order,1,2,-y.z,2),E=M.roots(0,!0)}else{const k=this.order,M=2*this.order-2,b=k+M-1;this.allocateAndZeroBezierWorkData(b,k,M);const D=this._workBezier,R=this._workCoffsA,X=this._workCoffsB,z=this._polygon.packedData;for(let E=0;E<3;E++){for(let y=0;y<R.length;y++)R[y]=0;for(let y=0;y<X.length;y++)X[y]=0;Vt.scaledComponentSum(R,z,4,k,3,y.at(E),E,-1),Vt.accumulateScaledShiftedComponentTimesComponentDelta(X,z,4,k,1,3,0,E),Vt.accumulateScaledShiftedComponentTimesComponentDelta(X,z,4,k,-1,E,0,3),Vt.accumulateProduct(D.coffs,R,X)}E=D.roots(0,!0)}if(E)for(const R of E){const M=this.fractionToPoint(R),b=M.distance(y);D+=k.updateIfCloserCurveFractionPointDistance(this,R,M,b)?1:0}return M&&(D+=this.updateDetailAtFraction(k,0,y)?1:0),b&&(D+=this.updateDetailAtFraction(k,1,y)?1:0),D>0}updateDetailAtFraction(y,k,M){const b=this.fractionToPoint(k),E=b.distance(M);return y.updateIfCloserCurveFractionPointDistance(this,k,b,E)}extendRange(y,k){const M=this.order;if(k){this.allocateAndZeroBezierWorkData(2*M-2,M,M);const b=this._workCoffsA,E=this._workCoffsB,D=this._workBezier;this.getPolePoint3d(0,this._workPoint0),y.extendTransformedPoint(k,this._workPoint0),this.getPolePoint3d(M-1,this._workPoint0),y.extendTransformedPoint(k,this._workPoint0);const R=this._polygon.packedData;let X;for(let z=0;z<3;z++){D.zero();for(let y=0,D=0;y<M;y++,D+=4)X=R[D+3],b[y]=k.multiplyComponentXYZW(z,R[D],R[D+1],R[D+2],X),E[y]=X;Vt.accumulateProductWithDifferences(D.coffs,b,E,1),Vt.accumulateProductWithDifferences(D.coffs,E,b,-1);const N=D.roots(0,!0);if(N&&N.length>0)for(const M of N)this.fractionToPoint(M,this._workPoint0),y.extendTransformedPoint(k,this._workPoint0)}}else{this.allocateAndZeroBezierWorkData(2*M-2,0,0);const k=this._workBezier,b=this._polygon.packedData;this.getPolePoint3d(0,this._workPoint0),y.extend(this._workPoint0),this.getPolePoint3d(M-1,this._workPoint0),y.extend(this._workPoint0);for(let E=0;E<3;E++){k.zero(),Vt.accumulateScaledShiftedComponentTimesComponentDelta(k.coffs,b,4,M,1,E,0,3),Vt.accumulateScaledShiftedComponentTimesComponentDelta(k.coffs,b,4,M,-1,3,0,E);const D=k.roots(0,!0);if(D)for(const k of D)this.fractionToPoint(k,this._workPoint0),y.extend(this._workPoint0)}}}}class Oe{get degree(){return this.knots.degree}get order(){return this.knots.degree+1}get numSpan(){return this.numPoles-this.knots.degree}get numPoles(){return this.packedData.length/this.poleLength}getPoint3dPole(y,k){return j.createFromPacked(this.packedData,y,k)}constructor(y,k,M,b){this.knots=b,this.packedData=new Float64Array(y*k),this.poleLength=k,this.basisBuffer=new Float64Array(M),this.poleBuffer=new Float64Array(k),this.basisBuffer1=new Float64Array(M),this.basisBuffer2=new Float64Array(M),this.poleBuffer1=new Float64Array(k),this.poleBuffer2=new Float64Array(k)}static create(y,k,M,b){return new Oe(y,k,M,b)}spanFractionToKnot(y,k){return this.knots.spanFractionToKnot(y,k)}evaluateBasisFunctionsInSpan(y,k,M,b,E){y<0&&(y=0),y>=this.numSpan&&(y=this.numSpan-1);const D=y+this.degree-1,R=this.knots.baseKnotFractionToKnot(D,k);return b?this.knots.evaluateBasisFunctions1(D,R,M,b,E):this.knots.evaluateBasisFunctions(D,R,M)}evaluateBuffersInSpan(y,k){this.evaluateBasisFunctionsInSpan(y,k,this.basisBuffer),this.sumPoleBufferForSpan(y)}evaluateBuffersInSpan1(y,k){this.evaluateBasisFunctionsInSpan(y,k,this.basisBuffer,this.basisBuffer1),this.sumPoleBufferForSpan(y),this.sumPoleBuffer1ForSpan(y)}sumPoleBufferForSpan(y){this.poleBuffer.fill(0);let k=y*this.poleLength;for(const M of this.basisBuffer)for(let y=0;y<this.poleLength;y++)this.poleBuffer[y]+=M*this.packedData[k++]}sumPoleBuffer1ForSpan(y){this.poleBuffer1.fill(0);let k=y*this.poleLength;for(const M of this.basisBuffer1)for(let y=0;y<this.poleLength;y++)this.poleBuffer1[y]+=M*this.packedData[k++]}sumPoleBuffer2ForSpan(y){this.poleBuffer2.fill(0);let k=y*this.poleLength;for(const M of this.basisBuffer2)for(let y=0;y<this.poleLength;y++)this.poleBuffer2[y]+=M*this.packedData[k++]}evaluateBuffersAtKnot(y,k=0){const M=this.knots.knotToLeftKnotIndex(y);k<1?(this.knots.evaluateBasisFunctions(M,y,this.basisBuffer),this.sumPoleBufferForSpan(M-this.degree+1)):1===k?(this.knots.evaluateBasisFunctions1(M,y,this.basisBuffer,this.basisBuffer1),this.sumPoleBufferForSpan(M-this.degree+1),this.sumPoleBuffer1ForSpan(M-this.degree+1)):(this.knots.evaluateBasisFunctions1(M,y,this.basisBuffer,this.basisBuffer1,this.basisBuffer2),this.sumPoleBufferForSpan(M-this.degree+1),this.sumPoleBuffer1ForSpan(M-this.degree+1),this.sumPoleBuffer2ForSpan(M-this.degree+1))}reverseInPlace(){const y=this.poleLength,k=this.packedData;for(let M=0,b=y*(this.numPoles-1);M<b;M+=y,b-=y){let E=0;for(let D=0;D<y;D++)E=k[M+D],k[M+D]=k[b+D],k[b+D]=E}this.knots.reflectKnots()}testCloseablePolygon(y){return this.testClosablePolygon(y)}testClosablePolygon(y){void 0===y&&(y=this.knots.wrappable);let k=0;if(y===L.OpenByAddingControlPoints)k=this.degree;else{if(y!==L.OpenByRemovingKnots)return!1;k=1}const M=this.poleLength,b=(this.numPoles-k)*M,E=k*M;for(let D=0;D<E;D++)if(!Q.isSameCoordinate(this.packedData[D],this.packedData[D+b]))return!1;return!0}addKnot(y,k){if(y<this.knots.leftKnot||y>this.knots.rightKnot)return!1;let M=this.knots.knotToLeftKnotIndex(y);if(Math.abs(y-this.knots.knots[M])<ge.knotTolerance)y=this.knots.knots[M];else if(Math.abs(y-this.knots.knots[M+1])<ge.knotTolerance){if(M+=this.knots.getKnotMultiplicityAtIndex(M+1),M>this.knots.rightKnotIndex)return!0;y=this.knots.knots[M]}const b=Math.min(k,this.degree)-this.knots.getKnotMultiplicity(y);if(b<=0)return!0;let E=this.knots.knots.length;const D=new Float64Array(E+b);for(let N=0;N<E;++N)D[N]=this.knots.knots[N];let R=this.numPoles;const X=new Float64Array(this.packedData.length+b*this.poleLength);for(let N=0;N<this.packedData.length;++N)X[N]=this.packedData[N];const z=new Float64Array(this.degree*this.poleLength);for(let N=0;N<b;++N){let k=0;const b=M-this.degree+2;for(let M=b;M<b+this.degree;++M){const b=(y-D[M-1])/(D[M+this.degree-1]-D[M-1]);for(let y=M*this.poleLength;y<(M+1)*this.poleLength;++y)z[k++]=Q.interpolate(X[y-this.poleLength],b,X[y])}X.copyWithin((b+this.degree)*this.poleLength,(b+this.degree-1)*this.poleLength,R*this.poleLength);let N=b*this.poleLength;for(const y of z)X[N++]=y;D.copyWithin(M+2,M+1,E),D[M+1]=y,++M,++E,++R}return this.knots.setKnotsCapture(D),this.packedData=X,!0}}class Ye extends ae{set definitionData(y){this._definitionData=y}get definitionData(){return this._definitionData}constructor(y,k,M,b){super(),this.curvePrimitiveType="bsplineCurve",this._bcurve=Oe.create(k,y,M,b)}get degree(){return this._bcurve.degree}get order(){return this._bcurve.order}get numSpan(){return this._bcurve.numSpan}get numPoles(){return this._bcurve.numPoles}get polesRef(){return this._bcurve.packedData}get knotsRef(){return this._bcurve.knots.knots}get poleDimension(){return this._bcurve.poleLength}copyKnots(y){return this._bcurve.knots.copyKnots(y)}getWrappable(){return this._bcurve.knots.wrappable}setWrappable(y){this._bcurve.knots.wrappable=y}get isClosableCurve(){const y=this._bcurve.knots.wrappable;return y===L.None?L.None:this._bcurve.knots.testClosable(y)&&this._bcurve.testClosablePolygon(y)?y:L.None}fractionToPoint(y,k){return this.knotToPoint(this._bcurve.knots.fractionToKnot(y),k)}fractionToPointAndDerivative(y,k){const M=this._bcurve.knots.fractionToKnot(y);return(k=this.knotToPointAndDerivative(M,k)).direction.scaleInPlace(this._bcurve.knots.knotLength01),k}fractionToPointAnd2Derivatives(y,k){const M=this._bcurve.knots.fractionToKnot(y);k=this.knotToPointAnd2Derivatives(M,k);const b=this._bcurve.knots.knotLength01;return k.vectorU.scaleInPlace(b),k.vectorV.scaleInPlace(b*b),k}startPoint(){return this.evaluatePointInSpan(0,0)}endPoint(){return this.evaluatePointInSpan(this.numSpan-1,1)}reverseInPlace(){this._bcurve.reverseInPlace()}collectBezierSpans(y){const k=[],M=this.numSpan;for(let b=0;b<M;b++)if(this._bcurve.knots.isIndexOfRealSpan(b)){const M=this.getSaturatedBezierSpan3dOr3dH(b,y);M&&k.push(M)}return k}poleIndexToDataIndex(y){if(y>=0&&y<this.numPoles)return y*this._bcurve.poleLength}closestPoint(y,k,M){const b=this.fractionToPoint(0);let E;M=vt.createCurveFractionPointDistance(this,0,b,b.distance(y),M);const D=this.numSpan;for(let R=0;R<D;R++)this._bcurve.knots.isIndexOfRealSpan(R)&&(E=this.getSaturatedBezierSpan3dOr3dH(R,!0,E),E&&E.updateClosestPointByTruePerpendicular(y,M,!1,!0)&&(M.curve=this,M.fraction=E.fractionToParentFraction(M.fraction)));return M}cloneTransformed(y){const k=this.clone();return k.tryTransformInPlace(y),k}clonePartialCurve(y,k){const M=this.clone(),b=M._bcurve.knots.knots.length;let E=M._bcurve.knots.fractionToKnot(y),D=M._bcurve.knots.fractionToKnot(k);if(M._bcurve.addKnot(E,M.degree),M._bcurve.addKnot(D,M.degree),b===M._bcurve.knots.knots.length)return M;if(E>D){const y=E;E=D,D=y}const R=M._bcurve.knots.knotToLeftKnotIndex(E)-M.degree+1,X=R*M._bcurve.poleLength,z=M._bcurve.knots.knotToLeftKnotIndex(D);let N=z-M._bcurve.knots.getKnotMultiplicityAtIndex(z)+1;M._bcurve.knots.knots[z]<D&&(N=z+1);const Y=(N+1)*M._bcurve.poleLength,O=N+M.degree;return M._bcurve.knots.setKnotsCapture(M._bcurve.knots.knots.slice(R,O)),M._bcurve.packedData=M._bcurve.packedData.slice(X,Y),M.setWrappable(L.None),M}appendPlaneIntersectionPoints(y,k){const M=this.numPoles,b=this.order,E=new Float64Array(M),D=this.numSpan,R=Dt.create(),X=ft.createNull();for(let O=0;O<M;O++)E[O]=y.weightedAltitude(this.getPolePoint4d(O,R)),X.extendX(E[O]);let z,N=0,Y=-1e3;if(X.containsX(0))for(let B=0;B<D;B++)if(this._bcurve.knots.isIndexOfRealSpan(B)&&(X.setNull(),X.extendArraySubset(E,B,b),X.containsX(0))){z=Lt.createArraySubset(E,B,b,z),De.saturate1dInPlace(z.coffs,this._bcurve.knots,B);const y=z.roots(0,!0);if(y)for(const M of y){N++;const y=this._bcurve.knots.spanFractionToFraction(B,M);if(!Q.isAlmostEqualNumber(y,Y)){const M=vt.createCurveEvaluatedFraction(this,y);M.intervalRole=O.isolated,k.push(M),Y=y}}}return N}constructOffsetXY(y){const k=we.create(y),M=new ye(this,k.leftOffsetDistance);return this.emitStrokableParts(M,k.strokeOptions),M.claimResult()}projectedParameterRange(y,k){return Ee.findExtremeFractionsAlongDirection(this,y,k)}}class Be extends Ye{initializeWorkBezier(){return void 0===this._workBezier&&(this._workBezier=ze.createOrder(this.order)),this._workBezier}isSameGeometryClass(y){return y instanceof Be}tryTransformInPlace(y){return ue.multiplyInPlace(y,this._bcurve.packedData),!0}getPolePoint3d(y,k){const M=this.poleIndexToDataIndex(y);if(void 0!==M){const y=this._bcurve.packedData;return j.create(y[M],y[M+1],y[M+2],k)}}getPolePoint4d(y,k){const M=this.poleIndexToDataIndex(y);if(void 0!==M){const y=this._bcurve.packedData;return Dt.create(y[M],y[M+1],y[M+2],1,k)}}spanFractionToKnot(y,k){return this._bcurve.spanFractionToKnot(y,k)}constructor(y,k,M){super(3,y,k,M)}copyPoints(){return ue.unpackNumbersToNestedArrays(this._bcurve.packedData,3)}copyPointsFloat64Array(){return this._bcurve.packedData.slice()}copyKnots(y){return this._bcurve.knots.copyKnots(y)}static createUniformKnots(y,k){const M=y instanceof Float64Array?y.length/3:y.length;if(k<2||M<k)return;const b=ge.createUniformClamped(M,k-1,0,1),E=new Be(M,k,b);if(y instanceof Float64Array)for(let D=0;D<3*M;D++)E._bcurve.packedData[D]=y[D];else if(y instanceof nt)E._bcurve.packedData=y.float64Data().slice(0,3*M);else{let k=0;for(const M of y)E._bcurve.packedData[k++]=M.x,E._bcurve.packedData[k++]=M.y,E._bcurve.packedData[k++]=M.z}return E}static createPeriodicUniformKnots(y,k){if(k<2)return;let M=y instanceof Float64Array?y.length/3:y.length;if(M<2)return;const b=j.createZero(),E=j.createZero();let D=!1;do{y instanceof Float64Array?(b.set(y[0],y[1],y[2]),E.set(y[3*M-3],y[3*M-2],y[3*M-1])):y instanceof nt?(y.getPoint3dAtUncheckedPointIndex(0,b),y.getPoint3dAtUncheckedPointIndex(M-1,E)):(b.setFromPoint3d(y[0]),E.setFromPoint3d(y[M-1])),(D=b.isAlmostEqual(E))&&--M}while(D&&M>1);if(M<k)return;const R=k-1,X=M,z=ge.createUniformWrapped(X,R,0,1);z.wrappable=L.OpenByAddingControlPoints;const N=new Be(M+R,k,z);if(y instanceof Float64Array){let k=0;for(let b=0;b<3*M;b++)N._bcurve.packedData[k++]=y[b];for(let M=0;M<3*R;M++)N._bcurve.packedData[k++]=y[M]}else if(y instanceof nt){let k=0;for(let b=0;b<3*M;b++)N._bcurve.packedData[k++]=y.float64Data()[b];for(let M=0;M<3*R;M++)N._bcurve.packedData[k++]=y.float64Data()[M]}else{let k=0;for(let b=0;b<M;b++)N._bcurve.packedData[k++]=y[b].x,N._bcurve.packedData[k++]=y[b].y,N._bcurve.packedData[k++]=y[b].z;for(let M=0;M<R;M++)N._bcurve.packedData[k++]=y[M].x,N._bcurve.packedData[k++]=y[M].y,N._bcurve.packedData[k++]=y[M].z}return N}static createFromInterpolationCurve3dOptions(y){return pe.createThroughPointsC2Cubic(y)}static createFromAkimaCurve3dOptions(y){return pe.createThroughPoints(y.fitPoints,4)}static create(y,k,M){if(M<2)return;let b=y.length;if(y instanceof Float64Array&&(b=Math.floor(b/3)),b<M)return;const E=k.length,D=b+M===E;if(!D&&b+M!==E+2)return;const R=ge.create(k,M-1,D),X=new Be(b,M,R);let z=0;if(y instanceof Float64Array)for(const N of y)X._bcurve.packedData[z++]=N;else if(y[0]instanceof j)for(const N of y)X._bcurve.packedData[z++]=N.x,X._bcurve.packedData[z++]=N.y,X._bcurve.packedData[z++]=N.z;else{if(!Array.isArray(y[0])||3!==y[0].length)return;for(const k of y)for(const y of k)X._bcurve.packedData[z++]=y}return X}clone(){const y=this._bcurve.knots.clone(),k=new Be(this.numPoles,this.order,y);return k._bcurve.packedData=this._bcurve.packedData.slice(),k}evaluatePointInSpan(y,k){return this._bcurve.evaluateBuffersInSpan(y,k),j.createFrom(this._bcurve.poleBuffer)}evaluatePointAndDerivativeInSpan(y,k){return this._bcurve.evaluateBuffersInSpan1(y,k),bt.createCapture(j.createFrom(this._bcurve.poleBuffer),$.createFrom(this._bcurve.poleBuffer1))}knotToPoint(y,k){return this._bcurve.evaluateBuffersAtKnot(y),j.createFrom(this._bcurve.poleBuffer,k)}knotToPointAndDerivative(y,k){return this._bcurve.evaluateBuffersAtKnot(y,1),k?(k.origin.setFrom(this._bcurve.poleBuffer),k.direction.setFrom(this._bcurve.poleBuffer1),k):bt.createCapture(j.createFrom(this._bcurve.poleBuffer),$.createFrom(this._bcurve.poleBuffer1))}knotToPointAnd2Derivatives(y,k){return this._bcurve.evaluateBuffersAtKnot(y,2),Et.createOriginAndVectorsXYZ(this._bcurve.poleBuffer[0],this._bcurve.poleBuffer[1],this._bcurve.poleBuffer[2],this._bcurve.poleBuffer1[0],this._bcurve.poleBuffer1[1],this._bcurve.poleBuffer1[2],this._bcurve.poleBuffer2[0],this._bcurve.poleBuffer2[1],this._bcurve.poleBuffer2[2],k)}isAlmostEqual(y){return y instanceof Be&&this._bcurve.knots.isAlmostEqual(y._bcurve.knots)&&ue.isAlmostEqual(this._bcurve.packedData,y._bcurve.packedData)}isInPlane(y){return ue.isCloseToPlane(this._bcurve.packedData,y)}quickLength(){return ue.sumEdgeLengths(this._bcurve.packedData)}emitStrokableParts(y,k){const M=void 0!==y.announceBezierCurve,b=this.initializeWorkBezier(),E=this.numSpan;let D;for(let R=0;R<E;R++){const E=this.getSaturatedBezierSpan3dOr3dH(R,!1,b);E&&(D=E.computeStrokeCountForOptions(k),M?y.announceBezierCurve(E,D,this,R,this._bcurve.knots.spanFractionToFraction(R,0),this._bcurve.knots.spanFractionToFraction(R,1)):y.announceIntervalForUniformStepStrokes(this,D,this._bcurve.knots.spanFractionToFraction(R,0),this._bcurve.knots.spanFractionToFraction(R,1)))}}computeStrokeCountForOptions(y){const k=this.initializeWorkBezier(),M=this.numSpan;let b=0;for(let E=0;E<M;E++){const M=this.getSaturatedBezierSpan3d(E,k);M&&(b+=M.computeStrokeCountForOptions(y))}return b}computeAndAttachRecursiveStrokeCounts(y,k){const M=this.initializeWorkBezier(),b=this.numSpan,E=Nt.createWithCurvePrimitiveAndOptionalParent(this,k,[]);for(let D=0;D<b;D++)if(this.getSaturatedBezierSpan3d(D,M)){const k=M.curveLength(),b=M.computeStrokeCountForOptions(y);E.addToCountAndLength(b,k)}ae.installStrokeCountMap(this,E,k)}emitStrokes(y,k){const M=this.initializeWorkBezier(),b=this.numSpan;for(let E=0;E<b;E++){const b=this.getSaturatedBezierSpan3d(E,M);b&&b.emitStrokes(y,k)}}get isClosable(){return this.isClosableCurve}getSaturatedBezierSpan3dOr3dH(y,k,M){return k?this.getSaturatedBezierSpan3dH(y,M):this.getSaturatedBezierSpan3d(y,M)}getSaturatedBezierSpan3d(y,k){if(y<0||y>=this.numSpan)return;const M=this.order;void 0!==k&&k instanceof ze&&k.order===M||(k=ze.createOrder(M));const b=k;return b.loadSpanPoles(this._bcurve.packedData,y),b.saturateInPlace(this._bcurve.knots,y)?k:void 0}getSaturatedBezierSpan3dH(y,k){if(y<0||y>=this.numSpan)return;const M=this.order;void 0!==k&&k instanceof Ne&&k.order===M||(k=Ne.createOrder(M));const b=k;return b.loadSpan3dPolesWithWeight(this._bcurve.packedData,y,1),b.saturateInPlace(this._bcurve.knots,y)?b:void 0}dispatchToGeometryHandler(y){return y.handleBSplineCurve3d(this)}extendRange(y,k){const M=this._bcurve.packedData,b=M.length-2;if(k)for(let E=0;E<b;E+=3)y.extendTransformedXYZ(k,M[E],M[E+1],M[E+2]);else for(let E=0;E<b;E+=3)y.extendXYZ(M[E],M[E+1],M[E+2])}}class Ve{}function Le(y){return y}function Ue(y,k,M){return Ze(k,(k=>M(y,k)))}function Ze(y,k){let M=0,b=y.length;for(;M<b;){const E=Math.floor((M+b)/2),D=k(y[E]);if(0===D)return{index:E,equal:!0};D<0?b=E:M=E+1}return{index:M,equal:!1}}Ve.oneMillimeter=.001,Ve.oneCentimeter=.01,Ve.oneMeter=1,Ve.oneKilometer=1e3,Ve.diameterOfEarth=12742*Ve.oneKilometer,Ve.circumferenceOfEarth=40075*Ve.oneKilometer,Ve.earthRadiusWGS84={polar:6356752.3142,equator:6378137},function(y){y[y.Allow=0]="Allow",y[y.Retain=1]="Retain",y[y.Replace=2]="Replace"}(Z||(Z={}));class qe{constructor(y,k=!1,M=Le){this._array=[],this._compare=y,this._clone=M,"boolean"==typeof k&&(k=k?Z.Allow:Z.Retain),this._duplicatePolicy=k}get length(){return this._array.length}get isEmpty(){return 0===this.length}[Symbol.iterator](){return this._array[Symbol.iterator]()}indexOf(y){const k=this.lowerBound(y);return k.equal?k.index:-1}contains(y){return-1!==this.indexOf(y)}findEqual(y){const k=this.indexOf(y);return-1!==k?this._array[k]:void 0}findEquivalent(y){const k=this.indexOfEquivalent(y);return-1!==k?this._array[k]:void 0}indexOfEquivalent(y){const k=Ze(this._array,(k=>0-y(k)));return k.equal?k.index:-1}get(y){return y<this.length?this._array[y]:void 0}forEach(y){for(let k=0;k<this.length;k++)y(this._array[k])}slice(y,k){const M=new qe(this._compare,this._duplicatePolicy,this._clone);return M._array=this._array.slice(y,k),M}lowerBound(y){return Ue(y,this._array,this._compare)}_clear(){this._array.length=0}_extractArray(){const y=this._array;return this._array=[],y}_insert(y,k){const M=this.lowerBound(y);if(M.equal)switch(this._duplicatePolicy){case Z.Retain:return M.index;case Z.Replace:return this._array[M.index]=this._clone(y),k&&k(y),M.index}return this._array.splice(M.index,0,this._clone(y)),void 0!==k&&k(y),M.index}_remove(y){const k=this.lowerBound(y);return k.equal?(this._array.splice(k.index,1),k.index):-1}}class We extends qe{constructor(y,k=!1,M=Le){super(y,k,M)}clear(){this._clear()}extractArray(){return this._extractArray()}insert(y,k){return this._insert(y,k)}remove(y){return this._remove(y)}slice(y,k){const M=new We(this._compare,this._duplicatePolicy,this._clone);return M._array=this._array.slice(y,k),M}}class Ge{constructor(y,k=Le){this._array=new We(y,!1,k)}get size(){return this._array.length}has(y){return-1!==this._array.indexOf(y)}[Symbol.iterator](){return this._array[Symbol.iterator]()}}class He extends Ge{constructor(y,k=Le){super(y,k)}clear(){this._array.clear()}add(y){return this._array.insert(y),this}delete(y){return-1!==this._array.remove(y)}}class Je{constructor(){}announceUnexpected(y,k){}announceCurvePrimitive(y,k=-1){}announcePath(y,k=-1){let M=0;for(const b of y.children)this.announceCurvePrimitive(b,M++)}announceLoop(y,k=-1){let M=0;for(const b of y.children)this.announceCurvePrimitive(b,M++)}announceParityRegion(y,k=-1){let M=0;for(const b of y.children)this.announceLoop(b,M++)}announceUnionRegion(y,k=-1){let M=0;for(const b of y.children)b.announceToCurveProcessor(this,M++)}announceBagOfCurves(y,k=-1){for(const M of y.children)M instanceof ae?this.announceCurvePrimitive(M):M.announceToCurveProcessor(this)}}class Qe extends Je{constructor(){super(),this._stack=[]}enter(y){this._stack.push(y)}leave(){return this._stack.pop()}announceUnexpected(y,k){}announceCurvePrimitive(y,k=-1){}announcePath(y,k=-1){this.enter(y),super.announcePath(y,k),this.leave()}announceLoop(y,k=-1){this.enter(y),super.announceLoop(y,k),this.leave()}announceParityRegion(y,k=-1){this.enter(y);let M=0;for(const b of y.children)this.announceLoop(b,M++);this.leave()}announceUnionRegion(y,k=-1){this.enter(y),super.announceUnionRegion(y,k),this.leave()}announceBagOfCurves(y,k=-1){this.enter(y);let M=0;for(const b of y.children)b instanceof ae?this.announceCurvePrimitive(b,M++):b.announceToCurveProcessor(this);this.leave()}}class Ke extends Qe{constructor(y){super(),this._transform=y,this._result=void 0}static clone(y,k){const M=new Ke(k);return y.announceToCurveProcessor(M),M._result}enter(y){y instanceof si&&super.enter(y.cloneEmptyPeer())}leave(){const y=super.leave();return y&&(0===this._stack.length?this._result=y:this._stack[this._stack.length-1].tryAddChild(y)),y}doClone(y){return this._transform?y.cloneTransformed(this._transform):y.clone()}announceCurvePrimitive(y,k){const M=this.doClone(y);if(void 0!==M&&this._stack.length>0){const y=this._stack[this._stack.length-1];if(y instanceof ni||y instanceof ri)if(Array.isArray(M))for(const k of M)y.tryAddChild(k);else y.tryAddChild(M)}}}class je extends Ke{constructor(){super(void 0)}doClone(y){if(y instanceof Me&&y.numPoints()>1){const k=y.packedPoints,M=k.length,b=[];for(let y=0;y+1<M;y++)b.push(Ce.createCapture(k.getPoint3dAtUncheckedPointIndex(y),k.getPoint3dAtUncheckedPointIndex(y+1)));return b}return y.clone()}static clone(y){const k=new je;return y.announceToCurveProcessor(k),k._result}}class $e extends Qe{constructor(){super(),this.numLineSegment=0,this.numLineString=0,this.numOther=0}static hasNonLinearPrimitives(y){const k=new $e;return y.announceToCurveProcessor(k),k.numOther>0}announceCurvePrimitive(y,k){y instanceof Ce?this.numLineSegment++:y instanceof Me?this.numLineString++:this.numOther++}}class ti extends Qe{constructor(){super(),this.maxGap=0}static maxGap(y){const k=new ti;return y.announceToCurveProcessor(k),k.maxGap}announceCurvePrimitive(y,k){if(this._stack.length>0){const M=this._stack[this._stack.length-1];if(M instanceof ni){const b=M.cyclicCurvePrimitive(k+1);void 0!==y&&void 0!==b&&(this.maxGap=Math.max(this.maxGap,y.endPoint().distance(b.startPoint())))}}}}class ei extends Je{constructor(){super(),this._sum=0}static sumLengths(y){const k=new ei;return y.announceToCurveProcessor(k),k._sum}announceCurvePrimitive(y,k){this._sum+=y.curveLength()}}class ii extends Je{constructor(y){super(),this.numFail=0,this.numOK=0,this.transform=y}static tryTransformInPlace(y,k){const M=new ii(k);return y.announceToCurveProcessor(M),0===M.numFail}announceCurvePrimitive(y,k){y.tryTransformInPlace(this.transform)?this.numOK++:this.numFail++}}class si extends Ot{constructor(){super(...arguments),this.geometryCategory="curveCollection",this.isInner=!1}sumLengths(){return ei.sumLengths(this)}closestPoint(y,k=!1,M){let b;const E=new vt;if(void 0!==this.children)for(const D of this.children)D.closestPoint(y,!1,E)&&(b=M=vt.chooseSmallerA(b,E).clone(M));return b}maxGap(){return ti.maxGap(this)}checkForNonLinearPrimitives(){return $e.hasNonLinearPrimitives(this)}tryTransformInPlace(y){return ii.tryTransformInPlace(this,y)}clone(){return Ke.clone(this)}cloneTransformed(y){return Ke.clone(this,y)}cloneWithExpandedLineStrings(){return je.clone(this)}collectCurvePrimitivesGo(y,k,M=!1){if(this.children)for(const b of this.children)(b instanceof ae||b instanceof si)&&b.collectCurvePrimitivesGo(y,k,M)}collectCurvePrimitives(y,k=!1,M=!1){const b=void 0===y?[]:y;return this.collectCurvePrimitivesGo(b,k,M),b}get isAnyRegionType(){return 2===this.dgnBoundaryType()||4===this.dgnBoundaryType()||5===this.dgnBoundaryType()}isAnyRegion(){return this.isAnyRegionType}get isOpenPath(){return 1===this.dgnBoundaryType()}isPath(){return this.isOpenPath}get isClosedPath(){return 2===this.dgnBoundaryType()}isLoop(){return this.isClosedPath}extendRange(y,k){const M=this.children;if(M)for(const b of M)b.extendRange(y,k)}static createCurveLocationDetailOnAnyCurvePrimitive(y,k=.5){if(y){if(y instanceof ae)return vt.createCurveEvaluatedFraction(y,k);if(y instanceof si&&void 0!==y.children)for(const M of y.children){const y=this.createCurveLocationDetailOnAnyCurvePrimitive(M,k);if(y)return y}}}projectedParameterRange(y,k){return Ee.findExtremeFractionsAlongDirection(this,y,k)}}class ni extends si{constructor(){super(),this._curves=[]}get children(){return this._curves}startPoint(y){const k=this.getChild(0);return k?k.fractionToPoint(0,y):void 0}endPoint(y){const k=this.getChild(this._curves.length-1);return k?k.fractionToPoint(1,y):void 0}cyclicCurvePrimitive(y,k=!0){const M=this.children.length;if(0!==M){if(y>=0&&y<M)return this.children[y];if(k){const k=Q.modulo(y,M);return this.children[k]}}}getPackedStrokes(y){const k=this.cloneStroked(y);if(k instanceof ni){const y=k.children;if(1===y.length){const k=y[0];if(k instanceof Me)return k.packedPoints}}}tryAddChild(y){return!!(y&&y instanceof ae)&&(this._curves.push(y),!0)}getChild(y){if(y<this._curves.length)return this._curves[y]}extendRange(y,k){for(const M of this._curves)M.extendRange(y,k)}reverseChildrenInPlace(){for(const y of this._curves)y.reverseInPlace();this._curves.reverse()}childIndex(y,k){for(let M=0;M<this._curves.length;M++)if(this._curves[M]===y)return M;if(k)for(let M=0;M<this._curves.length;M++){const k=this._curves[M];if(k instanceof me&&k.proxyCurve===y)return M}}primitiveIndexAndFractionToCurveLocationDetailPointAndDerivative(y,k,M=!1,b){const E=this.cyclicCurvePrimitive(y,M);if(E)return vt.createCurveEvaluatedFractionPointAndDerivative(E,k,b)}}class ri extends si{isSameGeometryClass(y){return y instanceof ri}constructor(){super(),this.curveCollectionType="bagOfCurves",this._children=[]}get children(){return this._children}static create(...y){const k=new ri;for(const M of y)k.tryAddChild(M);return k}dgnBoundaryType(){return 0}announceToCurveProcessor(y,k=-1){return y.announceBagOfCurves(this,k)}cloneStroked(y){const k=new ri;let M;for(M of this.children)if(M instanceof ae){const b=Me.create();M.emitStrokes(b,y),b&&k.children.push(b)}else if(M instanceof si){const b=M.cloneStroked(y);b&&k.children.push(b)}return k}closestPoint(y,k=!1,M){let b;const E=new vt;if(void 0!==this.children)for(const D of this.children)D.closestPoint(y,k,E)&&(b=M=vt.chooseSmallerA(b,E).clone(M));return b}cloneEmptyPeer(){return new ri}tryAddChild(y){return y&&this._children.push(y),!0}getChild(y){if(y<this._children.length)return this._children[y]}dispatchToGeometryHandler(y){return y.handleBagOfCurves(this)}}class oi extends ni{isSameGeometryClass(y){return y instanceof oi}announceToCurveProcessor(y,k=-1){return y.announcePath(this,k)}constructor(){super(),this.curveCollectionType="path"}static create(...y){const k=new oi;for(const M of y)M instanceof li?k.children.push(...M.path.children):M instanceof ae?k.children.push(M):Array.isArray(M)&&M.length>0&&M[0]instanceof j&&k.children.push(Me.create(M));return k}static createArray(y){return this.create(...y)}cloneStroked(y){const k=Me.create();for(const M of this.children)M.emitStrokes(k,y);return oi.create(k)}closestPoint(y,k=!1,M){let b;const E=new vt;if(void 0!==this.children)for(let D=0;D<this.children.length;D++){const R=this.children[D],X=0===D?ie.resolveVariantCurveExtendParameterToCurveExtendMode(k,0):U.None,z=D===this.children.length-1?ie.resolveVariantCurveExtendParameterToCurveExtendMode(k,1):U.None;R.closestPoint(y,[X,z],E)&&(b=M=vt.chooseSmallerA(b,E).clone(M))}return b}dgnBoundaryType(){return 1}cloneEmptyPeer(){return new oi}dispatchToGeometryHandler(y){return y.handlePath(this)}}class ai{constructor(y,k,M,b,E,D){this.childFraction0=y,this.childFraction1=k,this.chainDistance0=M,this.chainDistance1=b,this.childCurve=E,this.range=D,this.a=0}containsChainDistance(y){return y>=this.chainDistance0&&y<=this.chainDistance1}quickMinDistanceToChildCurve(y){if(this.range)return this.range.distanceToPoint(y);const k=this.childCurve.closestPoint(y,!1);return k?k.a:0}static collectSortedQuickMinDistances(y,k){const M=[];for(const b of y)b.a=b.quickMinDistanceToChildCurve(k),M.push(b);return M.sort(((y,k)=>y.a-k.a)),M}containsChildCurveAndChildFraction(y,k){return this.childCurve===y&&k>=this.childFraction0&&k<=this.childFraction1}chainDistanceToInterpolatedChildFraction(y){return Q.inverseInterpolate(this.childFraction0,this.chainDistance0,this.childFraction1,this.chainDistance1,y,this.childFraction0)}chainDistanceToAccurateChildFraction(y,k){return this.childCurve.moveSignedDistanceFromFraction(this.childFraction0,y-this.chainDistance0,k??!1).fraction}fractionScaleFactor(y){return y*(this.childFraction1-this.childFraction0)/(this.chainDistance1-this.chainDistance0)}reverseFractionsAndDistances(y){const k=this.childFraction0,M=this.childFraction1,b=this.chainDistance0,E=this.chainDistance1;this.childFraction0=1-M,this.childFraction1=1-k,this.chainDistance0=y-E,this.chainDistance1=y-b}childFractionTChainDistance(y){return this.childFractionToChainDistance(y)}childFractionToChainDistance(y){let k=this.childCurve.curveLengthBetweenFractions(this.childFraction0,y);return y<this.childFraction0&&(k=-k),this.chainDistance0+k}}class ci{constructor(){this._accumulatedDistance=0,this._fragments=[]}startParentCurvePrimitive(y){}startCurvePrimitive(y){}endParentCurvePrimitive(y){}endCurvePrimitive(y){}announcePointTangent(y,k,M){}announceSegmentInterval(y,k,M,b,E,D){const R=k.clone(),X=M.clone();let z=this._accumulatedDistance;if(b<=1)this._accumulatedDistance+=k.distance(M),this._fragments.push(new ai(E,D,z,this._accumulatedDistance,y,ut.create(R,X)));else{let N;for(let Y=1,O=E;Y<=b;Y++,O=N)N=Q.interpolate(E,Y/b,D),k.interpolate(N,M,X),z=this._accumulatedDistance,this._accumulatedDistance+=Math.abs(N-O)*k.distance(M),this._fragments.push(new ai(O,N,z,this._accumulatedDistance,y,ut.create(R,X))),R.setFrom(X)}}announceIntervalForUniformStepStrokes(y,k,M,b){let E,D,R;for(let X=1,z=M;X<=k;X++,z=E){E=Q.interpolate(M,X/k,b),D=y.curveLengthBetweenFractions(z,E),R=this._accumulatedDistance,this._accumulatedDistance+=D;const N=y.rangeBetweenFractions(z,E);this._fragments.push(new ai(z,E,R,this._accumulatedDistance,y,N))}}needPrimaryGeometryForStrokes(){return!0}static createPathFragmentIndex(y,k){const M=new ci;for(const b of y.children)b.emitStrokableParts(M,k);return M._fragments}}class li extends ae{isSameGeometryClass(y){return y instanceof li}constructor(y,k){super(),this.curvePrimitiveType="curveChainWithDistanceIndex",this._path=y instanceof oi?y:oi.create(...y.children),this._fragments=k,this._totalLength=k.length>0?k[k.length-1].chainDistance1:0}cloneTransformed(y,k){const M=this._path.clone();if(M.tryTransformInPlace(y))return li.createCapture(M,k)}get path(){return this._path}get fragments(){return this._fragments}clone(y){const k=this._path.clone();return li.createCapture(k,y)}clonePartialCurve(y,k,M){const b=y instanceof vt,E=k instanceof vt;let D=b?y.fraction:y,R=E?k.fraction:k;if(D===R)return;const X=D>R;X&&([D,R]=[R,D]);const z=D*this._totalLength,N=R*this._totalLength,Y=this.chainDistanceToFragment(z,!0);if(void 0===Y)return;const O=this.chainDistanceToFragment(N,!0);if(void 0===O)return;const B=this._path.childIndex(Y.childCurve,!0);if(void 0===B)return;const V=this._path.childIndex(O.childCurve,!0);if(void 0===V)return;const U=b&&y.childDetail?y.childDetail.fraction:Y.chainDistanceToAccurateChildFraction(z,!0),L=E&&k.childDetail?k.childDetail.fraction:O.chainDistanceToAccurateChildFraction(N,!0),Z=oi.create(),x=(y,k,M,b)=>{if(k===M)return!1;let E;return 0===k&&1===M?(E=y.clone(),b&&E.reverseInPlace()):E=b?y.clonePartialCurve(M,k):y.clonePartialCurve(k,M),!!E&&(Z.children.push(E),!0)};if(Y.childCurve===O.childCurve)return x(Y.childCurve,U,L,X)?li.createCapture(Z,M):void 0;x(this._path.children[B],U,1,X);for(let q=B+1;q<V;q++)x(this._path.children[q],0,1,X);return x(this._path.children[V],0,L,X),X&&Z.children.reverse(),li.createCapture(Z,M)}isInPlane(y){for(const k of this._path.children)if(!k.isInPlane(y))return!1;return!0}startPoint(y){const k=this._path.cyclicCurvePrimitive(0);return k?k.startPoint(y):j.createZero(y)}endPoint(y){const k=this._path.cyclicCurvePrimitive(-1);return k?k.endPoint(y):j.createZero(y)}emitStrokes(y,k){for(const M of this._path.children)M.emitStrokes(y,k)}emitStrokableParts(y,k){for(const M of this._path.children)M.emitStrokableParts(y,k)}computeStrokeCountForOptions(y){let k=0;for(const M of this._path.children)k+=M.computeStrokeCountForOptions(y);return k}collectCurvePrimitivesGo(y,k=!1,M=!1){if(k)for(const b of this._path.children)b.collectCurvePrimitivesGo(y,k,M);else y.push(this)}computeAndAttachRecursiveStrokeCounts(y,k){const M=Nt.createWithCurvePrimitiveAndOptionalParent(this,k);for(const b of this._path.children)b.computeAndAttachRecursiveStrokeCounts(y,M);ae.installStrokeCountMap(this,M,k)}dispatchToGeometryHandler(y){return y.handleCurveChainWithDistanceIndex(this)}extendRange(y,k){this._path.extendRange(y,k)}curveLengthBetweenFractions(y,k){return Math.abs(k-y)*this._totalLength}static flattenNestedChains(y){if(-1===y.children.findIndex((y=>y instanceof li)))return y;const k=y.clone(),M=k.children.flatMap((y=>y instanceof li?y.path.children:[y]));return k.children.splice(0,1/0,...M),k}static createCapture(y,k){y=this.flattenNestedChains(y);const M=ci.createPathFragmentIndex(y,k);return new li(y,M)}chainDistanceToFragment(y,k=!1){const M=this.chainDistanceToFragmentIndex(y,k);if(void 0!==M)return this._fragments[M]}chainDistanceToFragmentIndex(y,k=!1){const M=this._fragments.length,b=this._fragments;if(M>0){if(y<0)return k?0:void 0;if(y>this._totalLength)return k?M-1:void 0;for(let k=0;k<M;k++)if(b[k].containsChainDistance(y))return k}}chainDistanceToChainFraction(y){return y/this._totalLength}curveAndChildFractionToFragment(y,k){const M=this._fragments.length,b=this._fragments;if(M>0){if(k<0)return b[0];if(k>1)return b[M-1];for(const M of b)if(M.containsChildCurveAndChildFraction(y,k))return M}}curveLength(){return this._totalLength}quickLength(){return this._totalLength}fractionToPoint(y,k){const M=y*this._totalLength,b=this.chainDistanceToFragment(M,!0);if(b){const y=b.chainDistanceToAccurateChildFraction(M,!0);return b.childCurve.fractionToPoint(y,k)}return e(),this._fragments[0].childCurve.fractionToPoint(0,k)}fractionToPointAndDerivative(y,k){const M=y*this._totalLength,b=this.chainDistanceToFragment(M,!0),E=b.chainDistanceToAccurateChildFraction(M,!0);k=b.childCurve.fractionToPointAndDerivative(E,k);const D=this._totalLength/k.direction.magnitude();return k.direction.scaleInPlace(D),k}fractionToPointAndUnitTangent(y,k){const M=y*this._totalLength,b=this.chainDistanceToFragment(M,!0),E=b.chainDistanceToAccurateChildFraction(M,!0);return(k=b.childCurve.fractionToPointAndDerivative(E,k)).direction.normalizeInPlace(),k}fractionToPointAnd2Derivatives(y,k){const M=y*this._totalLength,b=this.chainDistanceToFragment(M,!0),E=b.chainDistanceToAccurateChildFraction(M,!0);if(!(k=b.childCurve.fractionToPointAnd2Derivatives(E,k)))return;const D=k.vectorU.magnitude(),R=D*D,X=k.vectorU.dotProduct(k.vectorV);k.vectorV.addScaledInPlace(k.vectorU,-X/R);const z=this._totalLength/D;return k.vectorU.scaleInPlace(z),k.vectorV.scaleInPlace(z*z),k}tryTransformInPlace(y){let k=0;for(const M of this._path.children)M.tryTransformInPlace(y)||k++;return 0===k}reverseInPlace(){this._path.reverseChildrenInPlace();for(const y of this._fragments)y.reverseFractionsAndDistances(this._totalLength);this._fragments.reverse()}isAlmostEqual(y){return y instanceof li&&Q.isSameCoordinate(this._totalLength,y._totalLength)&&this._path.isAlmostEqual(y._path)}moveSignedDistanceFromFraction(y,k,M,b){const E=y*this._totalLength+k,D=this.chainDistanceToFragment(E,!0),R=D.childCurve.moveSignedDistanceFromFraction(D.childFraction0,E-D.chainDistance0,M,b?.childDetail),X=y+k/this._totalLength,z=vt.createConditionalMoveSignedDistance(M,this,y,X,k,b);return z.childDetail=R,z}static getClosestPointTestCounts(y=!0){const k={numCalls:this._numCalls,numTested:this._numTested,numAssigned:this._numAssigned,numCandidate:this._numCandidate};return y&&(this._numTested=this._numAssigned=this._numCandidate=0),k}closestPoint(y,k,M){let b,E=Number.MAX_VALUE;if(1===this.path.children.length)b=this.path.children[0].closestPoint(y,k);else{const M=ai.collectSortedQuickMinDistances(this._fragments,y),D=[ie.resolveVariantCurveExtendParameterToCurveExtendMode(k,0),U.None],R=[U.None,ie.resolveVariantCurveExtendParameterToCurveExtendMode(k,1)],X=this._fragments[0],z=this._fragments[this._fragments.length-1];let N;li._numCalls++,li._numCandidate+=M.length;for(const k of M){if(k.a>E)break;li._numTested++,N=k.childCurve.closestPoint(y,k===X?D:k===z&&R,N),N&&N.a<E&&(E=N.a,b=N.clone(b),li._numAssigned++)}}if(b)return this.computeChainDetail(b,M)}constructOffsetXY(y){const k=we.create(y),M=[];for(const b of this.collectCurvePrimitives(void 0,!0,!0)){const y=b.constructOffsetXY(k);void 0!==y&&(y instanceof ae?M.push(y):Array.isArray(y)&&y.forEach((y=>M.push(y))))}return M}projectedParameterRange(y,k){return Ee.findExtremeFractionsAlongDirection(this,y,k)}computeChainDetail(y,k){if(!y.curve)return;const M=this.curveAndChildFractionToFragment(y.curve,y.fraction);if(M){const b=M.childFractionToChainDistance(y.fraction),E=this.chainDistanceToChainFraction(b),D=vt.createCurveFractionPoint(this,E,y.point,k);return D.childDetail=y,D.a=y.a,D}}static convertChildDetailToChainDetail(y,k,M,b,E){for(let D=k;D<y.length;++D){const k=y[D];if(M){const y=M.computeChainDetail(k.detailA);y&&(k.detailA=y)}if(b){const y=b.computeChainDetail(k.detailB);y&&(k.detailB=y)}}return E&&(y=Pt.removeAdjacentDuplicates(y,k)),y}}li._numCalls=0,li._numTested=0,li._numAssigned=0,li._numCandidate=0;class hi extends ni{isSameGeometryClass(y){return y instanceof hi}constructor(){super(),this.curveCollectionType="loop",this.isInner=!1}static create(...y){const k=new hi;for(const M of y)M instanceof li?k.children.push(...M.path.children):k.children.push(M);return k}static createArray(y){return this.create(...y)}static createPolygon(y){const k=Me.create(y);return k.addClosurePoint(),hi.create(k)}cloneStroked(y){const k=Me.create();for(const M of this.children)M.emitStrokes(k,y);return k.removeDuplicatePoints(),k.isPhysicallyClosed&&(k.popPoint(),k.addClosurePoint()),hi.create(k)}dgnBoundaryType(){return 2}announceToCurveProcessor(y,k=-1){return y.announceLoop(this,k)}cloneEmptyPeer(){return new hi}dispatchToGeometryHandler(y){return y.handleLoop(this)}}class di{constructor(y,k,M,b){this.loopA=y,this.curveA=k,this.loopB=M,this.curveB=b}setA(y,k){this.loopA=y,this.curveA=k}setB(y,k){this.loopB=y,this.curveB=k}}class ui extends Ae{setGeometryB(y){this._geometryB=y}constructor(y){super(),this.setGeometryB(y),this._maxDistanceSquared=Q.smallMetricDistanceSquared,this._results=[]}set maxDistanceToAccept(y){this._maxDistanceToAccept=y,void 0!==this._maxDistanceToAccept&&this._maxDistanceToAccept>0&&(this._maxDistanceSquared=this._maxDistanceToAccept*this._maxDistanceToAccept)}get maxDistanceToAccept(){return this._maxDistanceToAccept}get isMaxDistanceSet(){return void 0!==this._maxDistanceToAccept&&this._maxDistanceToAccept>0}resetGeometry(y){this.setGeometryB(y)}acceptFraction(y,k=1e-12){return!(y<-k||y>1+k)}grabPairedResults(y=!1){const k=this._results;return y&&(this._results=[]),k}testAndRecordPointPairApproach(y,k,M,b,E,D,R){if(M.distanceSquaredXY(D)<this._maxDistanceSquared){const X=vt.createCurveFractionPoint(y,k,M),z=vt.createCurveFractionPoint(b,E,D),N=Pt.createCapture(X,z);R&&N.swapDetails(),this._results.push(N)}}recordPointWithLocalFractions(y,k,M,b,E,D,R,X,z,N){let Y,B,V,U;const L=void 0!==N&&N.detailA.hasFraction1&&N.detailB.hasFraction1;L?(Y=Q.interpolate(M,N.detailA.fraction,b),B=Q.interpolate(R,N.detailB.fraction,X),V=Q.interpolate(M,N.detailA.fraction1,b),U=Q.interpolate(R,N.detailB.fraction1,X)):(Y=V=Q.interpolate(M,y,b),B=U=Q.interpolate(R,E,X));const Z=this._results.length;if(Z>0&&!L){const y=this._results[Z-1].detailA,M=this._results[Z-1].detailB;if(z){if(M.isSameCurveAndFraction({curve:k,fraction:Y})&&y.isSameCurveAndFraction({curve:D,fraction:B}))return}else if(y.isSameCurveAndFraction({curve:k,fraction:Y})&&M.isSameCurveAndFraction({curve:D,fraction:B}))return}const q=vt.createCurveFractionPoint(k,Y,k.fractionToPoint(Y)),jr=vt.createCurveFractionPoint(D,B,D.fractionToPoint(B));if(L)q.captureFraction1Point1(V,k.fractionToPoint(V)),jr.captureFraction1Point1(U,D.fractionToPoint(U));else{if(q.point.distanceSquaredXY(jr.point)>this._maxDistanceSquared)return;q.setIntervalRole(O.isolated),jr.setIntervalRole(O.isolated)}z?this._results.push(new Pt(jr,q)):this._results.push(new Pt(q,jr))}capturePairWithLocalFractions(y,k,M,b,E,D,R,X){const z=Q.interpolate(M,y.detailA.fraction,b),N=Q.interpolate(D,y.detailB.fraction,R),Y=this._results.length;if(Y>0){const y=this._results[Y-1].detailA,M=this._results[Y-1].detailB;if(X){if(M.isSameCurveAndFraction({curve:k,fraction:z})&&y.isSameCurveAndFraction({curve:E,fraction:N}))return}else if(y.isSameCurveAndFraction({curve:k,fraction:z})&&M.isSameCurveAndFraction({curve:E,fraction:N}))return}vt.createCurveEvaluatedFraction(k,z,y.detailA),vt.createCurveEvaluatedFraction(E,N,y.detailB),y.detailA.setIntervalRole(O.isolated),y.detailB.setIntervalRole(O.isolated),X&&y.swapDetails(),this._results.push(y)}recordPairs(y,k,M,b){if(void 0!==M)for(const E of M)this.recordPointWithLocalFractions(E.detailA.fraction,y,0,1,E.detailB.fraction,k,0,1,b,E)}captureDetailPair(y,k,M){y&&k&&(M?this._results.push(Pt.createCapture(k,y)):this._results.push(Pt.createCapture(y,k)))}static updatePointToSegmentDistance(y,k,M,b,E,D,R){let X=!1;E<0?E=0:E>1&&(E=1),this._workPointB=M.interpolate(E,b,this._workPointB);const z=this._workPointB.distanceSquaredXY(k);return z<=Math.min(D,R.detailA.a)&&(R.detailA.setFP(y,k,void 0,z),R.detailB.setFP(E,this._workPointB,void 0,z),X=!0),X}static segmentSegmentBoundedApproach(y,k,M,b,E){const D=k.x-y.x,R=k.y-y.y,X=b.x-M.x,z=b.y-M.y,N=M.x-y.x,Y=M.y-y.y,O=b.x-y.x,B=b.y-y.y,V=M.x-k.x,U=M.y-k.y,L=Q.crossProductXYXY(D,R,N,Y),Z=Q.crossProductXYXY(D,R,O,B),q=-Q.crossProductXYXY(X,z,N,Y),jr=-Q.crossProductXYXY(X,z,V,U);if(L*Z<0&&q*jr<0){const E=-q/(jr-q),D=-L/(Z-L);return Pt.createCapture(vt.createCurveFractionPoint(void 0,E,y.interpolate(E,k)),vt.createCurveFractionPoint(void 0,D,M.interpolate(D,b)))}const Gr=new Pt;Gr.detailA.a=2*E;let Jr=!1;const Kr=Q.hypotenuseSquaredXY(D,R);if(L*L<=E*Kr){const b=Q.dotProductXYXY(D,R,N,Y)/Kr;this.updatePointToSegmentDistance(0,M,y,k,b,E,Gr)&&(Jr=!0)}if(Z*Z<=E*Kr){const M=Q.dotProductXYXY(D,R,O,B)/Kr;this.updatePointToSegmentDistance(1,b,y,k,M,E,Gr)&&(Jr=!0)}const so=Q.hypotenuseSquaredXY(X,z);if(q*q<=E*so){const k=-Q.dotProductXYXY(X,z,N,Y)/so;this.updatePointToSegmentDistance(0,y,M,b,k,E,Gr)&&(Jr=!1)}if(jr*jr<=E*so){const y=-Q.dotProductXYXY(X,z,V,U)/so;this.updatePointToSegmentDistance(1,k,M,b,y,E,Gr)&&(Jr=!1)}if(!(Gr.detailA.a>E))return Jr&&Gr.swapDetails(),Gr}testAndRecordFractionalPairApproach(y,k,M,b,E,D,R,X,z){const N=y.fractionToPoint(k),Y=y.fractionToPoint(M),O=E.fractionToPoint(D),B=E.fractionToPoint(R);this.testAndRecordPointPairApproach(y,k,N,E,D,O,z),this.testAndRecordPointPairApproach(y,M,Y,E,D,O,z),this.testAndRecordPointPairApproach(y,k,N,E,R,B,z),this.testAndRecordPointPairApproach(y,M,Y,E,R,B,z),X&&(this.testAndRecordProjection(y,k,N,E,D,R,z),this.testAndRecordProjection(y,M,Y,E,D,R,z)),b&&(this.testAndRecordProjection(E,D,O,y,k,M,!z),this.testAndRecordProjection(E,R,B,y,k,M,!z))}getPointCurveClosestApproachXYNewton(y,k){y instanceof Ti||y instanceof Ce||e();const M=[.2,.4,.6,.8],b=new jt(y,k),E=new Wt(b,100);let D,R,X=Q.largeCoordinateResult;for(const z of M)if(E.setX(z),E.runIterations()){const M=E.getX();if(this.acceptFraction(M)){const b=y.fractionToPoint(M),E=b.distanceSquaredXY(k);E<X&&(X=E,D=M,R=b)}}if(D&&R)return vt.createCurveFractionPoint(y,D,R)}testAndRecordProjection(y,k,M,b,E,D,R){let X;if(b instanceof Me){const y=b.globalFractionToSegmentIndexAndLocalFraction(E<=D?E:D),k=y.fraction<.999999?y.index:y.index+1,R=b.getIndexedSegment(k);R&&(X=this.getPointCurveClosestApproachXYNewton(R,M))&&Me.convertLocalToGlobalDetail(X,k,b.numEdges(),b)}else X=this.getPointCurveClosestApproachXYNewton(b,M);X&&Q.restrictToInterval(X.fraction,E,D)===X.fraction&&this.testAndRecordPointPairApproach(y,k,M,b,X.fraction,X.point,R)}computeSegmentSegment3D(y,k,M,b,E,D,R,X,z,N,Y){const O=ui.segmentSegmentBoundedApproach(k,b,R,z,this._maxDistanceSquared);O&&(O.detailA.setCurve(y),O.detailB.setCurve(D),this.capturePairWithLocalFractions(O,y,M,E,D,X,N,Y))}dispatchSegmentSegment(y,k,M,b,E,D,R,X,z,N,Y){this.computeSegmentSegment3D(y,k,M,b,E,D,R,X,z,N,Y)}allPerpendicularsSegmentArcBounded(y,k,M,b,E,D,R=!1){const X=D.vector0.crossProductStartEndXY(k,b),z=D.vector90.crossProductStartEndXY(k,b),N=Math.atan2(z,X);for(const Y of[N,N+Math.PI]){const X=D.radiansToPoint(Y),z=D.sweep.radiansToSignedPeriodicFraction(Y);if(this.acceptFraction(z)){const N=Mt.lineSegment3dXYClosestPointUnbounded(k,b,X);void 0!==N&&this.acceptFraction(N)&&this.recordPointWithLocalFractions(N,y,M,E,z,D,0,1,R)}}}dispatchSegmentArc(y,k,M,b,E,D,R){let X=!1;const z=D.toTransformedVectors(),N=k,Y=b,O=Q.tripleProductXYW(N,1,Y,1,z.center,1),B=Q.tripleProductXYW(N,1,Y,1,z.vector0,0),V=Q.tripleProductXYW(N,1,Y,1,z.vector90,0),U=new It(2),L=new It(2),Z=new It(2),q=wt.appendImplicitLineUnitCircleIntersections(O,B,V,U,L,Z);for(let jr=0;jr<q;jr++){const k=z.center.plus2Scaled(z.vector0,U.atUncheckedIndex(jr),z.vector90,L.atUncheckedIndex(jr)),b=z.sweep.radiansToSignedPeriodicFraction(Z.atUncheckedIndex(jr)),O=Mt.lineSegment3dXYClosestPointUnbounded(N,Y,k);void 0!==O&&this.acceptFraction(O)&&this.acceptFraction(b)&&(this.recordPointWithLocalFractions(O,y,M,E,b,D,0,1,R),X=!0)}X||(this.testAndRecordFractionalPairApproach(y,M,E,!0,D,0,1,!0,R),this.allPerpendicularsSegmentArcBounded(y,k,M,b,E,D,R))}allPerpendicularsArcArcBounded(y,k,M=!1){const b=new $t(y,k),E=new Qt(b,100);for(let D=.05;D<1;D+=.1)for(let b=.05;b<1;b+=.1)if(E.setUV(D,b),E.runIterations()){const b=E.getU(),D=E.getV();this.acceptFraction(b)&&this.acceptFraction(D)&&this.recordPointWithLocalFractions(b,y,0,1,D,k,0,1,M)}}dispatchArcArc(y,k,M){const b=y.range(),E=k.range();b.expandInPlace(this._maxDistanceToAccept),E.intersectsRangeXY(b)&&(this.testAndRecordFractionalPairApproach(y,0,1,!0,k,0,1,!0,M),this.allPerpendicularsArcArcBounded(y,k,M))}dispatchArcBsplineCurve3d(y,k,M){const b=Me.create();k.emitStrokes(b),this.computeArcLineString(y,b,M)}dispatchBSplineCurve3dBSplineCurve3d(y,k,M){const b=Me.create();y.emitStrokes(b);const E=Me.create();k.emitStrokes(E),this.computeLineStringLineString(b,E,M)}dispatchLineStringBSplineCurve(y,k,M){const b=Me.create();k.emitStrokes(b),this.computeLineStringLineString(y,b,M)}dispatchSegmentBsplineCurve(y,k,M){const b=Me.create();k.emitStrokes(b),this.computeSegmentLineString(y,b,M)}computeSegmentLineString(y,k,M){const b=k.numPoints(),E=Q.safeDivideFraction(1,b-1,0),D=y.point0Ref,R=y.point1Ref,X=ui._workPointBB0,z=ui._workPointBB1;for(let N=0;N<b-1;++N){const Y=N*E,O=N+1===b-1?1:(N+1)*E;k.packedPoints.getPoint3dAtUncheckedPointIndex(N,X),k.packedPoints.getPoint3dAtUncheckedPointIndex(N+1,z),this.dispatchSegmentSegment(y,D,0,R,1,k,X,Y,z,O,M)}}computeArcLineString(y,k,M){const b=y.range(),E=k.range();if(b.expandInPlace(this._maxDistanceToAccept),!E.intersectsRangeXY(b))return;const D=ui._workPointBB0,R=ui._workPointBB1,X=k.numPoints();if(X>1){const b=1/(X-1);let E,z;E=0,k.pointAt(0,D);for(let N=1;N<X;N++,D.setFrom(R),E=z)k.pointAt(N,R),z=N*b,this.dispatchSegmentArc(k,D,E,R,z,y,!M)}}dispatchCurveCollection(y,k){const M=this._geometryB;if(M&&M.children&&M instanceof si){for(const b of M.children)this.resetGeometry(b),k(y);this._geometryB=M}}dispatchCurveChainWithDistanceIndex(y,k){if(!(this._geometryB&&this._geometryB instanceof li))return;y instanceof li&&e();const M=this._results.length,b=this._geometryB;for(const E of b.path.children)this.resetGeometry(E),k(y);this.resetGeometry(b),this._results=li.convertChildDetailToChainDetail(this._results,M,void 0,b,!0)}handleLineSegment3d(y){if(this._geometryB instanceof Ce){const k=this._geometryB;this.dispatchSegmentSegment(y,y.point0Ref,0,y.point1Ref,1,k,k.point0Ref,0,k.point1Ref,1,!1)}else this._geometryB instanceof Me?this.computeSegmentLineString(y,this._geometryB,!1):this._geometryB instanceof Ti?this.dispatchSegmentArc(y,y.point0Ref,0,y.point1Ref,1,this._geometryB,!1):this._geometryB instanceof Be?this.dispatchSegmentBsplineCurve(y,this._geometryB,!1):this._geometryB instanceof si?this.dispatchCurveCollection(y,this.handleLineSegment3d.bind(this)):this._geometryB instanceof li&&this.dispatchCurveChainWithDistanceIndex(y,this.handleLineSegment3d.bind(this))}classifyBitsPointRangeXY(y,k,M){let b=0;return y<M.low.x?b=1:y>M.high.x&&(b=2),k<M.low.y?b|=4:k>M.high.y&&(b|=8),b}computeLineStringLineString(y,k,M){const b=y.range(),E=k.range();if(b.expandInPlace(this._maxDistanceToAccept),!E.intersectsRangeXY(b))return;let D,R;const X=ut.createNull(),z=ui._workPointAA0,N=ui._workPointAA1,Y=ui._workPointBB0,O=ui._workPointBB1,B=y.numPoints(),V=k.numPoints();if(B>1&&V>1){const b=1/(B-1),U=1/(V-1);let L,Z,q,jr=0;y.pointAt(0,z);for(let Gr=1;Gr<B;Gr++,z.setFrom(N),jr=L)if(L=Gr*b,Z=0,y.pointAt(Gr,N),X.setNull(),X.extendPoint(z),X.extendPoint(N),X.expandInPlace(this._maxDistanceToAccept),X.intersectsRangeXY(E)){k.pointAt(0,Y),D=this.classifyBitsPointRangeXY(Y.x,Y.y,X);for(let b=1;b<V;b++,Y.setFrom(O),Z=q,D=R)k.pointAt(b,O),R=this.classifyBitsPointRangeXY(O.x,O.y,X),q=b*U,D&R||this.dispatchSegmentSegment(y,z,jr,N,L,k,Y,Z,O,q,M)}}}handleLineString3d(y){if(this._geometryB instanceof Me){const k=this._geometryB;this.computeLineStringLineString(y,k,!1)}else this._geometryB instanceof Ce?this.computeSegmentLineString(this._geometryB,y,!0):this._geometryB instanceof Ti?this.computeArcLineString(this._geometryB,y,!0):this._geometryB instanceof Be?this.dispatchLineStringBSplineCurve(y,this._geometryB,!1):this._geometryB instanceof si?this.dispatchCurveCollection(y,this.handleLineString3d.bind(this)):this._geometryB instanceof li&&this.dispatchCurveChainWithDistanceIndex(y,this.handleLineString3d.bind(this))}handleArc3d(y){this._geometryB instanceof Ce?this.dispatchSegmentArc(this._geometryB,this._geometryB.point0Ref,0,this._geometryB.point1Ref,1,y,!0):this._geometryB instanceof Me?this.computeArcLineString(y,this._geometryB,!1):this._geometryB instanceof Ti?this.dispatchArcArc(y,this._geometryB,!1):this._geometryB instanceof Be?this.dispatchArcBsplineCurve3d(y,this._geometryB,!1):this._geometryB instanceof si?this.dispatchCurveCollection(y,this.handleArc3d.bind(this)):this._geometryB instanceof li&&this.dispatchCurveChainWithDistanceIndex(y,this.handleArc3d.bind(this))}handleBSplineCurve3d(y){this._geometryB instanceof Ce?this.dispatchSegmentBsplineCurve(this._geometryB,y,!0):this._geometryB instanceof Me?this.dispatchLineStringBSplineCurve(this._geometryB,y,!0):this._geometryB instanceof Ti?this.dispatchArcBsplineCurve3d(this._geometryB,y,!0):this._geometryB instanceof Ye?this.dispatchBSplineCurve3dBSplineCurve3d(y,this._geometryB,!1):this._geometryB instanceof si?this.dispatchCurveCollection(y,this.handleBSplineCurve3d.bind(this)):this._geometryB instanceof li&&this.dispatchCurveChainWithDistanceIndex(y,this.handleBSplineCurve3d.bind(this))}handleCurveChainWithDistanceIndex(y){super.handleCurveChainWithDistanceIndex(y),this._results=li.convertChildDetailToChainDetail(this._results,0,y,void 0,!0)}handleBSplineCurve3dH(y){}}function fi(y,k){return Q.isAlmostEqualNumber(y,k,Q.smallFraction)?0:y<k?-1:1}function gi(y,k){return Q.isAlmostEqualNumber(y,k,Q.smallFraction)?0:y<k?1:-1}ui._workPointAA0=j.create(),ui._workPointAA1=j.create(),ui._workPointBB0=j.create(),ui._workPointBB1=j.create(),ui._workPointB=j.create();class pi{constructor(y,k,M,b){this._quadrant=y,this._fractions=k,this._interpolateStartTangent=M,this._interpolateEndTangent=b,this._averageAdded=!1}static create(y,k=[],M=!0,b=!0){return new pi(y,k,M,b)}get quadrant(){return this._quadrant}get fractions(){return this._fractions}set fractions(y){this._fractions=y}get interpolateStartTangent(){return this._interpolateStartTangent}set interpolateStartTangent(y){this._interpolateStartTangent=y}get interpolateEndTangent(){return this._interpolateEndTangent}set interpolateEndTangent(y){this._interpolateEndTangent=y}get averageAdded(){return 3===this._fractions.length&&this._averageAdded}set averageAdded(y){this._averageAdded=y}static getQuadrantRadians(y,k){return At.isRadiansInStartEnd(y,0,W.piOver2Radians)&&At.isRadiansInStartEnd(k,0,W.piOver2Radians)?{quadrant:1,angle0:0,angle1:W.piOver2Radians}:At.isRadiansInStartEnd(y,W.piOver2Radians,W.piRadians)&&At.isRadiansInStartEnd(k,W.piOver2Radians,W.piRadians)?{quadrant:2,angle0:W.piOver2Radians,angle1:W.piRadians}:At.isRadiansInStartEnd(y,W.piRadians,W.pi3Over2Radians)&&At.isRadiansInStartEnd(k,W.piRadians,W.pi3Over2Radians)?{quadrant:3,angle0:W.piRadians,angle1:W.pi3Over2Radians}:At.isRadiansInStartEnd(y,W.pi3Over2Radians,W.pi2Radians)&&At.isRadiansInStartEnd(k,W.pi3Over2Radians,W.pi2Radians)?{quadrant:4,angle0:W.pi3Over2Radians,angle1:W.pi2Radians}:void 0}static getQ1FractionalRange(y){const k=.5*Math.PI;let M=y.radiansToSignedPeriodicFraction(0),b=y.radiansToSignedPeriodicFraction(k);return y.isCCW||([M,b]=[b,M]),b<M&&(b+=1),ft.createXX(M,b)}reverse(){this._fractions.reverse(),[this._interpolateStartTangent,this._interpolateEndTangent]=[this._interpolateEndTangent,this._interpolateStartTangent]}}class mi{announceQuadrantBegin(y,k){return!0}announceArc(y,k,M,b){}announceQuadrantEnd(y,k){}}class xi extends mi{constructor(y){super(),this._ellipticalArc=y,this._maxPerpendicular=void 0}static create(y){return new xi(y)}get ellipticalArc(){return this._ellipticalArc}static computePrimitiveErrorXY(y,k,M,b){const E=new ui;E.maxDistanceToAccept=y.quickLength()/2;const D=void 0!==M&&void 0!==b,R=D?k.clonePartialCurve(M,b):k;let X;E.allPerpendicularsArcArcBounded(y,R);for(const z of E.grabPairedResults()){if(Q.isAlmostEqualEitherNumber(z.detailA.fraction,0,1,Q.smallFraction))continue;if(Q.isAlmostEqualEitherNumber(z.detailB.fraction,0,1,Q.smallFraction))continue;const y=z.detailA.point.distanceXY(z.detailB.point);(!X||X.detailA.a<y)&&(D&&(z.detailB.fraction=Q.interpolate(M,z.detailB.fraction,b),z.detailB.setCurve(k)),z.detailA.a=z.detailB.a=y,X=z)}return X}get maxPerpendicular(){return this._maxPerpendicular}set maxPerpendicular(y){this._maxPerpendicular=y}updateMaxPerpendicular(y,k,M){const b=xi.computePrimitiveErrorXY(y,this.ellipticalArc,k,M);b&&(!this.maxPerpendicular||this.maxPerpendicular.detailA.a<b.detailA.a)&&(this.maxPerpendicular=b)}announceArc(y,k,M,b){this.updateMaxPerpendicular(y,M,b)}}class _i extends mi{constructor(y,k,M,b){super(),this._fullEllipseXY=y,this._bracket0=k,this._f=M,this._bracket1=b,this._error0=this._error1=Q.largeCoordinateResult}static create(y,k,M,b){return new _i(y,k,M,b)}get fullEllipseXY(){return this._fullEllipseXY}get f(){return this._f}get isConverged(){return!!Q.isSmallMetricDistance(this._error0-this._error1)||!!Q.isSmallRelative(this._bracket0-this._bracket1)}announceQuadrantBegin(y,k){return e(y.quadrant),e(),e(4===y.fractions.length||3===y.fractions.length&&y.interpolateStartTangent),this._error0=this._error1=Q.largeCoordinateResult,!0}announceArc(y,k,M,b){if(Q.isAlmostEqualEitherNumber(this.f,M,b,0)){const k=xi.computePrimitiveErrorXY(y,this.fullEllipseXY,M,b);k&&(this.f===b?this._error0=k.detailA.a:this._error1=k.detailA.a)}}announceQuadrantEnd(y,k){if(Q.isLargeCoordinateResult(this._error0)||Q.isLargeCoordinateResult(this._error1))return;if(this.isConverged)return;const M=y.fractions.length;this._error0<this._error1?this._bracket0=this._f:this._bracket1=this._f,this._f=y.fractions[M-2]=Q.interpolate(this._bracket0,.5,this._bracket1)}}class yi extends mi{constructor(y,k){super(),this._fullEllipseXY=y,this._fractionRangeQ1=pi.getQ1FractionalRange(y.sweep),this._maxError=k>0?k:Ci.defaultMaxError,this._originalRefinementCount=0}static create(y,k){return new yi(y,k)}get fullEllipseXY(){return this._fullEllipseXY}get isRefined(){return void 0!==this._refinement&&0!==this._refinement.length&&this._originalRefinementCount<this._refinement.length}announceQuadrantBegin(y,k){e(y.quadrant),this._refinement=new We(k?gi:fi,!1);for(const M of y.fractions)this._fractionRangeQ1.containsX(M)&&this._refinement.insert(M);return 2<=(this._originalRefinementCount=this._refinement.length)}getPreviousFraction(y){if(void 0===this._refinement)return;const k=this._refinement.indexOf(y);return k>=1?this._refinement.get(k-1):void 0}announceArc(y,k,M,b){if(void 0===this._refinement)return;if(this._originalRefinementCount>2){const k=xi.computePrimitiveErrorXY(y,this.fullEllipseXY,M,b);if(!k||k.detailA.a<=this._maxError)return}const E=Q.interpolate(M,.5,b),D=Q.isAlmostEqualEitherNumber(M,this._fractionRangeQ1.low,this._fractionRangeQ1.high,0),R=Q.isAlmostEqualEitherNumber(b,this._fractionRangeQ1.low,this._fractionRangeQ1.high,0);D||void 0!==k||(k=this.getPreviousFraction(M));const X=void 0===k?[M,E,b]:[k,M,E,b],z=[pi.create(1,X,D,R)],N=_i.create(this.fullEllipseXY,M,E,b);let Y=0;do{wi.processQuadrantFractions(this.fullEllipseXY,z,N)}while(Y++<yi._maxIters&&!N.isConverged);this._refinement.insert(N.f)}announceQuadrantEnd(y,k){this._refinement&&(y.fractions=[...this._refinement])}getRefinedInteriorQ1Angles(y){if(y?y.length=0:y=[],this._refinement)for(const k of this._refinement)this._fractionRangeQ1.containsXOpen(k)&&y.push(this.fullEllipseXY.sweep.fractionToRadians(k));return y}}yi._maxIters=50;class vi{constructor(y,k){this._context=y,this._options=k}static create(y,k){return new vi(y,k)}computeRadiansStrictlyInsideQuadrant1(y){if(y||(y=[]),this._context.isValidEllipticalArc){const k=W.piOver2Radians/(this._options.numSamplesInQuadrant-1);for(let M=1;M<this._options.numSamplesInQuadrant-1;++M)y.push(M*k)}return y}}class Pi{constructor(y,k){this._context=y,this._options=k,this._xMag2=y.ellipticalArc.matrixRef.columnXMagnitudeSquared(),this._yMag2=y.ellipticalArc.matrixRef.columnYMagnitudeSquared(),this._curvatureRange=ft.createXX(Math.sqrt(this._xMag2)/this._yMag2,Math.sqrt(this._yMag2)/this._xMag2)}static create(y,k){return new Pi(y,k)}curvatureToRadians(y){if(!this._curvatureRange.containsX(y))return;const k=Math.cbrt(this._xMag2*this._yMag2/(y*y)),M=Math.sqrt(Math.abs((k-this._xMag2)/(this._yMag2-this._xMag2)));return Math.acos(M)}computeRadiansStrictlyInsideQuadrant1(y){if(y||(y=[]),this._context.isValidEllipticalArc){const k=1/(this._options.numSamplesInQuadrant-1);for(let M=1;M<this._options.numSamplesInQuadrant-1;++M){const b=this._options.remapFunction(M*k),E=(1-b)*this._curvatureRange.low+b*this._curvatureRange.high,D=this.curvatureToRadians(E);void 0!==D&&y.push(D)}}return y}}class Ai extends Pi{constructor(y,k){super(y,k.clone()),this._options.remapFunction=y=>y}static create(y,k){return new Ai(y,k)}}class Ii{constructor(y,k){this._context=y,this._options=k,this._fullEllipseXY=y.cloneLocalArc(!0)??Ti.createUnitCircle()}static create(y,k){return new Ii(y,k)}get fullEllipseXY(){return this._fullEllipseXY}computeRadiansStrictlyInsideQuadrant1(y){if(!this._context.isValidEllipticalArc)return[];const k=pi.getQ1FractionalRange(this.fullEllipseXY.sweep),M=[pi.create(1,[k.low,k.high],!0,!0)],b=yi.create(this.fullEllipseXY,this._options.maxError);do{wi.processQuadrantFractions(this.fullEllipseXY,M,b)}while(b.isRefined);return b.getRefinedInteriorQ1Angles(y)}}class Si extends mi{constructor(y,k){super(),this._chain=y.sweep.isFullCircle&&!k?hi.create():oi.create()}static create(y,k=!1){return new Si(y,k)}get chain(){return this._chain.children.length>0?this._chain:void 0}announceQuadrantBegin(y,k){return this._quadrantChain=void 0,!0}announceArc(y,k,M,b){this._quadrantChain||(this._quadrantChain=oi.create()),this._quadrantChain.tryAddChild(y)}announceQuadrantEnd(y,k){if(this._quadrantChain){k&&this._quadrantChain.reverseChildrenInPlace();for(const y of this._quadrantChain.children)this._chain.tryAddChild(y)}}}class wi{constructor(y){this._isValidEllipticalArc=!1;const k=y.toScaledMatrix3d();if(this._ellipticalArc=Ti.createScaledXYColumns(k.center,k.axes,k.r0,k.r90,k.sweep),this._localToWorld=pt.createRefs(k.center,k.axes),this._localToWorld.matrix.isSingular())return;if(this._ellipticalArc.sweep.isEmpty)return;const M=y.matrixRef.columnXMagnitudeSquared(),b=y.matrixRef.columnYMagnitudeSquared();Q.isSmallMetricDistanceSquared(M)||Q.isSmallMetricDistanceSquared(b)||Q.isSameCoordinateSquared(M,b)||(this._isValidEllipticalArc=!0)}static create(y){return new wi(y)}get ellipticalArc(){return this._ellipticalArc}get localToWorld(){return this._localToWorld}get isValidEllipticalArc(){return this._isValidEllipticalArc}cloneLocalArc(y){if(!this.isValidEllipticalArc)return;const k=this.localToWorld.inverse();if(!k)return;const M=this.ellipticalArc.cloneTransformed(k);if(y){let y=2*Math.PI;M.sweep.isCCW||(y=-y),M.sweep.setStartEndRadians(M.sweep.startRadians,M.sweep.startRadians+y)}return M}static processQuadrantFractions(y,k,M){const b=this.workPt0,E=this.workPt1,D=this.workPt2,R=this.workRay,a=(y,k,M)=>{const b=Ti.createCircularStartTangentEnd(y.origin,y.direction,k);if(b instanceof Ti)return M&&b.reverseInPlace(),b},c=(k,b)=>{y.fractionToPointAndDerivative(k,R),y.fractionToPoint(b,E),k>b&&R.direction.scaleInPlace(-1);const D=a(R,E,!1);D&&M.announceArc(D,void 0,k,b)},l=(k,R,X)=>{let z=k;M.getPreviousFraction&&(z=M.getPreviousFraction(R)??k),y.fractionToPoint(z,b),y.fractionToPoint(R,E),y.fractionToPoint(X,D);const N=((y,k,M)=>{const b=Ti.createCircularStartMiddleEnd(y,k,M);if(!(b instanceof Ti))return;const E=b.vector0.signedAngleTo($.createStartEnd(b.center,k),b.matrixRef.columnZ());return b.sweep.setStartEndRadians(E.radians,b.sweep.endRadians),b})(b,E,D);N&&M.announceArc(N,z,R,X)},h=(k,E)=>{y.fractionToPoint(k,b),y.fractionToPointAndDerivative(E,R),E>k&&R.direction.scaleInPlace(-1);const D=a(R,b,!0);D&&M.announceArc(D,void 0,k,E)},d=k=>{if(!k.interpolateStartTangent&&!k.interpolateEndTangent)return!1;const M=k.fractions.length;if(M<2)return!1;const b=y.vector0.magnitudeSquared()>y.vector90.magnitudeSquared()?2===k.quadrant||4===k.quadrant:1===k.quadrant||3===k.quadrant,E=!(k.fractions[0]>k.fractions[M-1])&&b===y.sweep.isCCW;return E&&k.reverse(),E};for(const X of k){const y=X.fractions.length;if(y<2)continue;const k=d(X);if(M.announceQuadrantBegin(X,k)){X.interpolateStartTangent&&c(X.fractions[0],X.fractions[1]);for(let k=0;k+2<y-1;++k)l(X.fractions[k],X.fractions[k+1],X.fractions[k+2]);y>2&&(X.interpolateEndTangent?h(X.fractions[y-2],X.fractions[y-1]):l(X.fractions[y-3],X.fractions[y-2],X.fractions[y-1])),M.announceQuadrantEnd(X,k),k&&X.reverse()}}}computeApproximationError(y){const k=this.cloneLocalArc();if(!k)return;const M=xi.create(k);wi.processQuadrantFractions(k,y,M);const b=M.maxPerpendicular;return b&&b.tryTransformInPlace(this.localToWorld)?b:void 0}computeSampleFractions(y,k=!1){if(!this.isValidEllipticalArc)return[];const i=(y,k)=>Q.isAlmostEqualNumber(y,k,Q.smallAngleRadians)?0:y<k?-1:1,s=(y,k)=>Q.isAlmostEqualNumber(y,k,Q.smallAngleRadians)?0:y<k?1:-1,n=(y,k)=>fi(y.fractions[y.fractions.length-1],k.fractions[0])<=0?-1:fi(k.fractions[k.fractions.length-1],y.fractions[0])<=0?1:0,r=(y,k)=>{const M=k.isRadiansInSweep(y,!0);if(M){const M=k.radiansToSignedPeriodicFraction(y);Q.isIn01(M)&&(y=k.fractionToRadians(M))}return{angle:y,inSweep:M}},o=(y,k,M,b,E)=>{if(void 0===b&&(b=0),void 0===E&&(E=1),b>E)return o(y,k,M,E,b);const D=M.radiansToSignedPeriodicFraction(k);return D<b-Q.smallFraction||E+Q.smallFraction<D?void 0:(Q.restrictToInterval(D,0,1),y.add(D),D)},a=(y,k,M,b)=>{if(k>M)return a(y,M,k,b);if(W.isAlmostEqualRadiansNoPeriodShift(k,M))return;const E=pi.getQuadrantRadians(k,M);if(void 0===E)return;const D=new He(fi),R=o(D,k,b),X=o(D,M,b);if(void 0===R||void 0===X)return;for(const N of y){let y=N;2===E.quadrant?y=W.piRadians-y:3===E.quadrant?y=W.piRadians+y:4===E.quadrant&&(y=W.pi2Radians-y),o(D,y,b,R,X)}const z=pi.create(E.quadrant,[...D]);return 2===z.fractions.length&&(z.fractions.splice(1,0,Q.interpolate(z.fractions[0],.5,z.fractions[1])),z.averageAdded=!0),z},M=[];switch(y.sampleMethod){case q.UniformParameter:vi.create(this,y).computeRadiansStrictlyInsideQuadrant1(M);break;case q.UniformCurvature:Ai.create(this,y).computeRadiansStrictlyInsideQuadrant1(M);break;case q.NonUniformCurvature:Pi.create(this,y).computeRadiansStrictlyInsideQuadrant1(M);break;case q.AdaptiveSubdivision:Ii.create(this,y).computeRadiansStrictlyInsideQuadrant1(M)}return k?((y,k)=>{const M=new He(k.isCCW?i:s);M.add(k.endRadians);for(const D of[0,W.piOver2Radians,W.piRadians,W.pi3Over2Radians,W.pi2Radians]){const y=r(D,k);y.inSweep&&M.add(y.angle)}const b=new He(n);let E=k.startRadians;for(const D of M){const M=a(y,E,D,k);M&&b.add(M),E=D}return[...b]})(M,this.ellipticalArc.sweep):((y,k)=>{const M=new He(fi);M.add(0),M.add(1);for(const b of[0,W.piOver2Radians,W.piRadians,W.pi3Over2Radians])o(M,b,k);for(const b of y)for(const y of[b,W.piRadians-b,W.piRadians+b,W.pi2Radians-b])o(M,y,k);return[...M]})(M,this.ellipticalArc.sweep)}constructCircularArcChainApproximation(y){if(!this.isValidEllipticalArc)return;y||(y=Ci.create());const k=this.computeSampleFractions(y,!0),M=Si.create(this.ellipticalArc,y.forcePath);return wi.processQuadrantFractions(this.ellipticalArc,k,M),M.chain}}wi.workPt0=j.createZero(),wi.workPt1=j.createZero(),wi.workPt2=j.createZero(),wi.workRay=bt.createZero(),function(y){y[y.UniformParameter=0]="UniformParameter",y[y.UniformCurvature=1]="UniformCurvature",y[y.NonUniformCurvature=2]="NonUniformCurvature",y[y.AdaptiveSubdivision=3]="AdaptiveSubdivision"}(q||(q={}));class Ci{constructor(y,k,M,b,E){this._sampleMethod=y,this._numSamplesInQuadrant=k,this._maxError=M,this._remapFunction=b,this._forcePath=E}static create(y=q.AdaptiveSubdivision,k=4,M=this.defaultMaxError,b=y=>y*y,E=!1){return k<2&&(k=2),M<=0&&(M=this.defaultMaxError),new Ci(y,k,M,b,E)}clone(){return new Ci(this.sampleMethod,this.numSamplesInQuadrant,this.maxError,this.remapFunction,this.forcePath)}get sampleMethod(){return this._sampleMethod}set sampleMethod(y){this._sampleMethod=y}get numSamplesInQuadrant(){return this._numSamplesInQuadrant}set numSamplesInQuadrant(y){this._numSamplesInQuadrant=y}get maxError(){return this._maxError}set maxError(y){this._maxError=y}get remapFunction(){return this._remapFunction}set remapFunction(y){this._remapFunction=y}get forcePath(){return this._forcePath}set forcePath(y){this._forcePath=y}}Ci.defaultMaxError=Ve.oneCentimeter;class Ti extends ae{isSameGeometryClass(y){return y instanceof Ti}get center(){return this._center.clone()}get vector0(){return this._matrix.columnX()}get vector90(){return this._matrix.columnY()}get perpendicularVector(){return this._matrix.columnZ()}matrixClone(){return this._matrix.clone()}get matrixRef(){return this._matrix}get sweep(){return this._sweep}set sweep(y){this._sweep.setFrom(y)}get isExtensibleFractionSpace(){return!0}constructor(y,k,M){super(),this.curvePrimitiveType="arc",this._center=y,this._matrix=k,this._sweep=M}cloneTransformed(y){const k=this.clone();return k.tryTransformInPlace(y),k}setRefs(y,k,M){this._center=y,this._matrix=k,this._sweep=M}set(y,k,M){this.setRefs(y.clone(),k.clone(),M?M.clone():At.create360())}setFrom(y){this._center.setFrom(y._center),this._matrix.setFrom(y._matrix),this._sweep.setFrom(y._sweep)}clone(){return new Ti(this._center.clone(),this._matrix.clone(),this._sweep.clone())}static createRefs(y,k,M,b){return b?(b.setRefs(y,k,M),b):new Ti(y,k,M)}static createScaledXYColumns(y,k,M,b,E,D){const R=k.columnX(),X=k.columnY();return Ti.create(y,R.scale(M,R),X.scale(b,X),E,D)}static createCenterNormalRadius(y,k,M,b){const E=xt.createRigidHeadsUp(k);return Ti.createScaledXYColumns(y,E,M,M,void 0,b)}static create(y,k,M,b,E){const D=k.unitCrossProductWithDefault(M,0,0,0),R=xt.createColumns(k,M,D);return Ti.createRefs(void 0!==y?y.clone():j.create(0,0,0),R,b?b.clone():At.create360(),E)}static createStartMiddleEnd(y,k,M,b,E){const D=j.createAdd2Scaled(y,.5,M,.5),R=$.createStartEnd(D,y),X=$.createStartEnd(D,k),z=R.dotProduct(X),N=R.magnitudeSquared();if(Math.abs(z)>=N)return;const Y=R.crossProduct(X).unitCrossProductWithDefault(R,0,0,0),O=X.dotProduct(Y),B=Q.safeDivideFraction(N*O,Math.sqrt(N*N-z*z),0);return Q.isSmallMetricDistanceSquared(B)?void 0:(Y.scaleInPlace(B),Ti.create(D,R,Y,b,E))}static createCircularStartTangentEnd(y,k,M,b){const D=$.createStartEnd(y,M),R=xt.createRigidFromColumns(k,D,E.XYZ);if(void 0!==R){const M=D.dotProduct(D),E=R.dotColumnY(D),X=Q.conditionalDivideCoordinate(M,2*E);if(void 0!==X){const M=R.columnY();M.scaleInPlace(-X);const E=R.columnX();E.scaleInPlace(X);const z=M.plus(D);let N=M.angleTo(z).radians;k.dotProduct(z)<0&&(N=2*Math.PI-N);const Y=y.plusScaled(M,-1),O=At.createStartEndRadians(0,N);return Ti.create(Y,M,E,O,b)}}return Ce.create(y,M)}static createCircularStartTangentRadius(y,k,M,b,E){void 0===b&&(b=$.unitZ());const D=b.unitCrossProduct(k);if(void 0===D)return;const R=y.plusScaled(D,M);D.scaleInPlace(-M);const X=k.scaleToLength(Math.abs(M));return Ti.create(R,D,X,At.create(E))}static createCircularStartEndRadius(y,k,M,b){const E=.25*y.distanceSquared(k),D=M*M;if(D<E)return;const R=Math.sqrt(D-E),X=$.createZero(this._workVectorU),z=$.createZero(this._workVectorV);if(b instanceof j?y.crossProductToPoints(b,k,X):X.setFrom(b),!X.normalizeInPlace()||!X.crossProductStartEnd(y,k,z).scaleToLength(R,z))return;const N=j.createZero();y.interpolate(.5,k,N).addInPlace(z);const Y=$.createStartEnd(N,y,this._workVectorW),O=$.createStartEnd(N,k,this._workVectorV),B=At.create(Y.signedAngleTo(O,X)),V=X.crossProduct(Y,this._workVectorV);return Ti.createRefs(N,xt.createColumns(Y,V,X),B)}cloneAtZ(y){return void 0===y&&(y=this._center.z),Ti.createXYZXYZXYZ(this._center.x,this._center.y,y,this._matrix.coffs[0],this._matrix.coffs[3],0,this._matrix.coffs[1],this._matrix.coffs[4],0,this._sweep)}static createXYZXYZXYZ(y,k,M,b,E,D,R,X,z,N,Y){return Ti.create(j.create(y,k,M),$.create(b,E,D),$.create(R,X,z),N,Y)}quickEccentricity(){const y=this._matrix.columnXMagnitude(),k=this._matrix.columnYMagnitude(),M=this._matrix.columnXYCrossProductMagnitude(),b=Q.maxXY(y,k);return M/(b*b)}static createCircularStartMiddleEnd(y,k,M,b){const E=$.createStartEnd(y,k),D=$.createStartEnd(y,M),R=E.magnitudeSquared(),X=D.magnitudeSquared(),z=E.sizedCrossProduct(D,Math.sqrt(Math.sqrt(R*X)));if(z){const k=Mt.linearSystem3d(z.x,z.y,z.z,E.x,E.y,E.z,D.x,D.y,D.z,0,.5*R,.5*X);if(k){const E=j.create(y.x,y.y,y.z).plus(k),D=$.createStartEnd(E,y),R=$.createRotateVectorAroundVector(D,z,W.createDegrees(90));if(R){const y=$.createStartEnd(E,M),k=D.signedAngleTo(y,z);return k.radians<0&&k.addMultipleOf2PiInPlace(1),Ti.create(E,D,R,At.createStartEndRadians(0,k.radians),b)}}}return Me.create(y,k,M)}getFractionToDistanceScale(){const y=this.circularRadius();if(void 0!==y)return Math.abs(y*this._sweep.sweepRadians)}fractionToPoint(y,k){const M=this._sweep.fractionToRadians(y);return this._matrix.originPlusMatrixTimesXY(this._center,Math.cos(M),Math.sin(M),k)}fractionAndRadialFractionToPoint(y,k,M){const b=this._sweep.fractionToRadians(y);return this._matrix.originPlusMatrixTimesXY(this._center,k*Math.cos(b),k*Math.sin(b),M)}fractionToPointAndDerivative(y,k){return(k=this.radiansToPointAndDerivative(this._sweep.fractionToRadians(y),k)).direction.scaleInPlace(this._sweep.sweepRadians),k}fractionToPointAnd2Derivatives(y,k){const M=this._sweep.fractionToRadians(y);k||(k=Et.createXYPlane());const b=Math.cos(M),E=Math.sin(M);this._matrix.originPlusMatrixTimesXY(this._center,b,E,k.origin);const D=this._sweep.sweepRadians;this._matrix.multiplyXY(-D*E,D*b,k.vectorU);const R=D*D;return this._matrix.multiplyXY(-R*b,-R*E,k.vectorV),k}radiansToPointAndDerivative(y,k){k=k||bt.createZero();const M=Math.cos(y),b=Math.sin(y);return this._matrix.originPlusMatrixTimesXY(this._center,M,b,k.origin),this._matrix.multiplyXY(-b,M,k.direction),k}radiansToPoint(y,k){k=k||j.create();const M=Math.cos(y),b=Math.sin(y);return this._matrix.originPlusMatrixTimesXY(this._center,M,b,k),k}radiansToRotatedBasis(y,k){k=k||Et.createXYPlane();const M=Math.cos(y),b=Math.sin(y);return k.origin.setFromPoint3d(this.center),this._matrix.multiplyXY(M,b,k.vectorU),this._matrix.multiplyXY(-b,M,k.vectorV),k}angleToPointAndDerivative(y,k){k=k||bt.createZero();const M=y.cos(),b=y.sin();return this._matrix.originPlusMatrixTimesXY(this._center,M,b,k.origin),this._matrix.multiplyXY(-b,M,k.direction),k}startPoint(y){return this.fractionToPoint(0,y)}endPoint(y){return this.fractionToPoint(1,y)}curveLength(){return this.curveLengthBetweenFractions(0,1)}curveLengthBetweenFractions(y,k){const M=this.getFractionToDistanceScale();if(void 0!==M)return M*Math.abs(k-y);let b=y,E=k;y>k&&(b=k,E=y);const D=(E-b)*this._sweep.sweepDegrees;let R=this.quickEccentricity();R<1e-5&&(R=1e-5);let X=Math.ceil(D/(R*Ti.quadratureIntervalAngleDegrees));return X>400&&(X=400),X<1&&(X=1),super.curveLengthWithFixedIntervalCountQuadrature(b,E,X,Ti.quadratureGuassCount)}quickLength(){const y=Math.abs(this._sweep.sweepRadians);let k=Math.ceil(4*y/Math.PI);k<1&&(k=1),k<4?k+=3:k<6&&(k+=2);const M=Ti._workPointA,b=Ti._workPointB;let E=0;this.fractionToPoint(0,M);for(let R=1;R<=k;R++)this.fractionToPoint(R/k,b),E+=M.distance(b),M.setFromPoint3d(b);const D=y/k;return E*(D/(2*Math.sin(.5*D)))}moveSignedDistanceFromFraction(y,k,M,b){if(!this.isCircular)return super.moveSignedDistanceFromFractionGeneric(y,k,M,b);const E=this.curveLength(),D=Q.conditionalDivideFraction(k,E);return void 0===D?vt.createCurveFractionPointDistanceCurveSearchStatus(this,y,this.fractionToPoint(y),0,B.error):vt.createConditionalMoveSignedDistance(M,this,y,y+D,k,b)}allPerpendicularAngles(y,k=!0,M=!1){const b=[],E=y.vectorTo(this.center),D=this._matrix.columnXMagnitudeSquared(),R=this._matrix.columnXDotColumnY(),X=this._matrix.columnYMagnitudeSquared();return Tt.solveUnitCircleImplicitQuadricIntersection(R,X-D,-R,this._matrix.dotColumnY(E),-this._matrix.dotColumnX(E),0,b),M&&(b.push(this.sweep.startRadians),b.push(this.sweep.endRadians)),b}closestPoint(y,k,M){M=vt.create(this,M);const b=this.allPerpendicularAngles(y,!0,!0);let E=ie.resolveVariantCurveExtendParameterToCurveExtendMode(k,0),D=ie.resolveVariantCurveExtendParameterToCurveExtendMode(k,1);this._sweep.isFullCircle&&(E=U.None,D=U.None),E!==U.None&&D!==U.None&&(b.push(this._sweep.startRadians),b.push(this._sweep.endRadians));const R=bt.createZero();if(0===b.length)M.setFR(0,this.radiansToPointAndDerivative(this._sweep.startRadians,R)),M.a=y.distance(M.point);else{let E=Number.MAX_VALUE,D=0;for(const X of b){const b=ie.resolveRadiansToSweepFraction(k,X,this.sweep);void 0!==b&&(this.fractionToPointAndDerivative(b,R),D=y.distance(R.origin),D<E&&(E=D,M.setFR(b,R),M.a=D))}}return M}reverseInPlace(){this._sweep.reverseInPlace()}tryTransformInPlace(y){return this._center=y.multiplyPoint3d(this._center,this._center),this._matrix=y.matrix.multiplyMatrixMatrix(this._matrix,this._matrix),this.setVector0Vector90(this._matrix.columnX(),this._matrix.columnY()),!0}isInPlane(y){const k=y.getNormalRef();return Q.isSmallMetricDistance(y.altitude(this._center))&&Q.isSmallMetricDistance(this._matrix.dotColumnX(k))&&Q.isSmallMetricDistance(this._matrix.dotColumnY(k))}get isCircular(){const y=this._matrix.columnXMagnitudeSquared(),k=this._matrix.columnYMagnitudeSquared(),M=this._matrix.columnXDotColumnY();return W.isPerpendicularDotSet(y,k,M)&&Q.isSameCoordinateSquared(y,k)}circularRadiusXY(){const y=this._matrix.at(0,0),k=this._matrix.at(1,0),M=this._matrix.at(0,1),b=this._matrix.at(1,1),E=Q.dotProductXYXY(y,k,y,k),D=Q.dotProductXYXY(M,b,M,b),R=Q.dotProductXYXY(y,k,M,b);if(W.isPerpendicularDotSet(E,D,R)&&Q.isSameCoordinateSquared(E,D))return Q.hypotenuseXY(y,k)}circularRadius(){return this.isCircular?this._matrix.columnXMagnitude():void 0}maxVectorLength(){return Math.max(this._matrix.columnXMagnitude(),this._matrix.columnYMagnitude())}appendPlaneIntersectionPoints(y,k){const M=y.altitude(this._center),b=this._matrix.coffs,E=y.velocityXYZ(b[0],b[3],b[6]),D=y.velocityXYZ(b[1],b[4],b[7]),R=Q.solveTrigForm(M,E,D);let X=0;if(void 0!==R){let y;for(y of(X=R.length,R)){const M=Math.atan2(y.y,y.x),b=this._sweep.radiansToPositivePeriodicFraction(M),E=vt.createCurveFractionPoint(this,b,this.fractionToPoint(b));E.intervalRole=O.isolated,(W.isAlmostEqualRadiansAllowPeriodShift(M,this._sweep.startRadians)||W.isAlmostEqualRadiansAllowPeriodShift(M,this._sweep.endRadians))&&(E.intervalRole=O.isolatedAtVertex),k.push(E)}}return X}extendRange(y,k){this.extendRangeInSweep(y,this._sweep,k)}extendRangeInSweep(y,k,M){const b=new kt(0,0,0),E=this._center.clone(Ti._workPointA),D=this._matrix.columnX(Ti._workVectorU),R=this._matrix.columnY(Ti._workVectorV);M&&(M.multiplyPoint3d(E,E),M.multiplyVector(D,D),M.multiplyVector(R,R));const X=Ti._workPointB,z=Ti._workPointC,N=ft.createNull();for(let Y=0;Y<3;Y++)b.set(E.at(Y),D.at(Y),R.at(Y)),b.rangeInSweep(k,N),X.setAt(Y,N.low),z.setAt(Y,N.high);y.extend(X),y.extend(z)}rangeBetweenFractions(y,k,M){const b=At.createStartEndRadians(this.sweep.fractionToRadians(y),this.sweep.fractionToRadians(k)),E=ut.create();return this.extendRangeInSweep(E,b,M),E}getPlaneAltitudeSineCosinePolynomial(y,k){return k||(k=new kt(0,0,0)),k.set(y.altitude(this._center),y.velocityXYZ(this._matrix.coffs[0],this._matrix.coffs[3],this._matrix.coffs[6]),y.velocityXYZ(this._matrix.coffs[1],this._matrix.coffs[4],this._matrix.coffs[7])),k}static createUnitCircle(){return Ti.createRefs(j.create(0,0,0),xt.createIdentity(),At.create360())}static createXY(y,k,M=At.create360()){return new Ti(y.clone(),xt.createScale(k,k,1),M.clone())}static createXYEllipse(y,k,M,b=At.create360()){return new Ti(y.clone(),xt.createScale(k,M,1),b.clone())}setVector0Vector90(y,k){this._matrix.setColumns(y,k,y.unitCrossProductWithDefault(k,0,0,0))}toScaledMatrix3d(){const y=W.dotProductsToHalfAngleTrigValues(this._matrix.columnXMagnitudeSquared(),this._matrix.columnYMagnitudeSquared(),this._matrix.columnXDotColumnY(),!0),k=this._matrix.multiplyXY(y.c,y.s),M=this._matrix.multiplyXY(-y.s,y.c),b=xt.createRigidFromColumns(k,M,E.XYZ);return{center:this._center.clone(),axes:b||xt.createIdentity(),r0:k.magnitude(),r90:M.magnitude(),sweep:this.sweep.cloneMinusRadians(y.radians)}}toVectors(){return{center:this.center.clone(),vector0:this._matrix.columnX(),vector90:this._matrix.columnY(),sweep:this.sweep.clone()}}toTransformedVectors(y){return y?{center:y.multiplyPoint3d(this._center),vector0:y.multiplyVector(this._matrix.columnX()),vector90:y.multiplyVector(this._matrix.columnY()),sweep:this.sweep.clone()}:{center:this._center.clone(),vector0:this._matrix.columnX(),vector90:this._matrix.columnY(),sweep:this.sweep.clone()}}toTransformedPoint4d(y){return{center:y.multiplyPoint3d(this._center,1),vector0:y.multiplyPoint3d(this._matrix.columnX(),0),vector90:y.multiplyPoint3d(this._matrix.columnY(),0),sweep:this.sweep.clone()}}setFromJSON(y){if(y&&y.center&&y.vector0&&y.vector90&&y.sweep){this._center.setFromJSON(y.center);const k=$.create(),M=$.create();k.setFromJSON(y.vector0),M.setFromJSON(y.vector90),this.setVector0Vector90(k,M),this._sweep.setFromJSON(y.sweep)}else this._center.set(0,0,0),this._matrix.setFrom(xt.identity),this._sweep.setStartEndRadians()}toJSON(){return{center:this._center.toJSON(),sweep:this._sweep.toJSON(),vector0:this._matrix.columnX().toJSON(),vector90:this._matrix.columnY().toJSON()}}isAlmostEqual(y,k=Q.smallMetricDistance,M=Q.smallAngleRadians){if(y instanceof Ti){const b=y;return this._center.isAlmostEqual(b._center,k)&&this._matrix.isAlmostEqual(b._matrix,k)&&this._sweep.isAlmostEqualAllowPeriodShift(b._sweep,M)}return!1}emitStrokes(y,k){const M=this.computeStrokeCountForOptions(k);y.appendFractionalStrokePoints(this,M,0,1,!0)}emitStrokableParts(y,k){const M=this.computeStrokeCountForOptions(k);y.startCurvePrimitive(this),y.announceIntervalForUniformStepStrokes(this,M,0,1),y.endCurvePrimitive(this)}computeStrokeCountForOptions(y){let k;if(y){const M=this.maxVectorLength();k=y.applyTolerancesToArc(M,this._sweep.sweepRadians)}else k=Ie.applyAngleTol(void 0,1,this._sweep.sweepRadians);return k}dispatchToGeometryHandler(y){return y.handleArc3d(this)}clonePartialCurve(y,k){if(k<y){const M=this.clonePartialCurve(k,y);return M.reverseInPlace(),M}const M=this.clone();return M.sweep.setStartEndRadians(this.sweep.fractionToRadians(y),this.sweep.fractionToRadians(k)),M}cloneInRotatedBasis(y){const k=y.cos(),M=y.sin(),b=this._matrix.multiplyXY(k,M),E=this._matrix.multiplyXY(-M,k),D=At.createStartEndRadians(this._sweep.startRadians-y.radians,this._sweep.endRadians-y.radians);return Ti.create(this._center.clone(),b,E,D)}announceClipIntervals(y,k){return y.announceClippedArcIntervals(this,k)}otherArcAsLocalVectors(y){const k=this._matrix.multiplyInverseXYZAsPoint3d(y.center.x-this.center.x,y.center.y-this.center.y,y.center.z-this.center.z),M=this._matrix.multiplyInverse(y.vector0),b=this._matrix.multiplyInverse(y.vector90);if(k&&M&&b)return{center:k,vector0:M,vector90:b,sweep:this.sweep.clone()}}static createFilletArc(y,k,M,b){const E=$.createStartEnd(k,y),D=$.createStartEnd(k,M),R=E.magnitude(),X=D.magnitude();if(E.normalizeInPlace()&&D.normalizeInPlace()){const y=E.plus(D);if(y.normalizeInPlace()){const M=D.minus(E),z=M.magnitude(),N=.5*z;if(!Q.isSmallAngleRadians(N)){const E=N/Math.sqrt(1-N*N),D=Math.acos(N),Y=b/N,O=b/E,B=O/R,V=O/X,U=k.plusScaled(y,Y);return y.scaleInPlace(-b),M.scaleInPlace(b/z),{arc:Ti.create(U,y,M,At.createStartEndRadians(-D,D)),fraction10:B,fraction12:V,point:k.clone()}}}}return{fraction10:0,fraction12:0,point:k.clone()}}scaleAboutCenterInPlace(y){this._matrix.scaleColumnsInPlace(y,y,1)}areaToChordXY(y,k){let M=Q.crossProductXYXY(this._matrix.coffs[0],this._matrix.coffs[3],this._matrix.coffs[1],this._matrix.coffs[4]);const b=this._sweep.fractionToRadians(y),E=.5*(this._sweep.fractionToRadians(k)-b);return E<0&&(M=-M),(E-Math.cos(E)*Math.sin(E))*M}constructOffsetXY(y){const k=we.create(y);if(this.isCircular||k.preserveEllipticalArcs){const y=this.cloneAtZ(),M=y.sweep.sweepRadians*y.matrixRef.coffs[8]>=0?1:-1,b=y.matrixRef.columnXMagnitude(),E=b-M*k.leftOffsetDistance,D=this.isCircular?b:y.matrixRef.columnYMagnitude(),R=this.isCircular?E:D-M*k.leftOffsetDistance;if(!Q.isSmallMetricDistance(E)&&b*E>0&&(this.isCircular||!Q.isSmallMetricDistance(R)&&D*R>0)){const k=E/b,M=this.isCircular?k:R/D,X=y.matrixClone();return X.scaleColumnsInPlace(k,M,1),Ti.createRefs(y.center.clone(),X,y.sweep.clone())}return}const M=new ye(this,k.leftOffsetDistance);return this.emitStrokableParts(M,k.strokeOptions),M.claimResult()}projectedParameterRange(y,k){return Ee.findExtremeFractionsAlongDirection(this,y,k)}constructCircularArcChainApproximation(y){y||(y=Ci.create());const k=wi.create(this).constructCircularArcChainApproximation(y);return!k&&this.isCircular?this.sweep.isFullCircle&&y.forcePath?oi.create(this):this:k}}Ti._workPointA=j.create(),Ti._workPointB=j.create(),Ti._workPointC=j.create(),Ti._workVectorU=$.create(),Ti._workVectorV=$.create(),Ti._workVectorW=$.create(),Ti.quadratureGuassCount=5,Ti.quadratureIntervalAngleDegrees=10;class Fi{areStronglyIndependentVectors(y,k,M=Q.smallAngleRadians){return void 0!==y&&void 0!==k&&y.smallerUnorientedRadiansTo(k)>M}clear(){this._origin=void 0,this._vector0=void 0,this._vector1=void 0,this._vector2=void 0}constructor(){this.clear()}getValidatedFrame(y=!1,k){if(this._origin&&this._vector0&&this._vector1){const i=(y,k)=>Fi._workMatrix=xt.createRigidFromColumns(y,k,E.XYZ,Fi._workMatrix);if(y){if(this._vector2){const y=i(this._vector0,this._vector1);if(y)return this._vector0.tripleProduct(this._vector1,this._vector2)<0&&y.scaleColumns(1,1,-1),pt.createOriginAndMatrix(this._origin,y,k);const M=this._vector2;this._vector1=this._vector2=void 0,this.announceVector(M)}}else{const y=i(this._vector0,this._vector1);if(y)return pt.createOriginAndMatrix(this._origin,y,k);this._vector1=this._vector2=void 0}}}applyDefaultUpVector(y){y&&this._vector0&&!this._vector1&&!y.isParallelTo(this._vector0)&&(this._vector1=y.crossProduct(this._vector0))}get hasOrigin(){return void 0!==this._origin}savedVectorCount(){return this._vector0?this._vector1?this._vector2?3:2:1:0}announcePoint(y){return this._origin?this._origin.isAlmostEqual(y)?this.savedVectorCount():this.announceVector(this._origin.vectorTo(y)):(this._origin=y.clone(),this.savedVectorCount())}announceVector(y){if(y.isAlmostZero)return this.savedVectorCount();if(!this._vector0)return this._vector0=y.clone(this._vector0),1;if(!this._vector1)return this.areStronglyIndependentVectors(y,this._vector0,1e-5)?(this._vector1=y.clone(this._vector1),2):1;if(!this._vector2){const k=this._vector0.unitCrossProduct(this._vector1);return k&&!Q.isSameCoordinate(0,k.dotProduct(y))?(this._vector2=y.clone(this._vector2),3):2}return 3}announce(y){if(!(this.savedVectorCount()>1)&&void 0!==y)if(y instanceof j)this.announcePoint(y);else if(y instanceof $)this.announceVector(y);else if(Array.isArray(y))for(const k of y){if(this.savedVectorCount()>1)break;this.announce(k)}else if(y instanceof ae)if(y instanceof Ce)this.announcePoint(y.startPoint()),this.announcePoint(y.endPoint());else if(y instanceof Ti){const k=y.fractionToPointAndDerivative(0);this.announcePoint(k.origin),this.announceVector(k.direction),this.announceVector(y.matrixRef.columnZCrossVector(k.direction))}else if(y instanceof Me){for(const k of y.points)if(this.announcePoint(k),this.savedVectorCount()>1)break}else if(y instanceof Be){const k=j.create();for(let M=0;this.savedVectorCount()<2&&y.getPolePoint3d(M,k)instanceof j;M++)this.announcePoint(k)}else if(y instanceof _e){const k=j.create();for(let M=0;this.savedVectorCount()<2&&M<y.options.fitPoints.length;M++)k.setFrom(y.options.fitPoints[M]),this.announcePoint(k)}else{const k=y.fractionToFrenetFrame(0);void 0!==k&&(this.announcePoint(k.getOrigin()),this.announceVector(k.matrix.getColumn(0)),this.announceVector(k.matrix.getColumn(1)))}else if(y instanceof si){if(y.children)for(const k of y.children)if(this.announce(k),this.savedVectorCount()>1)break}else if(y instanceof nt){const k=j.create();for(let M=0;this.savedVectorCount()<2&&y.getPoint3dAtCheckedPointIndex(M,k)instanceof j;M++)this.announcePoint(k)}else y.hasOwnProperty("x")&&y.hasOwnProperty("y")&&y.hasOwnProperty("z")&&this.announcePoint(j.create(y.x,y.y,y.z))}static createRightHandedFrame(y,...k){let M=k.length>0&&k[k.length-1]instanceof pt?k.pop():void 0;const s=k=>(y&&k.matrix.dotColumnZ(y)<0&&k.matrix.scaleColumnsInPlace(1,-1,-1),k),b=new Fi;for(const E of k)if(b.announce(E),b.applyDefaultUpVector(y),M=b.getValidatedFrame(!1,M))return s(M);const r=(y,k)=>y.fractionToFrenetFrame(0,k);for(const E of k)if(E instanceof ae){if(M=r(E,M))return s(M)}else if(E instanceof si){const y=E.collectCurvePrimitives();for(const k of y)if(M=r(k,M))return s(M)}}static createRightHandedLocalToWorld(...y){return this.createRightHandedFrame(void 0,y)}static createFrameToDistantPoints(y,k){if(y.length>2){const M=y[0],b=Fi._workVector0??$.create();ue.indexOfMostDistantPoint(y,y[0],b);const D=Fi._workVector1??$.create();ue.indexOfPointWithMaxCrossProductMagnitude(y,M,b,D);const R=Fi._workMatrix=xt.createRigidFromColumns(b,D,E.XYZ,Fi._workMatrix);if(R)return pt.createOriginAndMatrix(M,R,k)}}static createFrameWithCCWPolygon(y,k){if(y.length>2){const M=Ur.centroidAreaNormal(y);if(M)return M.toRigidZFrame(k)}}static createLocalToWorldTransformInRange(y,k=X.NonUniformRangeContainment,M=0,b=0,E=0,D=1,R){if(y.isNull)return pt.createIdentity(R);let z=1,N=1,Y=1;k===X.LongestRangeDirection?z=N=Y=Q.correctSmallMetricDistance(y.maxLength(),D):k===X.NonUniformRangeContainment&&(z=Q.correctSmallMetricDistance(y.xLength(),D)*Q.maxAbsDiff(M,0,1),N=Q.correctSmallMetricDistance(y.yLength(),D)*Q.maxAbsDiff(b,0,1),Y=Q.correctSmallMetricDistance(y.zLength(),D)*Q.maxAbsDiff(E,0,1));const O=Fi._workPoint=y.fractionToPoint(M,b,E,Fi._workPoint),B=Fi._workMatrix=xt.createScale(z,N,Y,Fi._workMatrix);return pt.createOriginAndMatrix(O,B,R)}}class ki{constructor(y,k,M){this._toleranceSquared=M*M,this._source=y,this._dest=k}acceptPointByIndex(y){const k=this._source.getPoint3dAtCheckedPointIndex(this._source.cyclicIndex(y));k&&this._dest.push(k)}indexOfMaxCrossProduct(y,k){let M,b,E=0;for(let D=y;D<=k;D++){const y=this._source.cyclicIndex(D),k=this._source.cyclicIndex(D+1),R=this._source.cyclicIndex(D+2);this._source.crossProductIndexIndexIndex(y,k,R,ki._vectorQ),M=ki._vectorQ.magnitudeSquared(),M>E&&(E=M,b=D)}return b}indexOfMaxDeviation(y,k){const M=this._source.cyclicIndex(y),b=this._source.cyclicIndex(k);let E,D,R,X,z,N=this._toleranceSquared;this._source.vectorIndexIndex(M,b,ki._vector01);const Y=ki._vector01.magnitudeSquared();for(let O=y+1;O<k;O++)z=this._source.cyclicIndex(O),this._source.vectorIndexIndex(M,z,ki._vectorQ),D=ki._vector01.dotProduct(ki._vectorQ),D<=0?R=ki._vectorQ.magnitudeSquared():D>Y?(this._source.vectorIndexIndex(b,z,ki._vectorQ),R=ki._vectorQ.magnitudeSquared()):(X=D/Y,R=ki._vectorQ.magnitudeSquared()-Y*X*X),R>N&&(N=R,E=O);return E}recursiveCompressByChordErrorGo(y,k){if(k===y+1)return void this.acceptPointByIndex(k);const M=this.indexOfMaxDeviation(y,k);void 0===M?this.acceptPointByIndex(k):(this.recursiveCompressByChordErrorGo(y,M),this.recursiveCompressByChordErrorGo(M,k))}static compressPoint3dArrayByChordError(y,k){const M=new ce(y),b=new ce([]);return this.compressCollectionByChordError(M,b,k),b.data}static compressCollectionByChordError(y,k,M){k.clear();const b=y.length;if(1===b)return void k.push(y.getPoint3dAtCheckedPointIndex(0));const E=new ki(y,k,M);let D=0,R=b-1;if(b>2&&y.distanceIndexIndex(0,b-1)<=M){const y=E.indexOfMaxCrossProduct(0,b-1);void 0!==y&&(D=y+1,R=D+b)}E.acceptPointByIndex(D),E.recursiveCompressByChordErrorGo(D,R)}static compressInPlaceByShortEdgeLength(y,k){const M=y.length;if(M<2)return;let b=0,E=M-1;for(;E>0&&y.distanceIndexIndex(E-1,M-1)<k;)E--;if(0===E)return void(y.length=1);E<M-1&&y.moveIndexToIndex(M-1,E);let D=b+1;for(;D<=E;)y.distanceIndexIndex(b,D)>=k&&(y.moveIndexToIndex(D,b+1),b++),D++;y.length=b+1}static compressInPlaceBySmallTriangleArea(y,k){const M=y.length;if(M<3)return;let b=0;const E=$.create();for(let D=1;D+1<M;D++)y.crossProductIndexIndexIndex(b,D,D+1,E),.5*E.magnitude()>k&&y.moveIndexToIndex(D,++b);y.moveIndexToIndex(M-1,++b),y.length=b+1}static compressInPlaceByPerpendicularDistance(y,k,M=1.0001){const b=y.length;if(b<3)return;let E=0;const D=ki._vector01,R=ki._vectorQ;let X;const z=k*k;let N,Y=1;for(;Y+1<b;Y++){y.vectorIndexIndex(E,Y+1,D),y.vectorIndexIndex(E,Y,R),N=D.magnitudeSquared();const k=Q.conditionalDivideFraction(R.dotProduct(D),N);void 0!==k&&k>=0&&k<=M&&(X=ki._vectorQ.magnitudeSquared()-N*k*k,X<=z)?(y.moveIndexToIndex(Y+1,++E),Y+=1):y.moveIndexToIndex(Y,++E)}Y<b&&y.moveIndexToIndex(Y,++E),y.length=E+1}static compressColinearWrapInPlace(y,k,M){const b=y.length-1;if(b>=3&&y[0].distance(y[b])<k){const k=b-1,E=0,D=1,R=$.createStartEnd(y[k],y[D]),X=$.createStartEnd(y[k],y[E]),z=R.dotProduct(R),N=R.dotProduct(X),Y=Q.conditionalDivideFraction(N,z);if(void 0!==Y&&Y>0&&Y<1){const b=X.magnitudeSquared()-Y*Y*z;Math.sqrt(Math.abs(b))<M&&(y[0]=y[k],y.pop())}}}}ki._vector01=$.create(),ki._vectorQ=$.create();class Mi{static edgeLengthRange(y){const k=ft.createNull();for(let M=1;M<y.length;M++)k.extendX(y[M-1].distance(y[M]));return k}static compressByChordError(y,k){return ki.compressPoint3dArrayByChordError(y,k)}static compressShortEdges(y,k){const M=nt.create(y);return ki.compressInPlaceByShortEdgeLength(M,k),M.getPoint3dArray()}static compressSmallTriangles(y,k){const M=nt.create(y);return ki.compressInPlaceBySmallTriangleArea(M,k),M.getPoint3dArray()}static compressByPerpendicularDistance(y,k,M=2){const b=nt.create(y);let E=b.length;for(let D=0;D<M;D++){ki.compressInPlaceByPerpendicularDistance(b,k);const y=b.length;if(y===E)break;E=y}return b.getPoint3dArray()}static squaredDistanceToInterpolatedPoint(y,k,M,b){const E=1-M,D=y.x-(E*k.x+M*b.x),R=y.y-(E*k.y+M*b.y),X=y.z-(E*k.z+M*b.z);return D*D+R*R+X*X}static isDanglerConfiguration(y,k,M,b,E){if(k<0||k>=y.length)return!1;const D=y[k],R=D.distanceSquared(b);if(R<=E)return!0;if(M<0||M>=y.length)return!1;const X=y[M],z=D.dotVectorsToTargets(X,b);if(z<=0)return!1;const N=D.distanceSquared(X);let Y;if(R>=N){const y=z/R;Y=this.squaredDistanceToInterpolatedPoint(X,D,y,b)}else{const y=z/N;Y=this.squaredDistanceToInterpolatedPoint(b,D,y,X)}return Y<E}static compressDanglers(y,k=!1,M=Q.smallMetricDistance){let b=y.length;const E=M*M;if(k)for(;b>1&&y[b-1].distanceSquared(y[0])<=E;)b--;const D=[];D.push(y[0].clone());for(let R=1;R<b;R++){const k=y[R];for(;this.isDanglerConfiguration(D,D.length-1,D.length-2,k,E);)D.pop();D.push(k.clone())}if(k){let y=0,k=D.length-1;for(;k>y+2;)if(this.isDanglerConfiguration(D,y,y+1,D[k],E))y++;else{if(!this.isDanglerConfiguration(D,k,k-1,D[y],E))break;k--}k+1<D.length&&(D.length=k+1),y>0&&D.splice(0,y)}return D}static addClosurePoint(y){if(0===y.length)return;const k=y[0];if(Array.isArray(k)){for(const k of y)Array.isArray(k)&&this.addClosurePoint(k);return}const M=y[y.length-1];k instanceof j&&M instanceof j&&!k.isAlmostEqual(M)&&y.push(k.clone())}static removeClosurePoint(y){if(0===y.length)return;const k=y[0];if(Array.isArray(k)){for(const k of y)Array.isArray(k)&&this.removeClosurePoint(k);return}const M=y[y.length-1];k instanceof j&&M instanceof j&&k.isAlmostEqual(M)&&y.pop()}static createBisectorPlanesForDistinctPoints(y,k=!1){const M=Mi.compressShortEdges(y,2*Q.smallMetricDistance);if(M.length<2)return;const b=[],E=M[0],D=M[1],R=$.createNormalizedStartEnd(E,D),X=_t.create(E,R),z=_t.createXYPlane();b.push(X.clone());for(let Y=1;Y+1<M.length;Y++)if($.createNormalizedStartEnd(M[Y],M[Y+1],R),void 0!==_t.create(M[Y],R,z)){const y=X.getNormalRef().interpolate(.5,z.getNormalRef()),k=_t.create(M[Y],y);void 0!==k&&b.push(k),X.setFrom(z)}b.push(_t.create(M[M.length-1],X.getNormalRef()));const N=b.length-1;if(N>0&&k){const y=b[0],k=b[N];if(Q.isSamePoint3d(y.getOriginRef(),k.getOriginRef())){const M=y.getNormalRef().plus(k.getNormalRef()),E=_t.create(y.getOriginRef(),M);void 0!==E&&(b[0]=E,b[N]=_t.create(k.getOriginRef(),M))}}return b.length>1?b:void 0}static closestApproach(y,k,M,b,E=Number.MAX_VALUE,D){Array.isArray(y)&&(y=new ce(y)),Array.isArray(M)&&(M=new ce(M));let R=E,X=!1;const z=y.length-1,N=M.length-1,Y=[U.None,U.None],O=[U.None,U.None],u=(y,k,M,b)=>{y[0]=y[1]=U.None,0===M?y[0]=ie.resolveVariantCurveExtendParameterToCurveExtendMode(k,0):M===b-1&&(y[1]=ie.resolveVariantCurveExtendParameterToCurveExtendMode(k,1))},f=(y,k,M)=>void 0===M?Ce.createCapture(y.getPoint3dAtUncheckedPointIndex(k),y.getPoint3dAtUncheckedPointIndex(k+1)):(y.getPoint3dAtUncheckedPointIndex(k,M.point0Ref),y.getPoint3dAtUncheckedPointIndex(k+1,M.point1Ref),M);for(let B=0;B<z;B++){this._workSegmentA=f(y,B,this._workSegmentA),u(Y,k,B,z);for(let y=0;y<N;y++)if(this._workSegmentB=f(M,y,this._workSegmentB),u(O,b,y,N),void 0!==(this._workLocalDetailPair=Ce.closestApproach(this._workSegmentA,Y,this._workSegmentB,O,this._workLocalDetailPair))){const k=this._workLocalDetailPair.detailA.a;if(k<R){const M=D?.detailA.childDetail,b=D?.detailB.childDetail;D=this._workLocalDetailPair.clone(D),Me.convertLocalToGlobalDetail(D.detailA,B,z,void 0,M),Me.convertLocalToGlobalDetail(D.detailB,y,N,void 0,b),D.detailA.childDetail&&D.detailB.childDetail&&(D.detailA.childDetail.curve=D.detailB.childDetail.curve=void 0),R=k,X=!0}}}return X?D:void 0}}class bi extends si{isSameGeometryClass(y){return y instanceof bi}get children(){return this._children}constructor(){super(),this.curveCollectionType="parityRegion",this._children=[]}addLoops(y){if(void 0===y);else if(y instanceof hi)this.children.push(y);else if(Array.isArray(y))for(const k of y)k instanceof hi?this.children.push(k):Array.isArray(k)&&this.addLoops(k)}static createLoops(y){if(y instanceof hi)return y;const k=new bi;return k.addLoops(y),k}static create(...y){const k=new bi;for(const M of y)k.children.push(M);return k}dgnBoundaryType(){return 4}announceToCurveProcessor(y,k=-1){return y.announceParityRegion(this,k)}clone(){const y=new bi;let k;for(k of this.children){const M=k.clone();M instanceof hi&&y.children.push(M)}return y}cloneStroked(y){const k=new bi;let M;for(M of this.children){const b=M.cloneStroked(y);b&&k.children.push(b)}return k}cloneEmptyPeer(){return new bi}tryAddChild(y){return!!(y&&y instanceof hi)&&(this._children.push(y),!0)}getChild(y){if(y<this._children.length)return this._children[y]}dispatchToGeometryHandler(y){return y.handleParityRegion(this)}}class Ei{get quantitySum(){return this.sums.atIJ(3,3)}signFactor(y){return y*this.quantitySum>0?1:-1}setOriginIfNeeded(y){this.needOrigin&&(this.origin.setFromPoint3d(y),this.needOrigin=!1)}setOriginFromGrowableXYZArrayIfNeeded(y){this.needOrigin&&y.length>0&&(y.getPoint3dAtCheckedPointIndex(0,this.origin),this.needOrigin=!1)}setOriginXYZIfNeeded(y,k,M){this.needOrigin&&(this.origin.set(y,k,M),this.needOrigin=!1)}constructor(){this._point0=j.create(),this._point1=j.create(),this.origin=j.createZero(),this.sums=Xt.createZero(),this.localToWorldMap=pt.createIdentity(),this.radiusOfGyration=$.create(),this.needOrigin=!1,this.absoluteQuantity=.1,this.absoluteQuantity=void 0}static create(y,k=!1){const M=new Ei;return M.needOrigin=k,y&&(M.origin.setFromPoint3d(y),M.needOrigin=!1),M}static momentTensorFromInertiaProducts(y){const k=y.sumDiagonal(),M=xt.createScale(k,k,k);return M.addScaledInPlace(y,-1),M}static sortColumnsForIncreasingMoments(y,k){const M=[y.indexedColumnWithWeight(0,k.x),y.indexedColumnWithWeight(1,k.y),y.indexedColumnWithWeight(2,k.z)].sort(((y,k)=>y.w<k.w?-1:y.w>k.w?1:0));y.setColumnsPoint4dXYZ(M[0],M[1],M[2]),y.determinant()<0&&y.scaleColumnsInPlace(-1,-1,-1),y.at(0,0)<0&&y.scaleColumnsInPlace(-1,-1,1),y.at(2,2)<0&&y.scaleColumnsInPlace(1,-1,-1),k.set(M[0].w,M[1].w,M[2].w)}static pointsToPrincipalAxes(y){const k=new Ei;return 0===y.length?k:(k.clearSums(y[0]),k.accumulatePointMomentsFromOrigin(y),this.inertiaProductsToPrincipalAxes(k.origin,k.sums))}static inertiaProductsToPrincipalAxes(y,k){const M=new Ei;if(M.sums.setFrom(k),M.origin.setFrom(y),!M.shiftOriginAndSumsToCentroidOfSums())return;const b=M.sums.matrixPart(),E=M.sums.weight();E<0&&b.scaleColumnsInPlace(-1,-1,-1);const D=Ei.momentTensorFromInertiaProducts(b),R=$.create(),X=xt.createZero();return D.fastSymmetricEigenvalues(X,R),R.x<0?void 0:(Ei.sortColumnsForIncreasingMoments(X,R),E<0&&X.scaleColumnsInPlace(1,-1,-1),M.localToWorldMap=pt.createOriginAndMatrix(M.origin,X),M.radiusOfGyration.set(Math.sqrt(Math.abs(R.x)),Math.sqrt(Math.abs(R.y)),Math.sqrt(Math.abs(R.z))),M.radiusOfGyration.scaleInPlace(1/Math.sqrt(Math.abs(E))),M.absoluteQuantity=Math.abs(E),M)}static areEquivalentPrincipalAxes(y,k){if(y&&k&&Q.isSameCoordinate(y.quantitySum,k.quantitySum)&&y.localToWorldMap.getOrigin().isAlmostEqual(k.localToWorldMap.getOrigin())&&y.radiusOfGyration.isAlmostEqual(k.radiusOfGyration)){if(Q.isSameCoordinate(y.radiusOfGyration.x,y.radiusOfGyration.y)){if(Q.isSameCoordinate(y.radiusOfGyration.x,y.radiusOfGyration.z))return!0;const M=y.localToWorldMap.matrix.columnZ(),b=k.localToWorldMap.matrix.columnZ();return!!M.isParallelTo(b,!0)}const M=$.create(),b=$.create();for(let E=0;E<3;E++)if(y.localToWorldMap.matrix.getColumn(E,M),k.localToWorldMap.matrix.getColumn(E,b),!M.isParallelTo(b,!0))return!1;return!0}return!1}clearSums(y){this.sums.setZero(),y?this.origin.setFrom(y):this.origin.setZero()}accumulatePointMomentsFromOrigin(y){for(const k of y)this.sums.addMomentsInPlace(k.x-this.origin.x,k.y-this.origin.y,k.z-this.origin.z,1)}shiftOriginAndSumsToCentroidOfSums(){const y=this.sums.columnW().realPoint();return!!y&&(this.shiftOriginAndSumsByXYZ(y.x,y.y,y.z),!0)}shiftOriginAndSumsByXYZ(y,k,M){this.origin.addXYZInPlace(y,k,M),this.sums.multiplyTranslationSandwichInPlace(-y,-k,-M)}shiftOriginAndSumsToNewOrigin(y){this.shiftOriginAndSumsByXYZ(y.x-this.origin.x,y.y-this.origin.y,y.z-this.origin.z)}accumulateTriangleMomentsXY(y,k,M){this.setOriginXYZIfNeeded(k.x,k.y,0);const b=this.origin.x,E=this.origin.y,D=Ei._vectorA=void 0!==y?Dt.create(y.x-b,y.y-E,0,1,Ei._vectorA):Dt.create(this.origin.x,this.origin.y,0,1,Ei._vectorA),R=Ei._vectorB=Dt.create(k.x-b,k.y-E,0,1,Ei._vectorB),X=Ei._vectorC=Dt.create(M.x-b,M.y-E,0,1,Ei._vectorC),z=Q.crossProductXYXY(R.x-D.x,R.y-D.y,X.x-D.x,X.y-D.y);if(0!==z){const y=z/12,k=z/24;this.sums.addScaledOuterProductInPlace(D,D,y),this.sums.addScaledOuterProductInPlace(D,R,k),this.sums.addScaledOuterProductInPlace(D,X,k),this.sums.addScaledOuterProductInPlace(R,D,k),this.sums.addScaledOuterProductInPlace(R,R,y),this.sums.addScaledOuterProductInPlace(R,X,k),this.sums.addScaledOuterProductInPlace(X,D,k),this.sums.addScaledOuterProductInPlace(X,R,k),this.sums.addScaledOuterProductInPlace(X,X,y)}}accumulateScaledOuterProduct(y,k){this.setOriginXYZIfNeeded(y.x,y.y,0);const M=Ei._vectorA=Dt.create(y.x-this.origin.x,y.y-this.origin.y,y.z-this.origin.z,1,Ei._vectorA);this.sums.addScaledOuterProductInPlace(M,M,k)}accumulateLineMomentsXYZ(y,k){this.setOriginXYZIfNeeded(y.x,y.y,y.z);const M=this.origin.x,b=this.origin.y,E=this.origin.z,D=Ei._vectorA=Dt.create(y.x-M,y.y-b,y.z-E,1,Ei._vectorA),R=Ei._vectorB=Dt.create(k.x-M,k.y-b,k.z-E,1,Ei._vectorB),X=y.distance(k),z=X/3,N=X/6;this.sums.addScaledOuterProductInPlace(D,D,z),this.sums.addScaledOuterProductInPlace(D,R,N),this.sums.addScaledOuterProductInPlace(R,D,N),this.sums.addScaledOuterProductInPlace(R,R,z)}accumulateTriangleToLineStringMomentsXY(y,k){const M=k.length;if(M>1){k.getPoint3dAtUncheckedPointIndex(0,this._point0);for(let b=1;b<M;b++)k.getPoint3dAtUncheckedPointIndex(b,this._point1),this.accumulateTriangleMomentsXY(y,this._point0,this._point1),this._point0.setFromPoint3d(this._point1)}}accumulateXYProductsInCentroidalFrame(y,k,M,b,E,D,R){const X=Xt.createRowValues(y,k,0,0,k,M,0,0,0,0,0,0,0,0,0,b),z=Q.crossProductXYXY(D.x,R.x,D.y,R.y),N=Xt.createRowValues(D.x,R.x,0,E.x-this.origin.x,D.y,R.y,0,E.y-this.origin.y,0,0,0,0,0,0,0,1),Y=N.multiplyMatrixMatrix(X).multiplyMatrixMatrixTranspose(N);this.sums.addScaledInPlace(Y,z)}accumulateProducts(y,k){this.setOriginIfNeeded(y.origin),this.sums.addTranslationSandwichInPlace(y.sums,this.origin.x-y.origin.x,this.origin.y-y.origin.y,this.origin.z-y.origin.z,k)}accumulateProductsFromOrigin(y,k,M){this.setOriginIfNeeded(y),this.sums.addTranslationSandwichInPlace(k,this.origin.x-y.x,this.origin.y-y.y,this.origin.z-y.z,M)}toJSON(){return{origin:this.origin,sums:this.sums.toJSON(),radiusOfGyration:this.radiusOfGyration.toJSON(),localToWorld:this.localToWorldMap.toJSON()}}}class Ri extends Pe{constructor(y,k,M){super(),this._geometry1=M,this._fraction=k}handleLineSegment3d(y){if(this._geometry1 instanceof Ce){const k=this._geometry1;return Ce.create(y.startPoint().interpolate(this._fraction,k.startPoint()),y.endPoint().interpolate(this._fraction,k.endPoint()))}}handleLineString3d(y){if(this._geometry1 instanceof Me){const k=this._geometry1;if(y.numPoints()===k.numPoints()){const M=y.numPoints(),b=Me.create(),E=j.create(),D=j.create(),R=j.create(),X=this._fraction;for(let z=0;z<M;z++)y.pointAt(z,D),k.pointAt(z,R),D.interpolate(X,R,E),b.addPoint(E);if(y.fractions&&k.fractions)for(let z=0;z<M;z++)b.addFraction(Q.interpolate(y.fractions.atUncheckedIndex(z),X,k.fractions.atUncheckedIndex(z)));if(y.strokeData&&k.strokeData&&(b.strokeData=y.strokeData.clone()),y.packedDerivatives&&k.packedDerivatives){const E=$.create(),D=$.create();for(let R=0;R<M;R++)y.packedDerivatives.getVector3dAtCheckedVectorIndex(R,E),k.packedDerivatives.getVector3dAtCheckedVectorIndex(R,D),b.addDerivative(E.interpolate(X,D))}return b}}}handleArc3d(y){if(this._geometry1 instanceof Ti){const k=this._geometry1;return Ti.create(y.center.interpolate(this._fraction,k.center),y.vector0.interpolate(this._fraction,k.vector0),y.vector90.interpolate(this._fraction,k.vector90),y.sweep.interpolate(this._fraction,k.sweep))}}static interpolateBetween(y,k,M){const b=new Ri(y,k,M);return y.dispatchToGeometryHandler(b)}}class Di extends Ot{constructor(y){super(),this.geometryCategory="solid",this._capped=y}get capped(){return this._capped}set capped(y){this._capped=y}}class Xi extends Di{constructor(y,k,M,b){super(b),this.solidPrimitiveType="cone",this._localToWorld=y,this._radiusA=k,this._radiusB=M,this._maxRadius=Math.max(this._radiusA,this._radiusB)}clone(){return new Xi(this._localToWorld.clone(),this._radiusA,this._radiusB,this.capped)}getConstructiveFrame(){return this._localToWorld.cloneRigid()}tryTransformInPlace(y){return!y.matrix.isSingular()&&(y.multiplyTransformTransform(this._localToWorld,this._localToWorld),!0)}cloneTransformed(y){const k=this.clone();return y.multiplyTransformTransform(k._localToWorld,k._localToWorld),k}static createAxisPoints(y,k,M,b,E){const D=y.vectorTo(k),R=D.magnitude();if(Q.isSmallMetricDistance(R))return;if((M=Q.correctSmallMetricDistance(M))*(b=Q.correctSmallMetricDistance(b))<0)return;if(M+b===0)return;const X=xt.createRigidHeadsUp(D);X.scaleColumns(1,1,R,X);const z=pt.createOriginAndMatrix(y,X);return new Xi(z,M,b,E)}static createBaseAndTarget(y,k,M,b,E,D,R){E=Math.abs(Q.correctSmallMetricDistance(E)),D=Math.abs(Q.correctSmallMetricDistance(D));const X=y.vectorTo(k),z=pt.createOriginAndMatrixColumns(y,M,b,X);return new Xi(z,E,D,R)}getCenterA(){return this._localToWorld.multiplyXYZ(0,0,0)}getCenterB(){return this._localToWorld.multiplyXYZ(0,0,1)}getVectorX(){return this._localToWorld.matrix.columnX()}getVectorY(){return this._localToWorld.matrix.columnY()}getRadiusA(){return this._radiusA}getRadiusB(){return this._radiusB}getMaxRadius(){return this._maxRadius}vFractionToRadius(y){return Q.interpolate(this._radiusA,y,this._radiusB)}isSameGeometryClass(y){return y instanceof Xi}isAlmostEqual(y){return y instanceof Xi&&this.capped===y.capped&&!!this._localToWorld.isAlmostEqualAllowZRotation(y._localToWorld)&&Q.isSameCoordinate(this._radiusA,y._radiusA)&&Q.isSameCoordinate(this._radiusB,y._radiusB)}dispatchToGeometryHandler(y){return y.handleCone(this)}strokeConstantVSection(y,k,M){let b=16;void 0!==k?b=k:void 0!==M&&(b=M.defaultCircleStrokes),b=Q.clampToStartEnd(b,4,64);const E=this.vFractionToRadius(y),D=Me.createForStrokes(k,M),R=2*Math.PI,X=R/b;let z=0;const N=D.fractions,Y=D.packedDerivatives,O=D.packedUVParams,B=D.packedSurfaceNormals,V=j.create(),U=$.create(),L=$.create(),Z=$.create(),q=this._localToWorld;let jr,Gr,Jr,Kr;for(let so=0;so<=b;so++)z=2*so<=b?so*X:(so-b)*X,Jr=Math.cos(z),Kr=Math.sin(z),jr=E*Jr,Gr=E*Kr,q.multiplyXYZ(jr,Gr,y,V),D.addPoint(V),N&&N.push(so/b),Y&&(q.matrix.multiplyXYZ(-Gr*R,jr*R,0,U),Y.push(U)),B&&(q.matrix.multiplyXYZ(-Kr,Jr,0,U),q.matrix.multiplyXYZ(0,0,1,L),U.unitCrossProduct(L,Z),B.push(Z)),O&&O.pushXY(so/b,y);return D}constantVSection(y){const k=this.vFractionToRadius(y),M=this._localToWorld,b=M.multiplyXYZ(0,0,y),E=M.matrix.multiplyXYZ(k,0,0),D=M.matrix.multiplyXYZ(0,k,0);return hi.create(Ti.create(b,E,D))}extendRange(y,k){const M=this.constantVSection(0),b=this.constantVSection(1);M.extendRange(y,k),b.extendRange(y,k)}uvFractionToPoint(y,k,M){const b=y*Math.PI*2,E=Q.interpolate(this._radiusA,k,this._radiusB),D=Math.cos(b),R=Math.sin(b);return this._localToWorld.multiplyXYZ(E*D,E*R,k,M)}uvFractionToPointAndTangents(y,k,M){const b=y*Math.PI*2,E=Q.interpolate(this._radiusA,k,this._radiusB),D=this._radiusB-this._radiusA,R=Math.cos(b),X=Math.sin(b),z=2*Math.PI;return Et.createOriginAndVectors(this._localToWorld.multiplyXYZ(E*R,E*X,k),this._localToWorld.multiplyVectorXYZ(-E*X*z,E*R*z,0),this._localToWorld.multiplyVectorXYZ(D*R,D*X,1),M)}get isClosedVolume(){return this.capped}maxIsoParametricDistance(){const y=this._localToWorld.matrix.columnX(),k=this._localToWorld.matrix.columnY(),M=this._localToWorld.matrix.columnZ(),b=y.unitCrossProduct(k),E=b.dotProduct(M),D=M.plusScaled(b,E).magnitudeXY();return J.create(2*Math.PI*Math.max(this._radiusA,this._radiusB),Q.hypotenuseXY(Math.abs(this._radiusB-this._radiusA)+D,E))}}class zi{constructor(y,k=8,M){this._data=new Float64Array(k*y),this._inUse=0,this._blockSize=y>0?y:1,this._growthFactor=void 0!==M&&M>=1?M:1.5}copyData(y,k,M){let b=void 0!==M?M*this.numPerBlock:0;if(b<0&&(b=0),b>=this._data.length)return{count:0,offset:0};let E=void 0!==k?k*this.numPerBlock:y.length;return E>0&&(E>y.length&&(E=y.length),b+E>this._data.length&&(E=this._data.length-b),E%this.numPerBlock!=0&&(E-=E%this.numPerBlock)),E<=0?{count:0,offset:0}:(E===y.length?this._data.set(y,b):y instanceof Float64Array?this._data.set(y.subarray(0,E),b):this._data.set(y.slice(0,E),b),{count:E/this.numPerBlock,offset:b/this.numPerBlock})}clone(){const y=new zi(this.numPerBlock,this.numBlocks,this._growthFactor);return y.copyData(this._data,this.numBlocks),y._inUse=this.numBlocks,y}get length(){return this._inUse}get numBlocks(){return this._inUse}get numPerBlock(){return this._blockSize}getWithinBlock(y,k){return this._data[y*this._blockSize+k]}clear(){this._inUse=0}blockCapacity(){return this._data.length/this._blockSize}ensureBlockCapacity(y,k=!0){if(y>this.blockCapacity()){k&&(y*=this._growthFactor);const M=this._data;this._data=new Float64Array(y*this._blockSize),this.copyData(M,this._inUse)}}addBlock(y){const k=this.newBlockIndex();let M=y.length;M>this._blockSize&&(M=this._blockSize);for(let b=0;b<M;b++)this._data[k+b]=y[b]}newBlockIndex(){const y=this._blockSize*this._inUse;y+1>this._data.length&&this.ensureBlockCapacity(1+this._inUse),this._inUse++;for(let k=y;k<y+this._blockSize;k++)this._data[k]=0;return y}popBlock(){this._inUse>0&&this._inUse--}blockIndexToDoubleIndex(y){return this._blockSize*y}checkedComponent(y,k){if(!(y>=this._inUse||y<0||k<0||k>=this._blockSize))return this._data[this._blockSize*y+k]}component(y,k){return this._data[this._blockSize*y+k]}static compareLexicalBlock(y,k,M,b){let E=0,D=0;for(let R=0;R<k;R++){if(E=y[M+R],D=y[b+R],E>D)return 1;if(E<D)return-1}return M-b}sortIndicesLexical(y=(y,k,M,b)=>zi.compareLexicalBlock(y,k,M,b)){const k=this._inUse,M=new Uint32Array(k),b=this._data,E=this._blockSize;for(let D=0;D<k;D++)M[D]=D;return M.sort(((k,M)=>y(b,E,k*E,M*E))),M}distanceBetweenBlocks(y,k){let M=0,b=this.blockIndexToDoubleIndex(y),E=this.blockIndexToDoubleIndex(k),D=0;const R=this._data;for(let X=0;X<this._blockSize;X++)D=R[b++]-R[E++],M+=D*D;return Math.sqrt(M)}distanceBetweenSubBlocks(y,k,M,b){let E=0;const D=this.blockIndexToDoubleIndex(y),R=this.blockIndexToDoubleIndex(k);let X=0;const z=this._data;for(let N=M;N<b;N++)X=z[D+N]-z[R+N],E+=X*X;return Math.sqrt(E)}}class Ni extends zi{static sortVectorComponent(y){let k=1;for(let M=1;M<y;M++)k*=Ni._vectorFactor;return k}constructor(y,k,M){super(1+y+k,M),this._numExtraDataPerPoint=k,this._numCoordinatePerPoint=y}addBlock(y){const k=this.newBlockIndex()+1,M=Math.min(this.numPerBlock-1,y.length);for(let b=0;b<M;b++)this._data[k+b]=y[b]}addDirect(y,k,M,b,E){const D=this.newBlockIndex();this._data[D+1]=y,void 0!==k&&(this._data[D+2]=k),void 0!==M&&(this._data[D+3]=M),void 0!==b&&(this._data[D+4]=b),void 0!==E&&(this._data[D+5]=E)}addPoint2d(y,k,M,b){const E=this.newBlockIndex();this._data[E+1]=y.x,this._data[E+2]=y.y,void 0!==k&&(this._data[E+3]=k),void 0!==M&&(this._data[E+4]=M),void 0!==b&&(this._data[E+5]=b)}addPoint3d(y,k,M,b){const E=this.newBlockIndex();this._data[E+1]=y.x,this._data[E+2]=y.y,this._data[E+3]=y.z,void 0!==k&&(this._data[E+4]=k),void 0!==M&&(this._data[E+5]=M),void 0!==b&&(this._data[E+6]=b)}getPoint2d(y,k){const M=this.blockIndexToDoubleIndex(y);return H.create(this._data[M+1],this._data[M+2],k)}getPoint3d(y,k){const M=this.blockIndexToDoubleIndex(y);return j.create(this._data[M+1],this._data[M+2],this._data[M+3],k)}getExtraData(y,k){const M=this.blockIndexToDoubleIndex(y);return this._data[M+1+this._numCoordinatePerPoint+k]}getData(y,k){const M=this.blockIndexToDoubleIndex(y);return this._data[M+k]}setExtraData(y,k,M){const b=this.blockIndexToDoubleIndex(y);this._data[b+1+this._numCoordinatePerPoint+k]=M}static isClusterTerminator(y){return y===Ni.clusterTerminator}clusterIndicesLexical(y=Q.smallMetricDistance){this.setupPrimaryClusterSort();const k=this.sortIndicesLexical(),M=new Uint32Array(2*k.length);let b=0;const E=this.numBlocks;let D=0,R=0,X=0,z=0,N=0;const Y=1+this._numCoordinatePerPoint;for(z=0;z<E;z++)if(D=k[z],!Ni.isClusterTerminator(D)){for(M[b++]=D,X=this.component(D,0)+y,k[z]=Ni.clusterTerminator,N=z+1;N<E;N++)if(R=k[N],R!==Ni.clusterTerminator){if(this.component(R,0)>=X)break;this.distanceBetweenSubBlocks(D,R,1,Y)<y&&(M[b++]=R,k[N]=Ni.clusterTerminator)}M[b++]=Ni.clusterTerminator}return M.slice(0,b)}setupPrimaryClusterSort(){const y=this.numBlocks,k=this._numCoordinatePerPoint,M=new Float64Array(k);M[0]=1;for(let R=1;R<k;R++)M[R]=M[R-1]*Ni._vectorFactor;let b=0,E=0;const D=this._data;for(let R=0;R<y;R++){b=this.blockIndexToDoubleIndex(R),E=0;for(let y=0;y<k;y++)E+=M[y]*D[b+1+y];D[b]=E}}toJSON(){const y=[];for(let k=0;k<this.numBlocks;k++){let M=this.blockIndexToDoubleIndex(k);const b=[k,this._data[M++]],E=[];for(let y=0;y<this._numCoordinatePerPoint;y++)E.push(this._data[M++]);b.push(E);for(let y=0;y<this._numExtraDataPerPoint;y++)b.push(this._data[M++]);y.push(b)}return y}createIndexBlockToClusterIndex(y){const k=this.numBlocks,M=new Uint32Array(k);M.fill(Ni.clusterTerminator);let b=0;for(const E of y)E>=k?b++:M[E]=b;return M}createIndexBlockToClusterStart(y){const k=y.length,M=this.numBlocks,b=new Uint32Array(M),E=Ni.clusterTerminator;b.fill(E);let D=0;for(let R=0;R<k;R++){const k=y[R];k>M?D=R+1:b[k]=D}return b}countClusters(y){let k=0;const M=Ni.clusterTerminator;for(const b of y)b===M&&k++;return k}createIndexClusterToClusterStart(y){let k=this.countClusters(y);const M=new Uint32Array(k),b=Ni.clusterTerminator;M.fill(b);const E=y.length;let D=0;for(let R=0;R<E;R++)y[R]===b?D=R+1:R===D&&(M[k++]=D);return M}sortSubsetsBySingleKey(y,k){const M=1+k;let b,E,D,R=0;const X=y.length;for(let z=0;z<X;z++)if(y[z]===Ni.clusterTerminator){for(let k=R;k+1<z;k++){E=this.getWithinBlock(y[k],M);for(let R=k+1;R<z;R++)D=this.getWithinBlock(y[R],M),D<E&&(b=y[k],y[k]=y[R],y[R]=b,E=D)}R=z+1}}static clusterPoint3dArray(y,k=Q.smallMetricDistance){const M=new Ni(3,0,y.length);y.forEach((y=>{M.addDirect(y.x,y.y,y.z)}));const b=M.clusterIndicesLexical(k),E=new Yi(y.length);let D=0,R=0;return b.forEach((k=>{Ni.isClusterTerminator(k)?(D++,R=0):(0===R&&E.packedPoints.push(y[k].clone()),E.oldToNew[k]=D,R++)})),E}static clusterNumberArray(y,k=Q.smallMetricDistance){const M=new Ni(1,0,y.length);y.forEach((y=>{M.addDirect(y)}));const b=M.clusterIndicesLexical(k),E=new Vi(y.length);let D=0,R=0;return b.forEach((k=>{Ni.isClusterTerminator(k)?(D++,R=0):(0===R&&E.packedNumbers.push(y[k]),E.oldToNew[k]=D,R++)})),E}static clusterGrowablePoint2dArray(y,k=Q.smallMetricDistance){const M=new Ni(2,0,y.length),b=H.create(),E=y.length;for(let Y=0;Y<E;Y++)y.getPoint2dAtUncheckedPointIndex(Y,b),M.addDirect(b.x,b.y);const D=M.clusterIndicesLexical(k),R=M.countClusters(D),X=new Bi(y.length,R);let z=0,N=0;return D.forEach((k=>{Ni.isClusterTerminator(k)?(z++,N=0):(0===N&&X.growablePackedPoints.pushFromGrowableXYArray(y,k),X.oldToNew[k]=z,N++)})),X}static clusterGrowablePoint3dArray(y,k=Q.smallMetricDistance){const M=new Ni(3,0,y.length),b=j.create(),E=y.length;for(let Y=0;Y<E;Y++)y.getPoint3dAtUncheckedPointIndex(Y,b),M.addDirect(b.x,b.y,b.z);const D=M.clusterIndicesLexical(k),R=new Yi(y.length),X=M.countClusters(D);R.growablePackedPoints=new nt(X);let z=0,N=0;return D.forEach((k=>{Ni.isClusterTerminator(k)?(z++,N=0):(0===N&&R.growablePackedPoints.pushFromGrowableXYZArray(y,k),R.oldToNew[k]=z,N++)})),R}}function Oi(y,k){let M=0;return y.forEach(((y,b,E)=>{y<k.length?E[b]=k[y]:M++})),0===M}Ni._vectorFactor=.8732,Ni.clusterTerminator=4294967295;class Yi{constructor(y){this.packedPoints=[],this.oldToNew=new Uint32Array(y);for(let k=0;k<y;k++)this.oldToNew[k]=Yi.invalidIndex}updateIndices(y){return Oi(y,this.oldToNew)}}Yi.invalidIndex=4294967295;class Bi{constructor(y,k){this.growablePackedPoints=new Fe(k),this.oldToNew=new Uint32Array(y);for(let M=0;M<y;M++)this.oldToNew[M]=Bi.invalidIndex}updateIndices(y){return Oi(y,this.oldToNew)}}Bi.invalidIndex=4294967295;class Vi{constructor(y){this.packedNumbers=[],this.oldToNew=new Uint32Array(y);for(let k=0;k<y;k++)this.oldToNew[k]=Yi.invalidIndex}updateIndices(y){return Oi(y,this.oldToNew)}}Vi.invalidIndex=4294967295,function(y){y[y.Scalar=0]="Scalar",y[y.Distance=1]="Distance",y[y.Vector=2]="Vector",y[y.Normal=3]="Normal"}(jr||(jr={}));class Li{constructor(y,k){if(this.input=y,k instanceof Float64Array){this.values=[];for(const y of k)this.values.push(y)}else this.values=k}copyValues(y,k,M,b){for(let E=0;E<b;E++)this.values[k*b+E]=y.values[M*b+E]}clone(){return new Li(this.input,this.values.slice())}isAlmostEqual(y,k){const M=k||1e-8;return Math.abs(this.input-y.input)<M&&he.isAlmostEqual(this.values,y.values,M)}}class Ui{constructor(y,k,M,b){this.data=y,this.dataType=k,this.name=M,this.inputName=b}clone(){const y=[];for(const k of this.data)y.push(k.clone());return new Ui(y,this.dataType,this.name,this.inputName)}isAlmostEqual(y,k){if(this.dataType!==y.dataType||this.name!==y.name||this.inputName!==y.inputName||this.data.length!==y.data.length)return!1;for(let M=0;M<this.data.length;M++)if(!this.data[M].isAlmostEqual(y.data[M],k))return!1;return!0}static isScalar(y){return y===jr.Distance||y===jr.Scalar}get isScalar(){return Ui.isScalar(this.dataType)}static entriesPerValue(y){return this.isScalar(y)?1:3}get entriesPerValue(){return Ui.entriesPerValue(this.dataType)}get valueCount(){return 0===this.data.length?0:this.data[0].values.length/this.entriesPerValue}get scalarRange(){if(!this.isScalar)return;const y=ft.createNull();for(const k of this.data)y.extendArray(k.values);return y}computeDisplacementRange(y=1,k){if(k=ut.createNull(k),jr.Vector===this.dataType)for(const M of this.data){const b=M.values;for(let M=0;M<b.length;M+=3)k.extendXYZ(b[M]*y,b[M+1]*y,b[M+2]*y)}return k}}class Zi{constructor(y,k){this.channels=y,this.indices=k}clone(){const y=this.channels.map((y=>y.clone()));return new Zi(y,this.indices.slice())}isAlmostEqual(y,k){if(!he.isExactEqual(this.indices,y.indices)||this.channels.length!==y.channels.length)return!1;for(let M=0;M<this.channels.length;M++)if(!this.channels[M].isAlmostEqual(y.channels[M],k))return!1;return!0}static isAlmostEqual(y,k,M){return y===k||!(!y||!k)&&y.isAlmostEqual(k,M)}createForVisitor(){const y=[];for(const k of this.channels){const M=[];for(const y of k.data)M.push(new Li(y.input,[]));y.push(new Ui(M,k.dataType,k.name,k.inputName))}return new Zi(y,[])}tryTransformInPlace(y){let k;const M=y.matrix,b=M.determinant(),E=Math.pow(Math.abs(b),1/3)*(b>=0?1:-1);for(const D of this.channels)for(const y of D.data)switch(D.dataType){case jr.Scalar:continue;case jr.Distance:for(let k=0;k<y.values.length;k++)y.values[k]*=E;break;case jr.Normal:if(k=k??M.inverse(),!k)return!1;qi(y.values,(y=>k.multiplyTransposeVectorInPlace(y)));break;case jr.Vector:qi(y.values,(y=>M.multiplyVectorInPlace(y)))}return!0}}function qi(y,k){const M=new j;for(let b=0;b<y.length;b+=3)M.set(y[b],y[b+1],y[b+2]),k(M),y[b]=M.x,y[b+1]=M.y,y[b+2]=M.z}!function(y){let k,M,b;!function(y){y[y.SubdivisionSurface=-1e3]="SubdivisionSurface"}(k=y.TaggedNumericTagType||(y.TaggedNumericTagType={})),function(y){y[y.ChooseBasedOnFacets=0]="ChooseBasedOnFacets",y[y.CatmullClark=1]="CatmullClark",y[y.Loop=2]="Loop",y[y.DooSabin=3]="DooSabin"}(M=y.SubdivisionMethod||(y.SubdivisionMethod={})),function(y){y[y.FixedDepth=-100]="FixedDepth",y[y.AbsoluteTolerance=-101]="AbsoluteTolerance",y[y.FractionOfRangeBoxTolerance=-102]="FractionOfRangeBoxTolerance"}(b=y.SubdivisionControlCode||(y.SubdivisionControlCode={}))}(Gr||(Gr={}));class Wi{constructor(y=0,k=0,M,b){this.tagA=y,this.tagB=k,M&&(this.intData=M),b&&(this.doubleData=b)}pushIntPair(y,k){this.intData||(this.intData=[]),this.intData.push(y),this.intData.push(k)}pushIndexedDouble(y,k){this.intData||(this.intData=[]),this.doubleData||(this.doubleData=[]),this.intData.push(y),this.intData.push(this.doubleData.length),this.doubleData.push(k)}tagToInt(y,k,M,b){if(this.intData)for(let E=0;E+1<this.intData.length;E+=2)if(this.intData[E]===y)return Math.min(Math.max(this.intData[E+1],k),M);return b}tagToIndexedDouble(y,k,M,b){if(this.intData)for(let E=0;E+1<this.intData.length;E+=2)if(this.intData[E]===y)return Q.clamp(this.getDoubleData(this.intData[E+1],b),k,M);return b}getDoubleData(y,k){return this.doubleData&&0<=y&&y<this.doubleData.length?this.doubleData[y]:k}isAlmostEqual(y){return void 0!==y&&this.tagA===y.tagA&&this.tagB===y.tagB&&Q.exactEqualNumberArrays(this.intData,y.intData)&&Q.almostEqualArrays(this.doubleData,y.doubleData,((y,k)=>Q.isAlmostEqualNumber(y,k)))}static areAlmostEqual(y,k){return void 0===y&&void 0===k||void 0!==y&&void 0!==k&&y.isAlmostEqual(k)}clone(y){return y||(y=new Wi(this.tagA,this.tagB)),this.intData&&(y.intData=this.intData.slice()),this.doubleData&&(y.doubleData=this.doubleData.slice()),y}}class Gi{constructor(y=!1,k=!1,M=!1,b=!1){this.point=new nt,this.pointIndex=[],y&&(this.normal=new nt,this.normalIndex=[]),k&&(this.param=new Fe,this.paramIndex=[]),M&&(this.color=[],this.colorIndex=[]),this.face=[],this.edgeVisible=[],this._twoSided=b,this._expectedClosure=0}clone(){const y=new Gi;return y.point=this.point.clone(),y.pointIndex=this.pointIndex.slice(),this.normal&&(y.normal=this.normal.clone()),this.normalIndex&&(y.normalIndex=this.normalIndex.slice()),this.param&&(y.param=this.param.clone()),this.paramIndex&&(y.paramIndex=this.paramIndex.slice()),this.color&&(y.color=this.color.slice()),this.colorIndex&&(y.colorIndex=this.colorIndex.slice()),y.face=this.face.slice(),this.auxData&&(y.auxData=this.auxData.clone()),this.taggedNumericData&&(y.taggedNumericData=this.taggedNumericData.clone()),y.edgeVisible=this.edgeVisible.slice(),y.twoSided=this.twoSided,y.expectedClosure=this.expectedClosure,y}isAlmostEqual(y){return!!(nt.isAlmostEqual(this.point,y.point)&&he.isExactEqual(this.pointIndex,y.pointIndex)&&nt.isAlmostEqual(this.normal,y.normal)&&he.isExactEqual(this.normalIndex,y.normalIndex)&&Fe.isAlmostEqual(this.param,y.param)&&he.isExactEqual(this.paramIndex,y.paramIndex)&&he.isExactEqual(this.color,y.color)&&he.isExactEqual(this.colorIndex,y.colorIndex)&&Zi.isAlmostEqual(this.auxData,y.auxData)&&Wi.areAlmostEqual(this.taggedNumericData,y.taggedNumericData)&&he.isExactEqual(this.edgeVisible,y.edgeVisible)&&this.twoSided===y.twoSided&&this.expectedClosure===y.expectedClosure)}get requireNormals(){return void 0!==this.normal}get requireParams(){return void 0!==this.param}get requireColors(){return void 0!==this.color}get pointCount(){return this.point.length}get normalCount(){return this.normal?this.normal.length:0}get paramCount(){return this.param?this.param.length:0}get colorCount(){return this.color?this.color.length:0}get indexCount(){return this.pointIndex.length}get faceCount(){return this.face.length}getPoint(y,k){return this.point.getPoint3dAtCheckedPointIndex(y,k)}getNormal(y,k){return this.normal?this.normal.getVector3dAtCheckedVectorIndex(y,k):void 0}getParam(y,k){return this.param?this.param.getPoint2dAtCheckedPointIndex(y,k):void 0}getColor(y){return this.color?this.color[y]:0}getEdgeVisible(y){return this.edgeVisible[y]}get twoSided(){return this._twoSided}set twoSided(y){this._twoSided=y}get expectedClosure(){return this._expectedClosure}set expectedClosure(y){this._expectedClosure=y}setTaggedNumericData(y){this.taggedNumericData=y}copyPointTo(y,k){this.point.getPoint3dAtUncheckedPointIndex(y,k)}copyNormalTo(y,k){this.normal&&this.normal.getVector3dAtUncheckedVectorIndex(y,k)}copyParamTo(y,k){this.param&&this.param.getPoint2dAtUncheckedPointIndex(y,k)}isAlmostEqualParamIndexUV(y,k,M){return void 0!==this.param&&y>=0&&y<this.param.length&&Q.isSameCoordinate(k,this.param.getXAtUncheckedPointIndex(y))&&Q.isSameCoordinate(M,this.param.getYAtUncheckedPointIndex(y))}gatherIndexedData(y,k,M,b){const E=M-k;b>E&&(b=E);const D=E+b;this.resizeAllArrays(D);for(let R=0;R<E;R++)this.point.transferFromGrowableXYZArray(R,y.point,y.pointIndex[k+R]);for(let R=0;R<b;R++)this.point.transferFromGrowableXYZArray(E+R,this.point,R);for(let R=0;R<E;R++)this.pointIndex[R]=y.pointIndex[k+R];for(let R=0;R<b;R++)this.pointIndex[E+R]=this.pointIndex[R];if(this.normal&&this.normalIndex&&y.normal&&y.normalIndex){for(let M=0;M<E;M++)this.normal.transferFromGrowableXYZArray(M,y.normal,y.normalIndex[k+M]);for(let y=0;y<b;y++)this.normal.transferFromGrowableXYZArray(E+y,this.normal,y);for(let M=0;M<E;M++)this.normalIndex[M]=y.normalIndex[k+M];for(let y=0;y<b;y++)this.normalIndex[E+y]=this.normalIndex[y]}if(this.param&&this.paramIndex&&y.param&&y.paramIndex){for(let M=0;M<E;M++)this.param.transferFromGrowableXYArray(M,y.param,y.paramIndex[k+M]);for(let y=0;y<b;y++)this.param.transferFromGrowableXYArray(E+y,this.param,y);for(let M=0;M<E;M++)this.paramIndex[M]=y.paramIndex[k+M];for(let y=0;y<b;y++)this.paramIndex[E+y]=this.paramIndex[y]}if(this.color&&this.colorIndex&&y.color&&y.colorIndex){for(let M=0;M<E;M++)this.color[M]=y.color[y.colorIndex[k+M]];for(let y=0;y<b;y++)this.color[E+y]=this.color[y];for(let M=0;M<E;M++)this.colorIndex[M]=y.colorIndex[k+M];for(let y=0;y<b;y++)this.colorIndex[E+y]=this.colorIndex[y]}for(let R=0;R<E;R++)this.edgeVisible[R]=y.edgeVisible[k+R];for(let R=0;R<b;R++)this.edgeVisible[E+R]=this.edgeVisible[R];if(this.auxData&&y.auxData&&this.auxData.channels.length===y.auxData.channels.length){for(let M=0;M<this.auxData.channels.length;M++){const D=this.auxData.channels[M],R=y.auxData.channels[M],X=D.entriesPerValue;if(D.data.length===R.data.length)for(let M=0;M<D.data.length;M++){const z=D.data[M],N=R.data[M];for(let M=0;M<E;M++)z.copyValues(N,M,y.auxData.indices[k+M],X);for(let k=0;k<b;k++)z.copyValues(z,y.auxData.indices[E+k],k,X)}}for(let M=0;M<E;M++)this.auxData.indices[M]=y.auxData.indices[k+M];for(let y=0;y<b;y++)this.auxData.indices[E+y]=this.auxData.indices[y]}}static trimArray(y,k){y&&k<y.length&&(y.length=k)}trimAllIndexArrays(y){if(Gi.trimArray(this.pointIndex,y),Gi.trimArray(this.paramIndex,y),Gi.trimArray(this.normalIndex,y),Gi.trimArray(this.colorIndex,y),Gi.trimArray(this.edgeVisible,y),this.auxData){Gi.trimArray(this.auxData.indices,y);for(const k of this.auxData.channels)for(const M of k.data)Gi.trimArray(M.values,k.entriesPerValue*y)}}resizeAllArrays(y){if(y>this.point.length){for(;this.point.length<y;)this.point.push(j.create());for(;this.pointIndex.length<y;)this.pointIndex.push(-1);if(this.normal)for(;this.normal.length<y;)this.normal.push($.create());if(this.normalIndex)for(;this.normalIndex.length<y;)this.normalIndex.push(-1);if(this.param)for(;this.param.length<y;)this.param.push(H.create());if(this.paramIndex)for(;this.paramIndex.length<y;)this.paramIndex.push(-1);if(this.color)for(;this.color.length<y;)this.color.push(0);if(this.colorIndex)for(;this.colorIndex.length<y;)this.colorIndex.push(-1);for(;this.edgeVisible.length<y;)this.edgeVisible.push(!1);if(this.auxData){for(const k of this.auxData.channels)for(const M of k.data)for(;M.values.length<y*k.entriesPerValue;)M.values.push(0);this.auxData.indices&&this.auxData.indices.push(-1)}}else if(y<this.point.length&&(this.point.resize(y),this.pointIndex.length=y,this.normal&&this.normal.resize(y),this.normalIndex&&(this.normalIndex.length=y),this.param&&this.param.resize(y),this.paramIndex&&(this.paramIndex.length=y),this.color&&(this.color.length=y),this.colorIndex&&(this.colorIndex.length=y),this.edgeVisible.length=y,this.auxData)){for(const k of this.auxData.channels)for(const M of k.data)M.values.length=y*k.entriesPerValue;this.auxData.indices&&(this.auxData.indices.length=y)}}resizeAllDataArrays(y){if(y>this.point.length){for(;this.point.length<y;)this.point.push(j.create());for(;this.pointIndex.length<y;)this.pointIndex.push(-1);for(;this.edgeVisible.length<y;)this.edgeVisible.push(!1);if(this.normal)for(;this.normal.length<y;)this.normal.push($.create());if(this.param)for(;this.param.length<y;)this.param.push(H.create());if(this.color)for(;this.color.length<y;)this.color.push(0);if(this.auxData)for(const k of this.auxData.channels)for(const M of k.data)for(;M.values.length<y*k.entriesPerValue;)M.values.push(0)}else if(y<this.point.length&&(this.point.resize(y),this.edgeVisible.length=y,this.pointIndex.length=y,this.normal&&this.normal.resize(y),this.param&&this.param.resize(y),this.color&&(this.color.length=y),this.auxData))for(const k of this.auxData.channels)for(const M of k.data)M.values.length=y*k.entriesPerValue}range(y,k){return(y=y||ut.createNull()).extendArray(this.point,k),y}tryTransformInPlace(y){return this.point.multiplyTransformInPlace(y),this.normal&&!y.matrix.isIdentity&&this.normal.multiplyAndRenormalizeMatrix3dInverseTransposeInPlace(y.matrix),void 0===this.auxData||this.auxData.tryTransformInPlace(y)}compress(y=Q.smallMetricDistance){const k=Ni.clusterGrowablePoint3dArray(this.point,y);if(this.point=k.growablePackedPoints,k.updateIndices(this.pointIndex),this.normalIndex&&this.normal){const y=Ni.clusterGrowablePoint3dArray(this.normal);this.normal=y.growablePackedPoints,y.updateIndices(this.normalIndex)}if(this.paramIndex&&this.param){const y=Ni.clusterGrowablePoint2dArray(this.param);this.param=y.growablePackedPoints,y.updateIndices(this.paramIndex)}if(this.colorIndex&&this.color){const y=Ni.clusterNumberArray(this.color);this.color=y.packedNumbers,y.updateIndices(this.colorIndex)}if(this.auxData&&1===this.auxData.channels.length&&1===this.auxData.channels[0].data.length){const y=this.auxData.channels[0].entriesPerValue;if(1===y){const y=Ni.clusterNumberArray(this.auxData.channels[0].data[0].values);this.auxData.channels[0].data[0].values=y.packedNumbers,y.updateIndices(this.auxData.indices)}else if(3===y){const y=nt.create(this.auxData.channels[0].data[0].values),k=Ni.clusterGrowablePoint3dArray(y);this.auxData.channels[0].data[0].values=he.create(k.growablePackedPoints.float64Data()),k.updateIndices(this.auxData.indices)}}}static isValidFacetStartIndexArray(y){if(0===y.length)return!1;for(let k=0;k+1<y.length;k++)if(y[k]>=y[k+1])return!1;return!0}static reverseIndices(y,k,M){if(!k||0===k.length)return!0;if(k.length>0&&y[y.length-1]===k.length){for(let b=0;b+1<y.length;b++){let E=y[b],D=y[b+1];if(M)for(;D>E+2;){D--,E++;const y=k[E];k[E]=k[D],k[D]=y}else for(;D>E+1;){D--;const y=k[E];k[E]=k[D],k[D]=y,E++}}return!0}return!1}static reverseIndicesSingleFacet(y,k,M,b){if(!M||0===M.length)return!0;if(M.length>0&&k[k.length-1]===M.length&&y>=0&&y+1<k.length){let E=k[y],D=k[y+1];if(b)for(;D>E+2;){D--,E++;const y=M[E];M[E]=M[D],M[D]=y}else for(;D>E+1;){D--;const y=M[E];M[E]=M[D],M[D]=y,E++}return!0}return!1}reverseIndices(y){y&&Gi.isValidFacetStartIndexArray(y)&&(Gi.reverseIndices(y,this.pointIndex,!0),this.normalIndex!==this.pointIndex&&Gi.reverseIndices(y,this.normalIndex,!0),this.paramIndex!==this.pointIndex&&Gi.reverseIndices(y,this.paramIndex,!0),this.colorIndex!==this.pointIndex&&Gi.reverseIndices(y,this.colorIndex,!0),Gi.reverseIndices(y,this.edgeVisible,!1))}reverseIndicesSingleFacet(y,k){Gi.reverseIndicesSingleFacet(y,k,this.pointIndex,!0),this.normalIndex!==this.pointIndex&&Gi.reverseIndicesSingleFacet(y,k,this.normalIndex,!0),this.paramIndex!==this.pointIndex&&Gi.reverseIndicesSingleFacet(y,k,this.paramIndex,!0),this.colorIndex!==this.pointIndex&&Gi.reverseIndicesSingleFacet(y,k,this.colorIndex,!0),Gi.reverseIndicesSingleFacet(y,k,this.edgeVisible,!1)}reverseNormals(){this.normal&&this.normal.scaleInPlace(-1)}}Gi.planarityLocalRelTol=1e-13;class Hi extends Gi{constructor(y,k){super(y.data.normalCount>0,y.data.paramCount>0,y.data.colorCount>0,y.twoSided),this._polyface=y,this._numWrap=k,y.data.auxData&&(this.auxData=y.data.auxData.createForVisitor()),this.reset(),this._numEdges=0,this._nextFacetIndex=0,this._currentFacetIndex=-1}clientPolyface(){return this._polyface}getVisitableFacetCount(){return this._polyface.facetCount}setNumWrap(y){this._numWrap=y}get numEdgesThisFacet(){return this._numEdges}static create(y,k){return new Hi(y,k)}moveToReadIndex(y){return!!this._polyface.isValidFacetIndex(y)&&(this._currentFacetIndex=y,this._nextFacetIndex=y+1,this._numEdges=this._polyface.numEdgeInFacet(y),this.resizeAllArrays(this._numEdges+this._numWrap),this.gatherIndexedData(this._polyface.data,this._polyface.facetIndex0(this._currentFacetIndex),this._polyface.facetIndex1(this._currentFacetIndex),this._numWrap),!0)}moveToNextFacet(){return this._nextFacetIndex!==this._currentFacetIndex?this.moveToReadIndex(this._nextFacetIndex):(this._nextFacetIndex++,!0)}reset(){this.moveToReadIndex(0),this._nextFacetIndex=0}tryGetDistanceParameter(y,k){if(y<0||y>=this.numEdgesThisFacet)return;if(void 0===this.param||0===this._polyface.data.face.length)return;const M=this._polyface.tryGetFaceData(this._currentFacetIndex);return M?M.convertParamXYToDistance(this.param.getXAtUncheckedPointIndex(y),this.param.getYAtUncheckedPointIndex(y),k):void 0}tryGetNormalizedParameter(y,k){if(y<0||y>=this.numEdgesThisFacet)return;if(void 0===this.param||0===this._polyface.data.face.length)return;const M=this._polyface.tryGetFaceData(this._currentFacetIndex);return M?M.convertParamXYToNormalized(this.param.getXAtUncheckedPointIndex(y),this.param.getYAtUncheckedPointIndex(y),k):void 0}currentReadIndex(){return this._currentFacetIndex}clientPointIndex(y){return this.pointIndex[y]}clientParamIndex(y){return this.paramIndex?this.paramIndex[y]:-1}clientNormalIndex(y){return this.normalIndex?this.normalIndex[y]:-1}clientColorIndex(y){return this.colorIndex?this.colorIndex[y]:-1}clientAuxIndex(y){return this.auxData?this.auxData.indices[y]:-1}clearArrays(){this.point.length=0,this.edgeVisible.length=0,void 0!==this.param&&(this.param.length=0),void 0!==this.normal&&(this.normal.length=0),void 0!==this.color&&(this.color.length=0)}pushDataFrom(y,k){this.point.pushFromGrowableXYZArray(y.point,k),this.edgeVisible.push(y.edgeVisible[k]),this.param&&y.param&&k<y.param.length&&this.param.pushFromGrowableXYArray(y.param,k),this.normal&&y.normal&&k<y.normal.length&&this.normal.pushFromGrowableXYZArray(y.normal,k),this.color&&y.color&&k<y.color.length&&this.color.push(y.color[k])}pushInterpolatedDataFrom(y,k,M,b){k>b&&this.pushInterpolatedDataFrom(y,b,1-M,k),this.point.pushInterpolatedFromGrowableXYZArray(y.point,k,M,b);const E=(k+1)%y.edgeVisible.length===b&&y.edgeVisible[k];this.edgeVisible.push(E),this.param&&y.param&&k<y.param.length&&b<y.param.length&&this.param.pushInterpolatedFromGrowableXYArray(y.param,k,M,b),this.normal&&y.normal&&k<y.normal.length&&b<y.normal.length&&this.normal.pushInterpolatedFromGrowableXYZArray(y.normal,k,M,b),this.color&&y.color&&k<y.color.length&&b<y.color.length&&this.color.push(Q.interpolateColor(y.color[k],M,y.color[b]))}}class Ji extends Hi{constructor(y,k,M){super(y,M),this._parentFacetIndices=k.slice(),this._currentActiveIndex=-1,this._nextActiveIndex=0}isValidSubsetIndex(y){return void 0!==this._parentFacetIndices&&y>=0&&y<this._parentFacetIndices.length}static createSubsetVisitor(y,k,M=0){return new Ji(y,k,M)}moveToReadIndex(y){return!!this.isValidSubsetIndex(y)&&(this._currentActiveIndex=y,this._nextActiveIndex=y+1,super.moveToReadIndex(this._parentFacetIndices[y]))}moveToNextFacet(){return this._nextActiveIndex!==this._currentActiveIndex?this.moveToReadIndex(this._nextActiveIndex):(this._nextActiveIndex++,!0)}reset(){this.moveToReadIndex(0),this._nextActiveIndex=0}parentFacetIndex(y){return void 0===y&&(y=this._currentActiveIndex),this.isValidSubsetIndex(y)?this._parentFacetIndices[y]:void 0}getVisitableFacetCount(){return this._parentFacetIndices?this._parentFacetIndices.length:0}static createNormalComparison(y,k=$.unitZ(),M=W.createSmallAngle(),b=0){if(y instanceof ji)return this.createNormalComparison(y.createVisitor(),k,M,b);const E=y,D=[],R=$.createZero();for(E.reset();E.moveToNextFacet();)Ur.unitNormal(E.point,R)&&(R.dotProduct(k)<0||R.angleFromPerpendicular(k).isMagnitudeLessThanOrEqual(M)||D.push(E.currentReadIndex()));return Ji.createSubsetVisitor(E.clientPolyface(),D,b)}}class Qi{get paramDistanceRange(){return this._paramDistanceRange}get paramRange(){return this._paramRange}constructor(y,k){this._paramDistanceRange=y,this._paramRange=k}static createNull(){return new Qi(gt.createNull(),gt.createNull())}clone(y){return y?(this._paramDistanceRange.clone(y._paramDistanceRange),this._paramRange.clone(y._paramRange),y):new Qi(this._paramDistanceRange.clone(),this._paramRange.clone())}setNull(){this._paramDistanceRange.setNull(),this._paramRange.setNull()}convertParamXYToDistance(y,k,M){M=M||H.create();const b=this._paramRange.high.minus(this._paramRange.low);return M.x=0===b.x?y:this._paramDistanceRange.low.x+(y-this._paramRange.low.x)*(this._paramDistanceRange.high.x-this._paramDistanceRange.low.x)/b.x,M.y=0===b.y?k:this.paramDistanceRange.low.y+(k-this._paramRange.low.y)*(this._paramDistanceRange.high.y-this._paramDistanceRange.low.y)/b.y,M}convertParamXYToNormalized(y,k,M){M=M||H.create();const b=this._paramRange.high.minus(this._paramRange.low);return M.x=0===b.x?y:(y-this._paramRange.low.x)/b.x,M.y=0===b.y?k:(k-this._paramRange.low.y)/b.y,M}convertParamToDistance(y,k){return this.convertParamXYToDistance(y.x,y.y,k)}convertParamToNormalized(y,k){return this.convertParamXYToNormalized(y.x,y.y,k)}scaleDistances(y){this._paramDistanceRange.low.x*=y,this._paramDistanceRange.low.y*=y,this._paramDistanceRange.high.x*=y,this._paramDistanceRange.high.y*=y}setParamDistanceRangeFromNewFaceData(y,k,M){const b=H.create(),E=H.create();this.setNull();let D=0;const R=Hi.create(y,0);if(!R.moveToReadIndex(k)||M<=k)return!1;do{const y=R.numEdgesThisFacet,k=R.point,M=[],X=R.param,z=[];if(!X)return!1;X.extendRange(this._paramRange);const N=J.create(),Y=J.create();for(let R=0;R<y;R++){if(M[2]=R,z[2]=R,R>1){X.vectorIndexIndex(z[1],z[0],N),X.vectorIndexIndex(z[1],z[2],Y);const y=k.getPoint3dAtUncheckedPointIndex(M[0]).minus(k.getPoint3dAtUncheckedPointIndex(M[1])),R=k.getPoint3dAtUncheckedPointIndex(M[1]).minus(k.getPoint3dAtUncheckedPointIndex(M[2])),O=Math.abs(N.x*Y.y-Y.x*N.y);if(O){const k=j.createFrom(y);k.scaleInPlace(Y.y),k.addScaledInPlace(R,-N.y);const M=j.createFrom(R);M.scaleInPlace(N.x),M.addScaledInPlace(y,-Y.x);const X=H.create(k.magnitude()/O,M.magnitude()/O);b.x+=X.x,b.y+=X.y,E.x+=X.x*X.x,E.y+=X.y*X.y,D++}}z[0]=z[1],z[1]=z[2],M[0]=M[1],M[1]=M[2]}}while(R.moveToNextFacet()&&R.currentReadIndex()<M);if(0!==D){const y=H.create(b.x/D,b.y/D),k=H.create(Math.sqrt(Math.abs(E.x/D-y.x*y.x)),Math.sqrt(Math.abs(E.y/D-y.y*y.y)));this._paramDistanceRange.low.set(0,0),this._paramDistanceRange.high.set((y.x+k.x)*(this._paramRange.high.x-this._paramRange.low.x),(y.y+k.y)*(this._paramRange.high.y-this._paramRange.low.y))}return!0}}class Ki extends Ot{constructor(y){super(),this.geometryCategory="polyface",this.data=y}get twoSided(){return this.data.twoSided}set twoSided(y){this.data.twoSided=y}get expectedClosure(){return this.data.expectedClosure}set expectedClosure(y){this.data.expectedClosure=y}static areIndicesValid(y,k,M,b,E){if(void 0===y&&void 0===b)return!0;if(void 0===y||void 0===b)return!1;if(k<0||k>=y.length)return!1;if(M<=k||M>y.length)return!1;for(let D=k;D<M;D++)if(y[D]<0||y[D]>=E)return!1;return!0}get facetCount(){}}class ji extends Ki{constructor(y,k,M){super(y),k?this._facetStart=k.slice():(this._facetStart=[],this._facetStart.push(0)),this._facetToFaceData=M?M.slice():[]}isSameGeometryClass(y){return y instanceof ji}isAlmostEqual(y){return y instanceof ji&&this.data.isAlmostEqual(y.data)&&he.isExactEqual(this._facetStart,y._facetStart)&&he.isExactEqual(this._facetToFaceData,y._facetToFaceData)}get isEmpty(){return 0===this.data.pointCount||0===this.data.pointIndex.length}tryTransformInPlace(y){return!!this.data.tryTransformInPlace(y)&&(y.matrix.determinant()<0&&(this.reverseIndices(),this.reverseNormals()),!0)}reverseSingleFacet(y){this.data.reverseIndicesSingleFacet(y,this._facetStart)}clone(){return new ji(this.data.clone(),this._facetStart.slice(),this._facetToFaceData.slice())}cloneTransformed(y){const k=this.clone();return k.tryTransformInPlace(y),k}reverseIndices(){this.data.reverseIndices(this._facetStart)}reverseNormals(){this.data.reverseNormals()}tryGetFaceData(y){if(y<0||y>=this._facetToFaceData.length)return;const k=this._facetToFaceData[y];return k<0||k>=this.data.face.length?void 0:this.data.face[k]}addIndexedPolyface(y,k,M){const b=y.facetCount,E=this.data.point.length,D=j.create();for(let R=0;R<y.data.point.length;R++)y.data.point.getPoint3dAtUncheckedPointIndex(R,D),M?(M.multiplyPoint3d(D,D),this.addPoint(D)):this.addPoint(D);for(let R=0;R<b;R++){const M=y._facetStart[R],b=y._facetStart[R+1];if(k)for(let k=b;k-- >M;)this.addPointIndex(E+y.data.pointIndex[k],y.data.edgeVisible[k>M?k-1:b-1]);else for(let k=M;k<b;k++)this.addPointIndex(E+y.data.pointIndex[k],y.data.edgeVisible[k]);this.terminateFacet(!1)}if(void 0!==this.data.param&&void 0!==y.data.param&&void 0!==y.data.paramIndex){const M=this.data.param.length;this.data.param.pushFromGrowableXYArray(y.data.param);for(let E=0;E<b;E++){const b=y._facetStart[E],D=y._facetStart[E+1];if(k)for(let k=D;k-- >b;)this.addParamIndex(M+y.data.paramIndex[k]);else for(let k=b;k<D;k++)this.addParamIndex(M+y.data.paramIndex[k])}}if(void 0!==this.data.normal&&void 0!==y.data.normal&&void 0!==y.data.normalIndex){const E=this.data.normal.length;for(let b=0;b<y.data.normal.length;b++){const E=y.data.normal.getVector3dAtCheckedVectorIndex(b);M&&M.multiplyVector(E,E),k&&E.scaleInPlace(-1),this.addNormal(E)}for(let M=0;M<b;M++){const b=y._facetStart[M],D=y._facetStart[M+1];if(k)for(let k=D;k-- >b;)this.addNormalIndex(E+y.data.normalIndex[k]);else for(let k=b;k<D;k++)this.addNormalIndex(E+y.data.normalIndex[k])}}if(void 0!==this.data.color&&void 0!==y.data.color&&void 0!==y.data.colorIndex){const M=this.data.color.length;for(const k of y.data.color)this.addColor(k);for(let E=0;E<b;E++){const b=y._facetStart[E],D=y._facetStart[E+1];if(k)for(let k=D;k-- >b;)this.addColorIndex(M+y.data.colorIndex[k]);else for(let k=b;k<D;k++)this.addColorIndex(M+y.data.colorIndex[k])}}if(0!==y.data.face.length){const k=this.data.face.length;for(const M of y.data.face){const y=M.clone();this.data.face.push(y)}for(const M of y._facetToFaceData)this._facetToFaceData.push(k+M)}}get zeroTerminatedIndexCount(){return this.data.pointIndex.length+this._facetStart.length-1}static create(y=!1,k=!1,M=!1,b=!1){return new ji(new Gi(y,k,M,b))}addPoint(y,k){if(void 0!==k){const M=this.data.point.distanceIndexToPoint(k,y);if(void 0!==M&&Q.isSmallMetricDistance(M))return k}return this.data.point.pushXYZ(y.x,y.y,y.z),this.data.point.length-1}addPointXYZ(y,k,M){return this.data.point.pushXYZ(y,k,M),this.data.point.length-1}addParam(y){return this.data.param||(this.data.param=new Fe),this.data.param.push(y),this.data.param.length-1}addParamUV(y,k,M,b){return this.data.param||(this.data.param=new Fe),void 0!==M&&this.data.isAlmostEqualParamIndexUV(M,y,k)?M:void 0!==b&&this.data.isAlmostEqualParamIndexUV(b,y,k)?b:(this.data.param.pushXY(y,k),this.data.param.length-1)}addNormal(y,k,M){const s=k=>{const M=this.data.normal.distanceIndexToPoint(k,y);return void 0!==M&&Q.isSmallMetricDistance(M)};if(void 0!==this.data.normal){if(void 0!==k&&s(k))return k;if(void 0!==M&&s(M))return M;if(void 0!==k||void 0!==M){const y=this.data.normal.length-1;if(s(y))return y}}return this.addNormalXYZ(y.x,y.y,y.z)}addNormalXYZ(y,k,M){return this.data.normal||(this.data.normal=new nt),this.data.normal.pushXYZ(y,k,M),this.data.normal.length-1}addColor(y){return this.data.color||(this.data.color=[]),this.data.color.push(y),this.data.color.length-1}addPointIndex(y,k=!0){this.data.pointIndex.push(y),this.data.edgeVisible.push(k)}addNormalIndex(y){this.data.normalIndex||(this.data.normalIndex=[]),this.data.normalIndex.push(y)}addParamIndex(y){this.data.paramIndex||(this.data.paramIndex=[]),this.data.paramIndex.push(y)}addColorIndex(y){this.data.colorIndex||(this.data.colorIndex=[]),this.data.colorIndex.push(y)}cleanupOpenFacet(){this.data.trimAllIndexArrays(this.data.pointIndex.length)}validateAllIndices(y=0,k){const M=this.data.pointIndex.length,b=k??[];return this.data.normalIndex&&this.data.normalIndex.length!==M&&b.push("normalIndex count must match pointIndex count"),this.data.paramIndex&&this.data.paramIndex.length!==M&&b.push("paramIndex count must equal pointIndex count"),this.data.colorIndex&&this.data.colorIndex.length!==M&&b.push("colorIndex count must equal pointIndex count"),this.data.edgeVisible.length!==M&&b.push("visibleIndex count must equal pointIndex count"),Ki.areIndicesValid(this.data.pointIndex,y,M,this.data.point,this.data.point?this.data.point.length:0)||b.push("invalid point indices in the last facet"),Ki.areIndicesValid(this.data.normalIndex,y,M,this.data.normal,this.data.normal?this.data.normal.length:0)||b.push("invalid normal indices in the last facet"),Ki.areIndicesValid(this.data.paramIndex,y,M,this.data.param,this.data.param?this.data.param.length:0)||b.push("invalid param indices in the last facet"),Ki.areIndicesValid(this.data.colorIndex,y,M,this.data.color,this.data.color?this.data.color.length:0)||b.push("invalid color indices in the last facet"),0===b.length}terminateFacet(y=!0){const k=this._facetStart.length-1,M=this._facetStart[k],b=this.data.pointIndex.length;if(y){const y=[];if(b<M+2&&y.push("Less than 3 indices in the last facet"),this.validateAllIndices(M,y),y.length>0)return this.data.trimAllIndexArrays(M),y}this._facetStart.push(b)}get facetCount(){return this._facetStart.length-1}get faceCount(){return this.data.faceCount}get pointCount(){return this.data.pointCount}get colorCount(){return this.data.colorCount}get paramCount(){return this.data.paramCount}get normalCount(){return this.data.normalCount}isValidFacetIndex(y){return y>=0&&y<this.facetCount}numEdgeInFacet(y){return this.isValidFacetIndex(y)?this._facetStart[y+1]-this._facetStart[y]:0}facetIndex0(y){return this._facetStart[y]}facetIndex1(y){return this._facetStart[y+1]}createVisitor(y=0){return Hi.create(this,y)}range(y,k){return this.data.range(k,y)}extendRange(y,k){this.data.range(y,k)}getFaceDataByFacetIndex(y){return this.data.face[this._facetToFaceData[y]]}setNewFaceData(y=0){const k=this._facetToFaceData.length;if(k>=this._facetStart.length)return!1;0===y&&(y=this._facetStart.length);const M=Qi.createNull(),b=Hi.create(this,0);if(!b.moveToReadIndex(k))return!1;const E=void 0!==this.data.param,D=M.paramRange.isNull&&E;do{D&&void 0!==b.param&&b.param.extendRange(M.paramRange)}while(b.moveToNextFacet()&&b.currentReadIndex()<y);E&&0!==this.data.param.length&&M.paramDistanceRange.isNull&&M.setParamDistanceRangeFromNewFaceData(this,k,y),this.data.face.push(M);const R=this.data.face.length-1;for(let X=this._facetToFaceData.length;X<y;X++)this._facetToFaceData.push(0===this._facetStart[X]?0:R);return!0}dispatchToGeometryHandler(y){return y.handleIndexedPolyface(this)}}class $i{get tolerance(){return this._tolerance}constructor(y=Q.smallMetricDistance){this._tolerance=y}static create(y=Q.smallMetricDistance){return new $i(y)}static assignDetailInterpolatedFractionsAndPoints(y,k,M,b,E,D=!1){D?(y.fraction=M,y.fraction1=k):(y.fraction=k,y.fraction1=M),y.point=b.interpolate(y.fraction,E,y.point),y.point1=b.interpolate(y.fraction1,E,y.point1)}projectPointToSegmentXY(y,k,M){this._vectorU=$.createStartEnd(k,M,this._vectorU),this._vectorV=$.createStartEnd(k,y,this._vectorV);const b=this._vectorU.dotProductXY(this._vectorU),E=this._vectorU.dotProductXY(this._vectorV),D=Q.safeDivideFraction(E,b,0);return vt.createCurveFractionPoint(void 0,D,k.interpolate(D,M))}clampCoincidentOverlapToSegmentBounds(y,k,M,b,E,D=!1,R=!1,X=!1,z=!1){const N=Re.create(y.detailA.fraction,y.detailA.hasFraction1?y.detailA.fraction1:y.detailA.fraction),Y=Re.create(y.detailB.fraction,y.detailB.hasFraction1?y.detailB.fraction1:y.detailB.fraction),O=N.signedDelta()<0,u=()=>{const D=N.x0,R=N.x1,X=Y.x0,z=Y.x1;return $i.assignDetailInterpolatedFractionsAndPoints(y.detailA,D,R,k,M,D>R),$i.assignDetailInterpolatedFractionsAndPoints(y.detailB,X,z,b,E,X>z),y},B=N.clampDirectedTo01(!D,!R,!1),V=Y.clampDirectedTo01(!X,!z,!1);if(B&&V){if(Q.isAlmostEqualNumber(N.absoluteDelta(),Y.absoluteDelta(),Q.smallFraction))return u();if(N.clampDirectedTo01(!0,!0,!1)&&Y.clampDirectedTo01(!0,!0,!1))return u()}const p=(k,M,b,E)=>(k.clone(y.detailA.point),M.clone(y.detailB.point),y.detailA.fraction=b?0:1,y.detailB.fraction=E?0:1,y.detailA.collapseToStart(),y.detailB.collapseToStart(),y),U=N.clampDirectedTo01(!0,!0,!0),L=Y.clampDirectedTo01(!0,!0,!0);if(U&&L){const D=y.detailA.point1??y.detailA.point;if(O){if(y.detailA.point.isAlmostEqual(k,this.tolerance))return p(k,b,!0,!0);if(D.isAlmostEqual(M,this.tolerance))return p(M,E,!1,!1)}else{if(D.isAlmostEqual(k,this.tolerance))return p(k,E,!0,!1);if(y.detailA.point.isAlmostEqual(M,this.tolerance))return p(M,b,!1,!0)}}}coincidentSegmentRangeXY(y,k,M,b,E=!0){const D=this.projectPointToSegmentXY(y,M,b);if(y.distanceXY(D.point)>this._tolerance)return;const R=this.projectPointToSegmentXY(k,M,b);if(k.distanceXY(R.point)>this._tolerance)return;const X=this.projectPointToSegmentXY(M,y,k);if(M.distanceXY(X.point)>this._tolerance)return;const z=this.projectPointToSegmentXY(b,y,k);if(b.distanceXY(z.point)>this._tolerance)return;D.fraction1=R.fraction,D.point1=R.point,X.fraction1=z.fraction,X.point1=z.point;const N=Pt.createCapture(X,D);return E?this.clampCoincidentOverlapToSegmentBounds(N,y,k,M,b):N}createDetailPair(y,k,M,b,E,D){const R=E-b,X=Q.conditionalDivideFraction(M.x0-b,R),z=Q.conditionalDivideFraction(M.x1-b,R);if(void 0!==X&&void 0!==z){const b=vt.createCurveEvaluatedFractionFraction(y,M.x0,M.x1),E=vt.createCurveEvaluatedFractionFraction(k,X,z);return D&&b.swapFractionsAndPoints(),Pt.createCapture(b,E)}}appendDetailPair(y,k){return void 0===k?y:void 0===y?[k]:(y.push(k),y)}coincidentArcIntersectionXY(y,k,M=!0){let b;if(y.center.isAlmostEqual(k.center,this.tolerance)){const M=y.matrixRef.multiplyMatrixInverseMatrix(k.matrixRef);if(M){const E=M.at(0,0),D=M.at(1,0),R=M.at(0,1),X=M.at(1,1),z=Q.hypotenuseXY(E,D),N=Q.hypotenuseXY(R,X),Y=Q.dotProductXYXY(E,D,R,X),O=Q.crossProductXYXY(E,D,R,X);if(Q.isAlmostEqualNumber(z,1)&&Q.isAlmostEqualNumber(N,1)&&Q.isAlmostEqualNumber(0,Y)){const M=Math.atan2(D,E),R=O>0?1:-1,X=M+R*k.sweep.startRadians,z=M+R*k.sweep.endRadians,N=R*y.sweep.sweepRadians*k.sweep.sweepRadians<0,Y=At.createStartEndRadians(X,z),B=y.sweep,V=B.fractionPeriod(),U=B.radiansToPositivePeriodicFraction(Y.startRadians);e();const L=U+Y.sweepRadians/B.sweepRadians,x=(M,E)=>{const D=b?b.length:0,R=M.x0,X=M.x1;if(M.clampDirectedTo01()&&!Q.isSmallRelative(M.absoluteDelta()))b=this.appendDetailPair(b,this.createDetailPair(y,k,M,R,X,N));else{const M=N?E:!E,D=this._point0=E?y.startPoint(this._point0):y.endPoint(this._point0),R=this._point1=M?k.startPoint(this._point1):k.endPoint(this._point1);if(D.isAlmostEqual(R,this.tolerance)){const X=vt.createCurveFractionPoint(y,E?0:1,D),z=vt.createCurveFractionPoint(k,M?0:1,R);b=this.appendDetailPair(b,Pt.createCapture(X,z))}}return void 0!==b&&b.length>D};x(Re.create(U,L),!1),L>=V?x(Re.create(U-V,L-V),!0):0===U&&x(Re.create(U+V,L+V),!0)}}}return b}}class ts extends Ae{constructor(y,k,M,b,E=Q.smallMetricDistance){super(),this._extendA0=k,this._extendA1=k,this._geometryB=M,this._extendB0=b,this._extendB1=b,this._worldToLocalPerspective=void 0,this._worldToLocalAffine=void 0,void 0===y||y.isIdentity()||(this._worldToLocalAffine=y.asTransform,this._worldToLocalAffine||(this._worldToLocalPerspective=y.clone())),this._coincidentGeometryContext=$i.create(E),this._results=[]}resetGeometry(y){this._geometryB=y}acceptFraction(y,k,M,b=1e-12){return!(!y&&k<-b||!M&&k>1+b)}acceptFractionOnLine(y,k,M,b,E,D=Q.smallMetricDistance){return!y&&k<0?Q.isDistanceWithinTol(k*b.distanceXY(E),D):!(!M&&k>1)||Q.isDistanceWithinTol((k-1)*b.distanceXY(E),D)}grabPairedResults(y=!1){const k=this._results;return y&&(this._results=[]),k}recordPointWithLocalFractions(y,k,M,b,E,D,R,X,z,N){let Y,B,V,U;const L=void 0!==N&&N.detailA.hasFraction1&&N.detailB.hasFraction1;L?(Y=Q.interpolate(M,N.detailA.fraction,b),B=Q.interpolate(R,N.detailB.fraction,X),V=Q.interpolate(M,N.detailA.fraction1,b),U=Q.interpolate(R,N.detailB.fraction1,X)):(Y=V=Q.interpolate(M,y,b),B=U=Q.interpolate(R,E,X));const Z=this._results.length;if(Z>0&&!L){const y=this._results[Z-1].detailA,M=this._results[Z-1].detailB;if(z){if(M.isSameCurveAndFraction({curve:k,fraction:Y})&&y.isSameCurveAndFraction({curve:D,fraction:B}))return}else if(y.isSameCurveAndFraction({curve:k,fraction:Y})&&M.isSameCurveAndFraction({curve:D,fraction:B}))return}const q=vt.createCurveFractionPoint(k,Y,k.fractionToPoint(Y)),jr=vt.createCurveFractionPoint(D,B,D.fractionToPoint(B));L?(q.captureFraction1Point1(V,k.fractionToPoint(V)),jr.captureFraction1Point1(U,D.fractionToPoint(U))):(q.setIntervalRole(O.isolated),jr.setIntervalRole(O.isolated)),z?this._results.push(new Pt(jr,q)):this._results.push(new Pt(q,jr))}recordPairs(y,k,M,b){if(void 0!==M)for(const E of M)this.recordPointWithLocalFractions(E.detailA.fraction,y,0,1,E.detailB.fraction,k,0,1,b,E)}computeSegmentSegment3D(y,k,M,b,E,D,R,X,z,N,Y,O,B,V,U){const L=ts._workVector2dA,Z=this._coincidentGeometryContext.coincidentSegmentRangeXY(M,E,N,O,!1);Z?this._coincidentGeometryContext.clampCoincidentOverlapToSegmentBounds(Z,M,E,N,O,k,R,z,V)&&this.recordPointWithLocalFractions(Z.detailA.fraction,y,b,D,Z.detailB.fraction,X,Y,B,U,Z):Mt.lineSegment3dXYTransverseIntersectionUnbounded(M,E,N,O,L)&&this.acceptFractionOnLine(k,L.x,R,M,E,this._coincidentGeometryContext.tolerance)&&this.acceptFractionOnLine(z,L.y,V,N,O,this._coincidentGeometryContext.tolerance)&&this.recordPointWithLocalFractions(L.x,y,b,D,L.y,X,Y,B,U)}computeSegmentSegment3DH(y,k,M,b,E,D,R,X,z,N,Y,O,B,V,U){const L=ts._workPointA0H,Z=ts._workPointA1H,q=ts._workPointB0H,jr=ts._workPointB1H;this._worldToLocalPerspective.multiplyPoint3d(M,1,L),this._worldToLocalPerspective.multiplyPoint3d(E,1,Z),this._worldToLocalPerspective.multiplyPoint3d(N,1,q),this._worldToLocalPerspective.multiplyPoint3d(O,1,jr);const Gr=Mt.lineSegment3dHXYTransverseIntersectionUnbounded(L,Z,q,jr);if(void 0!==Gr){const M=Gr.x,E=Gr.y;this.acceptFraction(k,M,R)&&this.acceptFraction(z,E,V)&&this.recordPointWithLocalFractions(M,y,b,D,E,X,Y,B,U)}}dispatchSegmentSegment(y,k,M,b,E,D,R,X,z,N,Y,O,B,V,U){this._worldToLocalAffine?(ts.setTransformedWorkPoints(this._worldToLocalAffine,M,E,N,O),this.computeSegmentSegment3D(y,k,ts._workPointA0,b,ts._workPointA1,D,R,X,z,ts._workPointB0,Y,ts._workPointB1,B,V,U)):this._worldToLocalPerspective?this.computeSegmentSegment3DH(y,k,M,b,E,D,R,X,z,N,Y,O,B,V,U):this.computeSegmentSegment3D(y,k,M,b,E,D,R,X,z,N,Y,O,B,V,U)}dispatchSegmentArc(y,k,M,b,E,D,R,X,z,N,Y){if(this._worldToLocalPerspective){const O=X.toTransformedPoint4d(this._worldToLocalPerspective),B=this._worldToLocalPerspective.multiplyPoint3d(M,1),V=this._worldToLocalPerspective.multiplyPoint3d(E,1),U=Q.tripleProductPoint4dXYW(B,V,O.center),L=Q.tripleProductPoint4dXYW(B,V,O.vector0),Z=Q.tripleProductPoint4dXYW(B,V,O.vector90),q=new It(2),jr=new It(2),Gr=new It(2),Jr=wt.appendImplicitLineUnitCircleIntersections(U,L,Z,q,jr,Gr);for(let M=0;M<Jr;M++){const E=O.center.plus2Scaled(O.vector0,q.atUncheckedIndex(M),O.vector90,jr.atUncheckedIndex(M)),U=O.sweep.radiansToSignedFraction(Gr.atUncheckedIndex(M),z),L=Mt.lineSegment3dHXYClosestPointUnbounded(B,V,E);void 0!==L&&this.acceptFraction(k,L,R)&&this.acceptFraction(z,U,N)&&this.recordPointWithLocalFractions(L,y,b,D,U,X,0,1,Y)}}else{const O=X.toTransformedVectors(this._worldToLocalAffine);let B=M,V=E;this._worldToLocalAffine&&(B=this._worldToLocalAffine.multiplyPoint3d(M),V=this._worldToLocalAffine.multiplyPoint3d(E));const U=Q.tripleProductXYW(B,1,V,1,O.center,1),L=Q.tripleProductXYW(B,1,V,1,O.vector0,0),Z=Q.tripleProductXYW(B,1,V,1,O.vector90,0),q=new It(2),jr=new It(2),Gr=new It(2),Jr=wt.appendImplicitLineUnitCircleIntersections(U,L,Z,q,jr,Gr),Kr=1e-10,so=1e-7;for(let M=0;M<Jr;M++){const E=O.center.plus2Scaled(O.vector0,q.atUncheckedIndex(M),O.vector90,jr.atUncheckedIndex(M)),U=O.sweep.radiansToSignedFraction(Gr.atUncheckedIndex(M),z),L=Mt.lineSegment3dXYClosestPointUnbounded(B,V,E);void 0!==L&&this.acceptFraction(k,L,R,Kr)&&this.acceptFraction(z,U,N,so)&&this.recordPointWithLocalFractions(L,y,b,D,U,X,0,1,Y)}}}dispatchArcArcThisOrder(y,k,M,b,E,D,R,X,z){const N=k.inverse();if(N){const k=N.multiplyMatrixMatrix(D),Y=[],O=[];Tt.solveUnitCircleHomogeneousEllipseIntersection(k.coffs[2],k.coffs[5],k.coffs[8],k.coffs[0],k.coffs[3],k.coffs[6],k.coffs[1],k.coffs[4],k.coffs[7],Y,O);for(let D=0;D<Y.length;D++){const k=y.sweep.radiansToSignedFraction(O[D],M),N=E.sweep.radiansToSignedFraction(Y[D],R);this.acceptFraction(M,k,b)&&this.acceptFraction(R,N,X)&&this.recordPointWithLocalFractions(k,y,0,1,N,E,0,1,z)}}}dispatchArcArc(y,k,M,b,E,D,R){let X,z;if(this._worldToLocalPerspective){const k=y.toTransformedPoint4d(this._worldToLocalPerspective),M=b.toTransformedPoint4d(this._worldToLocalPerspective);X=xt.createColumnsXYW(k.vector0,k.vector0.w,k.vector90,k.vector90.w,k.center,k.center.w),z=xt.createColumnsXYW(M.vector0,M.vector0.w,M.vector90,k.vector90.w,M.center,M.center.w)}else{const k=y.toTransformedVectors(this._worldToLocalAffine),M=b.toTransformedVectors(this._worldToLocalAffine);X=xt.createColumnsXYW(k.vector0,0,k.vector90,0,k.center,1),z=xt.createColumnsXYW(M.vector0,0,M.vector90,0,M.center,1)}if(X.conditionNumber()>z.conditionNumber()?this.dispatchArcArcThisOrder(y,X,k,M,b,z,E,D,R):this.dispatchArcArcThisOrder(b,z,E,D,y,X,k,M,!R),this._coincidentGeometryContext)if(this._worldToLocalPerspective);else if(this._worldToLocalAffine);else{const k=this._coincidentGeometryContext.coincidentArcIntersectionXY(y,b,!0);void 0!==k&&this.recordPairs(y,b,k,R)}}dispatchArcBsplineCurve3d(y,k,M,b,E,D,R){let X;if(this._worldToLocalPerspective){const k=y.toTransformedPoint4d(this._worldToLocalPerspective);X=xt.createColumnsXYW(k.vector0,k.vector0.w,k.vector90,k.vector90.w,k.center,k.center.w)}else{const k=y.toTransformedVectors(this._worldToLocalAffine);X=xt.createColumnsXYW(k.vector0,0,k.vector90,0,k.center,1)}const z=X.inverse();if(z){const X=b.order,N=2*X-1,Y=new Float64Array(X),O=new Lt(N),B=z.at(0,0),V=z.at(0,1),U=0,L=z.at(0,2),Z=z.at(1,0),q=z.at(1,1),jr=0,Gr=z.at(1,2),Jr=z.at(2,0),Kr=z.at(2,1),so=0,no=z.at(2,2);if(z){let X;for(let z=0;X=b.getSaturatedBezierSpan3dH(z,X),X;z++){this._worldToLocalPerspective?X.tryMultiplyMatrix4dInPlace(this._worldToLocalPerspective):this._worldToLocalAffine&&X.tryTransformInPlace(this._worldToLocalAffine),O.zero(),X.poleProductsXYZW(Y,B,V,U,L),O.addSquaredSquaredBezier(Y,1),X.poleProductsXYZW(Y,Z,q,jr,Gr),O.addSquaredSquaredBezier(Y,1),X.poleProductsXYZW(Y,Jr,Kr,so,no),O.addSquaredSquaredBezier(Y,-1);const z=O.roots(0,!0);if(z)for(const N of z){const z=X.fractionToParentFraction(N),Y=X.fractionToPoint4d(N),O=Y.dotProductXYZW(B,V,U,L),Jr=Y.dotProductXYZW(Z,q,jr,Gr),Kr=y.sweep.radiansToSignedFraction(Math.atan2(Jr,O),k);this.acceptFraction(k,Kr,M)&&this.acceptFraction(E,z,D)&&this.recordPointWithLocalFractions(Kr,y,0,1,z,b,0,1,R)}}}}}transformBeziers(y){if(this._worldToLocalAffine)for(const k of y)k.tryTransformInPlace(this._worldToLocalAffine);else if(this._worldToLocalPerspective)for(const k of y)k.tryMultiplyMatrix4dInPlace(this._worldToLocalPerspective)}getRanges(y){const k=[];k.length=0;for(const M of y)k.push(M.range());return k}dispatchBezierBezierStrokeFirst(y,k,M,b,E,D,R,X){this._xyzwA0||(this._xyzwA0=Dt.create()),this._xyzwA1||(this._xyzwA1=Dt.create()),this._xyzwPlane||(this._xyzwPlane=Dt.create()),this._xyzwB||(this._xyzwB=Dt.create()),y.fractionToPoint4d(0,this._xyzwA0);let z,N=0;const Y=1/M;for(let O=1;O<=M;O++,N=z,this._xyzwA0.setFrom(this._xyzwA1)){z=O*Y,y.fractionToPoint4d(z,this._xyzwA1),Dt.createPlanePointPointZ(this._xyzwA0,this._xyzwA1,this._xyzwPlane),b.poleProductsXYZW(R.coffs,this._xyzwPlane.x,this._xyzwPlane.y,this._xyzwPlane.z,this._xyzwPlane.w);const M=R.roots(0,!0);if(M)for(const D of M){let M=D;b.fractionToPoint4d(M,this._xyzwB);const R=Mt.lineSegment3dHXYClosestPointUnbounded(this._xyzwA0,this._xyzwA1,this._xyzwB);if(R&&Q.isIn01WithTolerance(R,1e-5)){let D=Q.interpolate(N,R,z);const Y=new Kt(y,b),O=new Qt(Y);O.setUV(D,M),O.runIterations()&&(D=O.getU(),M=O.getV());const B=y.fractionToParentFraction(D),V=b.fractionToParentFraction(M);this.acceptFraction(!1,B,!1)&&this.acceptFraction(!1,V,!1)&&this.recordPointWithLocalFractions(B,k,0,1,V,E,0,1,X)}}}}dispatchBSplineCurve3dBSplineCurve3d(y,k,M){const b=y.collectBezierSpans(!0),E=k.collectBezierSpans(!0),D=b.length,R=E.length;this.transformBeziers(b),this.transformBeziers(E);const X=this.getRanges(b),z=this.getRanges(E),N=y.order,Y=k.order,O=new Lt(N),B=new Lt(Y);for(let V=0;V<D;V++)for(let D=0;D<R;D++)if(X[V].intersectsRangeXY(z[D])){const R=b[V].computeStrokeCountForOptions(),X=E[D].computeStrokeCountForOptions();R<X?this.dispatchBezierBezierStrokeFirst(b[V],y,R,E[D],k,X,B,M):this.dispatchBezierBezierStrokeFirst(E[D],k,X,b[V],y,R,O,!M)}}projectPoint(y,k=1){return this._worldToLocalPerspective?this._worldToLocalPerspective.multiplyPoint3d(y,k):this._worldToLocalAffine?this._worldToLocalAffine.multiplyXYZW(y.x,y.y,y.z,k):Dt.createFromPointAndWeight(y,k)}mapNPCPlaneToWorld(y,k){this._worldToLocalAffine?this._worldToLocalAffine.multiplyTransposeXYZW(y.x,y.y,y.z,y.w,k):this._worldToLocalPerspective?this._worldToLocalPerspective.multiplyTransposePoint4d(y,k):y.clone(k)}dispatchSegmentBsplineCurve(y,k,M,b,E,D,R,X,z,N,Y){const O=this.projectPoint(M),B=this.projectPoint(E),V=Dt.createPlanePointPointZ(O,B);this.mapNPCPlaneToWorld(V,V);const U=[];X.appendPlaneIntersectionPoints(V,U);for(const L of U){const M=L.fraction,E=L.point,V=this.projectPoint(E),U=Mt.lineSegment3dHXYClosestPointUnbounded(O,B,V);void 0!==U&&this.acceptFraction(k,U,R)&&this.acceptFraction(z,M,N)&&this.recordPointWithLocalFractions(U,y,b,D,M,X,0,1,Y)}}dispatchLineStringBSplineCurve(y,k,M,b,E,D,R){const X=y.numPoints();if(X>1){const z=1/(X-1);let N,Y;N=0;const O=ts._workPointA0,B=ts._workPointA1;y.pointAt(0,O);for(let V=1;V<X;V++,O.setFrom(B),N=Y)y.pointAt(V,B),Y=V*z,this.dispatchSegmentBsplineCurve(y,1===V&&k,O,N,B,Y,V+1===X&&M,b,E,D,R)}}computeSegmentLineString(y,k,M,b,E,D,R){const X=y.point0Ref,z=y.point1Ref,N=ts._workPointBB0,Y=ts._workPointBB1,O=b.numPoints();if(O>1){const B=1/(O-1);let V,U;V=0,b.pointAt(0,N);for(let L=1;L<O;L++,N.setFrom(Y),V=U)b.pointAt(L,Y),U=L*B,this.dispatchSegmentSegment(y,k,X,0,z,1,M,b,1===L&&E,N,V,Y,U,L+1===O&&D,R)}}computeArcLineString(y,k,M,b,E,D,R){const X=ts._workPointBB0,z=ts._workPointBB1,N=b.numPoints();if(N>1){const Y=1/(N-1);let O,B;O=0,b.pointAt(0,X);for(let V=1;V<N;V++,X.setFrom(z),O=B)b.pointAt(V,z),B=V*Y,this.dispatchSegmentArc(b,1===V&&E,X,O,z,B,V+1===N&&D,y,k,M,!R)}}computeLineStringLineString(y,k,M){const b=ts._workPointAA0,E=ts._workPointAA1,D=ts._workPointBB0,R=ts._workPointBB1,X=y.numPoints(),z=k.numPoints();if(X>1&&z>1){y.pointAt(0,b);const N=1/(X-1),Y=1/(z-1);let O,B,V,U=0;y.pointAt(0,b);for(let L=1;L<X;L++,b.setFrom(E),U=B){B=L*N,O=0,y.pointAt(L,E),k.pointAt(0,D);for(let N=1;N<z;N++,D.setFrom(R),O=V)k.pointAt(N,R),V=N*Y,this.dispatchSegmentSegment(y,1===L&&this._extendA0,b,U,E,B,L+1===X&&this._extendA1,k,1===N&&this._extendB0,D,O,R,V,N+1===z&&this._extendB1,M)}}}static setTransformedWorkPoints(y,k,M,b,E){y.multiplyPoint3d(k,this._workPointA0),y.multiplyPoint3d(M,this._workPointA1),y.multiplyPoint3d(b,this._workPointB0),y.multiplyPoint3d(E,this._workPointB1)}dispatchCurveCollection(y,k){const M=this._geometryB;if(!(M&&M.children&&M instanceof si))return;const b=M.children,E=this._extendB0,D=this._extendB1;for(let R=0;R<b.length;R++)this.resetGeometry(b[R]),M instanceof oi&&b.length>1?0===R?this._extendB1=!1:R===b.length-1?this._extendB0=!1:this._extendB0=this._extendB1=!1:M instanceof hi&&(this._extendB0=this._extendB1=!1),k(y),this._extendB0=E,this._extendB1=D;this.resetGeometry(M)}dispatchCurveChainWithDistanceIndex(y,k){if(!(this._geometryB&&this._geometryB instanceof li))return;y instanceof li&&e();const M=this._results.length,b=this._geometryB;this.resetGeometry(b.path),this.dispatchCurveCollection(y,k),this.resetGeometry(b),this._results=li.convertChildDetailToChainDetail(this._results,M,void 0,b,!0)}handleChildren(y){const k=y.children,M=this._extendA0,b=this._extendA1;if(k)for(let E=0;E<k.length;E++)y instanceof oi&&k.length>1?0===E?this._extendA1=!1:E===k.length-1?this._extendA0=!1:this._extendA0=this._extendA1=!1:y instanceof hi&&(this._extendA0=this._extendA1=!1),k[E].dispatchToGeometryHandler(this),this._extendA0=M,this._extendA1=b}handleLineSegment3d(y){if(this._geometryB instanceof Ce){const k=this._geometryB;this.dispatchSegmentSegment(y,this._extendA0,y.point0Ref,0,y.point1Ref,1,this._extendA1,k,this._extendB0,k.point0Ref,0,k.point1Ref,1,this._extendB1,!1)}else this._geometryB instanceof Me?this.computeSegmentLineString(y,this._extendA0,this._extendA1,this._geometryB,this._extendB0,this._extendB1,!1):this._geometryB instanceof Ti?this.dispatchSegmentArc(y,this._extendA0,y.point0Ref,0,y.point1Ref,1,this._extendA1,this._geometryB,this._extendB0,this._extendB1,!1):this._geometryB instanceof Be?this.dispatchSegmentBsplineCurve(y,this._extendA0,y.point0Ref,0,y.point1Ref,1,this._extendA1,this._geometryB,this._extendB0,this._extendB1,!1):this._geometryB instanceof si?this.dispatchCurveCollection(y,this.handleLineSegment3d.bind(this)):this._geometryB instanceof li&&this.dispatchCurveChainWithDistanceIndex(y,this.handleLineSegment3d.bind(this))}handleLineString3d(y){if(this._geometryB instanceof Me){const k=this._geometryB;this.computeLineStringLineString(y,k,!1)}else this._geometryB instanceof Ce?this.computeSegmentLineString(this._geometryB,this._extendB0,this._extendB1,y,this._extendA0,this._extendA1,!0):this._geometryB instanceof Ti?this.computeArcLineString(this._geometryB,this._extendB0,this._extendB1,y,this._extendA0,this._extendA1,!0):this._geometryB instanceof Be?this.dispatchLineStringBSplineCurve(y,this._extendA0,this._extendA1,this._geometryB,this._extendB0,this._extendB1,!1):this._geometryB instanceof si?this.dispatchCurveCollection(y,this.handleLineString3d.bind(this)):this._geometryB instanceof li&&this.dispatchCurveChainWithDistanceIndex(y,this.handleLineString3d.bind(this))}handleArc3d(y){this._geometryB instanceof Ce?this.dispatchSegmentArc(this._geometryB,this._extendB0,this._geometryB.point0Ref,0,this._geometryB.point1Ref,1,this._extendB1,y,this._extendA0,this._extendA1,!0):this._geometryB instanceof Me?this.computeArcLineString(y,this._extendA0,this._extendA1,this._geometryB,this._extendB0,this._extendB1,!1):this._geometryB instanceof Ti?this.dispatchArcArc(y,this._extendA0,this._extendA1,this._geometryB,this._extendB0,this._extendB1,!1):this._geometryB instanceof Be?this.dispatchArcBsplineCurve3d(y,this._extendA0,this._extendA1,this._geometryB,this._extendB0,this._extendB1,!1):this._geometryB instanceof si?this.dispatchCurveCollection(y,this.handleArc3d.bind(this)):this._geometryB instanceof li&&this.dispatchCurveChainWithDistanceIndex(y,this.handleArc3d.bind(this))}handleBSplineCurve3d(y){this._geometryB instanceof Ce?this.dispatchSegmentBsplineCurve(this._geometryB,this._extendB0,this._geometryB.point0Ref,0,this._geometryB.point1Ref,1,this._extendB1,y,this._extendA0,this._extendA1,!0):this._geometryB instanceof Me?this.dispatchLineStringBSplineCurve(this._geometryB,this._extendB0,this._extendB1,y,this._extendA0,this._extendA1,!0):this._geometryB instanceof Ti?this.dispatchArcBsplineCurve3d(this._geometryB,this._extendB0,this._extendB1,y,this._extendA0,this._extendA1,!0):this._geometryB instanceof Ye?this.dispatchBSplineCurve3dBSplineCurve3d(y,this._geometryB,!1):this._geometryB instanceof si?this.dispatchCurveCollection(y,this.handleBSplineCurve3d.bind(this)):this._geometryB instanceof li&&this.dispatchCurveChainWithDistanceIndex(y,this.handleBSplineCurve3d.bind(this))}handleCurveChainWithDistanceIndex(y){super.handleCurveChainWithDistanceIndex(y),this._results=li.convertChildDetailToChainDetail(this._results,0,y,void 0,!0)}handleBSplineCurve3dH(y){}}ts._workVector2dA=J.create(),ts._workPointA0H=Dt.create(),ts._workPointA1H=Dt.create(),ts._workPointB0H=Dt.create(),ts._workPointB1H=Dt.create(),ts._workPointAA0=j.create(),ts._workPointAA1=j.create(),ts._workPointBB0=j.create(),ts._workPointBB1=j.create(),ts._workPointA0=j.create(),ts._workPointA1=j.create(),ts._workPointB0=j.create(),ts._workPointB1=j.create();class es extends Ae{constructor(y,k,M){super(),this._extendA0=y,this._extendA1=y,this._geometryB=k,this._extendB0=M,this._extendB1=M,this._results=[]}resetGeometry(y){this._geometryB=y}grabPairedResults(y=!1){const k=this._results;return y&&(this._results=[]),k}acceptFraction(y,k,M,b=1e-12){return!(!y&&k<-b||!M&&k>1+b)}recordPointWithLocalFractions(y,k,M,b,E,D,R,X,z){const N=Q.interpolate(M,y,b),Y=Q.interpolate(R,E,X),B=this._results.length;if(B>0){const y=this._results[B-1].detailA,M=this._results[B-1].detailB;if(z){if(M.isSameCurveAndFraction({curve:k,fraction:N})&&y.isSameCurveAndFraction({curve:D,fraction:Y}))return}else if(y.isSameCurveAndFraction({curve:k,fraction:N})&&M.isSameCurveAndFraction({curve:D,fraction:Y}))return}const V=k.fractionToPoint(N),U=D.fractionToPoint(Y);if(!V.isAlmostEqualMetric(U))return;const L=vt.createCurveFractionPoint(k,N,V);L.setIntervalRole(O.isolated);const Z=vt.createCurveFractionPoint(D,Y,U);if(Z.setIntervalRole(O.isolated),z){const y=new Pt(Z,L);this._results.push(y)}else{const y=new Pt(L,Z);this._results.push(y)}}computeSegmentSegment3D(y,k,M,b,E,D,R,X,z,N,Y,O,B,V,U){const L=es._workVector2dA;Mt.lineSegment3dClosestApproachUnbounded(M,E,N,O,L)&&this.acceptFraction(k,L.x,R)&&this.acceptFraction(z,L.y,V)&&this.recordPointWithLocalFractions(L.x,y,b,D,L.y,X,Y,B,U)}dispatchSegmentSegment(y,k,M,b,E,D,R,X,z,N,Y,O,B,V,U){this.computeSegmentSegment3D(y,k,M,b,E,D,R,X,z,N,Y,O,B,V,U)}createPlaneWithPreferredPerpendicular(y,k,M,b,E){M=Q.restrictToInterval(Math.abs(M),0,1-Q.smallFraction);const D=k.magnitudeSquared(),R=b.magnitudeSquared(),X=Math.abs(k.dotProduct(b)),z=k.unitCrossProduct(X*X<=M*M*D*R?b:E);if(z)return _t.create(y,z)}dispatchSegmentArc(y,k,M,b,E,D,R,X,z,N,Y){const O=$.createStartEnd(M,E),B=this.createPlaneWithPreferredPerpendicular(M,O,.94,X.perpendicularVector,X.vector0);if(void 0!==B){const O=[];let V,U;X.appendPlaneIntersectionPoints(B,O);for(const B of O){const O=X.sweep.fractionToSignedPeriodicFraction(B.fraction,z);this.acceptFraction(z,O,N)&&(V=Mt.lineSegment3dClosestPointUnbounded(M,E,B.point),void 0!==V&&(U=M.interpolate(V,E,U),U.isAlmostEqualMetric(B.point)&&this.acceptFraction(k,V,R)&&this.recordPointWithLocalFractions(V,y,b,D,O,X,0,1,Y)))}}}dispatchArcArcInPlane(y,k,M,b,E,D,R){const X=y.otherArcAsLocalVectors(b);if(void 0!==X){const z=[],N=[];Tt.solveUnitCircleHomogeneousEllipseIntersection(X.center.x,X.center.y,1,X.vector0.x,X.vector0.y,0,X.vector90.x,X.vector90.y,0,z,N);for(let X=0;X<z.length;X++){const Y=y.sweep.radiansToSignedFraction(N[X],k),O=b.sweep.radiansToSignedFraction(z[X],E);this.acceptFraction(k,Y,M)&&this.acceptFraction(E,O,D)&&this.recordPointWithLocalFractions(Y,y,0,1,O,b,0,1,R)}}}dispatchArcArc(y,k,M,b,E,D,R){const X=_t.create(y.center,y.perpendicularVector),z=_t.create(b.center,b.perpendicularVector);if(void 0!==X&&void 0!==z)if(X.getNormalRef().isParallelTo(z.getNormalRef()))X.isPointInPlane(z.getOriginRef())&&z.isPointInPlane(X.getOriginRef())&&this.dispatchArcArcInPlane(y,k,M,b,E,D,R);else{const N=[];b.appendPlaneIntersectionPoints(X,N);const Y=[];y.appendPlaneIntersectionPoints(z,Y);for(const X of N)for(const z of Y)if(z.point.isAlmostEqual(X.point)){const N=y.sweep.fractionToSignedPeriodicFraction(z.fraction,k),Y=b.sweep.fractionToSignedPeriodicFraction(X.fraction,E);this.acceptFraction(k,N,M)&&this.acceptFraction(E,Y,D)&&this.recordPointWithLocalFractions(N,y,0,1,Y,b,0,1,R)}}}dispatchArcBsplineCurve3d(y,k,M,b,E,D,R){}dispatchBSplineCurve3dBSplineCurve3d(y,k,M){}dispatchSegmentBsplineCurve(y,k,M,b,E,D,R,X,z,N,Y){}dispatchLineStringBSplineCurve(y,k,M,b,E,D,R){}computeSegmentLineString(y,k,M,b,E,D,R){const X=y.point0Ref,z=y.point1Ref,N=es._workPointBB0,Y=es._workPointBB1,O=b.numPoints();if(O>1){const B=1/(O-1);let V,U;V=0,b.pointAt(0,N);for(let L=1;L<O;L++,N.setFrom(Y),V=U)b.pointAt(L,Y),U=L*B,this.dispatchSegmentSegment(y,k,X,0,z,1,M,b,1===L&&E,N,V,Y,U,L+1===O&&D,R)}}computeArcLineString(y,k,M,b,E,D,R){const X=es._workPointBB0,z=es._workPointBB1,N=b.numPoints();if(N>1){const Y=1/(N-1);let O,B;O=0,b.pointAt(0,X);for(let V=1;V<N;V++,X.setFrom(z),O=B)b.pointAt(V,z),B=V*Y,this.dispatchSegmentArc(b,1===V&&E,X,O,z,B,V+1===N&&D,y,k,M,!R)}}computeLineStringLineString(y,k,M){const b=es._workPointAA0,E=es._workPointAA1,D=es._workPointBB0,R=es._workPointBB1,X=y.numPoints(),z=k.numPoints();if(X>1&&z>1){y.pointAt(0,b);const N=1/(X-1),Y=1/(z-1);let O,B,V,U=0;y.pointAt(0,b);for(let L=1;L<X;L++,b.setFrom(E),U=B){B=L*N,O=0,y.pointAt(L,E),k.pointAt(0,D);for(let N=1;N<z;N++,D.setFrom(R),O=V)k.pointAt(N,R),V=N*Y,this.dispatchSegmentSegment(y,1===L&&this._extendA0,b,U,E,B,L+1===X&&this._extendA1,k,1===N&&this._extendB0,D,O,R,V,N+1===z&&this._extendB1,M)}}}dispatchCurveCollection(y,k){const M=this._geometryB;if(!(M&&M.children&&M instanceof si))return;const b=M.children,E=this._extendB0,D=this._extendB1;for(let R=0;R<b.length;R++)this.resetGeometry(b[R]),M instanceof oi&&b.length>1?0===R?this._extendB1=!1:R===b.length-1?this._extendB0=!1:this._extendB0=this._extendB1=!1:M instanceof hi&&(this._extendB0=this._extendB1=!1),k(y),this._extendB0=E,this._extendB1=D;this.resetGeometry(M)}dispatchCurveChainWithDistanceIndex(y,k){if(!(this._geometryB&&this._geometryB instanceof li))return;y instanceof li&&e();const M=this._results.length,b=this._geometryB;this.resetGeometry(b.path),this.dispatchCurveCollection(y,k),this.resetGeometry(b),this._results=li.convertChildDetailToChainDetail(this._results,M,void 0,b,!0)}handleChildren(y){const k=y.children,M=this._extendA0,b=this._extendA1;if(k)for(let E=0;E<k.length;E++)y instanceof oi&&k.length>1?0===E?this._extendA1=!1:E===k.length-1?this._extendA0=!1:this._extendA0=this._extendA1=!1:y instanceof hi&&(this._extendA0=this._extendA1=!1),k[E].dispatchToGeometryHandler(this),this._extendA0=M,this._extendA1=b}handleLineSegment3d(y){if(this._geometryB instanceof Ce){const k=this._geometryB;this.dispatchSegmentSegment(y,this._extendA0,y.point0Ref,0,y.point1Ref,1,this._extendA1,k,this._extendB0,k.point0Ref,0,k.point1Ref,1,this._extendB1,!1)}else this._geometryB instanceof Me?this.computeSegmentLineString(y,this._extendA0,this._extendA1,this._geometryB,this._extendB0,this._extendB1,!1):this._geometryB instanceof Ti?this.dispatchSegmentArc(y,this._extendA0,y.point0Ref,0,y.point1Ref,1,this._extendA1,this._geometryB,this._extendB0,this._extendB1,!1):this._geometryB instanceof Be?this.dispatchSegmentBsplineCurve(y,this._extendA0,y.point0Ref,0,y.point1Ref,1,this._extendA1,this._geometryB,this._extendB0,this._extendB1,!1):this._geometryB instanceof si?this.dispatchCurveCollection(y,this.handleLineSegment3d.bind(this)):this._geometryB instanceof li&&this.dispatchCurveChainWithDistanceIndex(y,this.handleLineSegment3d.bind(this))}handleLineString3d(y){if(this._geometryB instanceof Me){const k=this._geometryB;this.computeLineStringLineString(y,k,!1)}else this._geometryB instanceof Ce?this.computeSegmentLineString(this._geometryB,this._extendB0,this._extendB1,y,this._extendA0,this._extendA1,!0):this._geometryB instanceof Ti?this.computeArcLineString(this._geometryB,this._extendB0,this._extendB1,y,this._extendA0,this._extendA1,!0):this._geometryB instanceof Be?this.dispatchLineStringBSplineCurve(y,this._extendA0,this._extendA1,this._geometryB,this._extendB0,this._extendB1,!1):this._geometryB instanceof si?this.dispatchCurveCollection(y,this.handleLineString3d.bind(this)):this._geometryB instanceof li&&this.dispatchCurveChainWithDistanceIndex(y,this.handleLineString3d.bind(this))}handleArc3d(y){this._geometryB instanceof Ce?this.dispatchSegmentArc(this._geometryB,this._extendB0,this._geometryB.point0Ref,0,this._geometryB.point1Ref,1,this._extendB1,y,this._extendA0,this._extendA1,!0):this._geometryB instanceof Me?this.computeArcLineString(y,this._extendA0,this._extendA1,this._geometryB,this._extendB0,this._extendB1,!1):this._geometryB instanceof Ti?this.dispatchArcArc(y,this._extendA0,this._extendA1,this._geometryB,this._extendB0,this._extendB1,!1):this._geometryB instanceof Be?this.dispatchArcBsplineCurve3d(y,this._extendA0,this._extendA1,this._geometryB,this._extendB0,this._extendB1,!1):this._geometryB instanceof si?this.dispatchCurveCollection(y,this.handleArc3d.bind(this)):this._geometryB instanceof li&&this.dispatchCurveChainWithDistanceIndex(y,this.handleArc3d.bind(this))}handleBSplineCurve3d(y){this._geometryB instanceof Ce?this.dispatchSegmentBsplineCurve(this._geometryB,this._extendB0,this._geometryB.point0Ref,0,this._geometryB.point1Ref,1,this._extendB1,y,this._extendA0,this._extendA1,!0):this._geometryB instanceof Me?this.dispatchLineStringBSplineCurve(this._geometryB,this._extendB0,this._extendB1,y,this._extendA0,this._extendA1,!0):this._geometryB instanceof Ti?this.dispatchArcBsplineCurve3d(this._geometryB,this._extendB0,this._extendB1,y,this._extendA0,this._extendA1,!0):this._geometryB instanceof Ye?this.dispatchBSplineCurve3dBSplineCurve3d(y,this._geometryB,!1):this._geometryB instanceof si?this.dispatchCurveCollection(y,this.handleBSplineCurve3d.bind(this)):this._geometryB instanceof li&&this.dispatchCurveChainWithDistanceIndex(y,this.handleBSplineCurve3d.bind(this))}handleCurveChainWithDistanceIndex(y){super.handleCurveChainWithDistanceIndex(y),this._results=li.convertChildDetailToChainDetail(this._results,0,y,void 0,!0)}handleBSplineCurve3dH(y){}}es._workVector2dA=J.create(),es._workPointAA0=j.create(),es._workPointAA1=j.create(),es._workPointBB0=j.create(),es._workPointBB1=j.create();class is{static intersectionXYPairs(y,k,M,b,E=Q.smallMetricDistance){return is.intersectionProjectedXYPairs(void 0,y,k,M,b,E)}static intersectionProjectedXYPairs(y,k,M,b,E,D=Q.smallMetricDistance){const R=new ts(y,M,b,E,D);return k.dispatchToGeometryHandler(R),R.grabPairedResults()}static intersectionXYZPairs(y,k,M,b){const E=new es(k,M,b);return y.dispatchToGeometryHandler(E),E.grabPairedResults()}static allIntersectionsAmongPrimitivesXY(y,k=Q.smallMetricDistance){const M=new ts(void 0,!1,void 0,!1,k);for(let b=0;b<y.length;b++){const k=y[b];for(let E=b+1;E<y.length;E++)M.resetGeometry(y[E]),k.dispatchToGeometryHandler(M)}return M.grabPairedResults()}static closeApproachProjectedXYPairs(y,k,M){const b=new ui(k);return b.maxDistanceToAccept=M,y.dispatchToGeometryHandler(b),b.grabPairedResults()}static closestApproachProjectedXYPair(y,k){const M=y.range();M.extendRange(k.range());const b=M.low.distanceXY(M.high),E=this.closeApproachProjectedXYPairs(y,k,b);if(!E.length)return;let D=0,R=2*b;for(let X=0;X<E.length;++X){const y=E[X].detailA.point.distanceXY(E[X].detailB.point);y<R&&(D=X,R=y)}return E[D]}}class ss{constructor(y=Q.smallMetricDistance,k){this._chains=[],this._gapTolerance=y,this._snapTolerance=Q.smallMetricDistance,this._planeTolerance=k}findAnyChainToConnect(y,k,M=-1){for(let b=0;b<this._chains.length;b++){if(M===b)continue;const E=this._chains[b];if(this._xyzWork1=E[E.length-1].endPoint(this._xyzWork1),this._xyzWork1.isAlmostEqual(y,k))return{chainIndex:b,atEnd:!0};if(this._xyzWork1=E[0].startPoint(this._xyzWork1),this._xyzWork1.isAlmostEqual(y,k))return{chainIndex:b,atEnd:!1}}}captureCurvePrimitive(y){this._snapTolerance<this._gapTolerance&&this.attachPrimitiveToAnyChain(y,this._snapTolerance)||this.attachPrimitiveToAnyChain(y,this._gapTolerance)||this._chains.push([y])}captureCurve(y){if(y instanceof ae)this.captureCurvePrimitive(y);else if(y instanceof si)for(const k of y.children)this.captureCurve(k)}static simpleEndPointMove(y,k,M){if(y instanceof Ce)return k?y.point1Ref.setFrom(M):y.point0Ref.setFrom(M),!0;if(y instanceof Me&&y.numPoints()>0){const b=k?y.numPoints()-1:0;return y.packedPoints.setAtCheckedPointIndex(b,M),!0}return!1}static moveHeadOrTail(y,k,M){const b=y.endPoint(),E=k.startPoint(),D=.001*Q.smallMetricDistance,R=b.distanceXY(E);if(R<D)return!1;if(R<M&&(this.simpleEndPointMove(k,!1,b)||this.simpleEndPointMove(y,!0,E)))return!0;const X=is.intersectionXYPairs(y,!0,k,!0);for(const z of X){const D=z.detailA,R=z.detailB,X=D.point.distanceXY(b),N=R.point.distanceXY(E);if(X<5*M&&N<5*M&&y instanceof Ti&&k instanceof Ti){const M=y.sweep.fractionToRadians(D.fraction);y.sweep.setStartEndRadians(y.sweep.startRadians,M);const b=k.sweep.fractionToRadians(R.fraction);return k.sweep.setStartEndRadians(b,k.sweep.endRadians),!0}}return!1}attachPrimitiveToAnyChain(y,k){if(y){this._xyzWork0=y.startPoint(this._xyzWork0);let M=this.findAnyChainToConnect(this._xyzWork0,k);if(M){if(M.atEnd){const b=this._chains[M.chainIndex],E=b.length-1;return this._chains[M.chainIndex].push(y),ss.moveHeadOrTail(b[E],b[E+1],this._gapTolerance),this.searchAndMergeChainIndex(M.chainIndex,k),!0}{y.reverseInPlace();const b=this._chains[M.chainIndex];return b.splice(0,0,y),ss.moveHeadOrTail(b[0],b[1],this._gapTolerance),this.searchAndMergeChainIndex(M.chainIndex,k),!0}}if(this._xyzWork0=y.endPoint(this._xyzWork0),M=this.findAnyChainToConnect(this._xyzWork0,k),M){if(M.atEnd){y.reverseInPlace();const b=this._chains[M.chainIndex],E=b.length-1;return this._chains[M.chainIndex].push(y),ss.moveHeadOrTail(b[E],b[E+1],this._gapTolerance),this.searchAndMergeChainIndex(M.chainIndex,k),!0}{const b=this._chains[M.chainIndex];return b.splice(0,0,y),ss.moveHeadOrTail(b[0],b[1],this._gapTolerance),this.searchAndMergeChainIndex(M.chainIndex,k),!0}}}return!1}mergeChainsForwardForward(y,k){const M=this._chains[y],b=this._chains[k];for(const D of b)M.push(D);b.length=0;const E=this._chains.length-1;k!==E&&(this._chains[k]=this._chains[E]),this._chains.pop()}reverseChain(y){const k=this._chains[y];k.reverse();for(const M of k)M.reverseInPlace()}searchAndMergeChainIndex(y,k){const M=this._chains[y],b=M.length-1;this._xyzWork0=M[0].startPoint(this._xyzWork0);let E=this.findAnyChainToConnect(this._xyzWork0,k,y);return E?(E.atEnd||this.reverseChain(E.chainIndex),void this.mergeChainsForwardForward(E.chainIndex,y)):(this._xyzWork0=M[b].endPoint(this._xyzWork0),E=this.findAnyChainToConnect(this._xyzWork0,k,y),E?(E.atEnd&&this.reverseChain(E.chainIndex),void this.mergeChainsForwardForward(y,E.chainIndex)):void 0)}promoteArrayToCurves(y,k){if(0!==y.length){if(k){const k=y[0],M=y[y.length-1];if(ss._staticPointA=k.startPoint(ss._staticPointA),ss._staticPointB=M.endPoint(ss._staticPointB),ss.moveHeadOrTail(M,k,this._gapTolerance)&&(ss._staticPointA=k.startPoint(ss._staticPointA),ss._staticPointB=M.endPoint(ss._staticPointB)),ss._staticPointA.isAlmostEqual(ss._staticPointB,this._gapTolerance)){const k=Fi.createRightHandedLocalToWorld(y);if(k){const M=k.inverse();if(M){const k=Er.curveArrayRange(y,M);if(void 0!==this._planeTolerance&&k.zLength()<=this._planeTolerance)return hi.createArray(y)}}return oi.createArray(y)}}return 1===y.length?y[0]:oi.createArray(y)}}chainToLineString3d(y,k){if(0===y.length)return;const M=Me.create();for(const b of y)b.emitStrokes(M,k);return M.removeDuplicatePoints(this._gapTolerance),M}grabResult(y=!1){const k=this._chains;if(0===k.length)return;if(1===k.length)return this.promoteArrayToCurves(k[0],y);const M=ri.create();for(const b of k){const k=this.promoteArrayToCurves(b,y);M.tryAddChild(k)}return M}announceChainsAsLineString3d(y,k){const M=this._chains;if(1===M.length){const b=this.chainToLineString3d(M[0],k);b&&y(b)}else if(M.length>1)for(const b of M){const M=this.chainToLineString3d(b,k);M&&y(M)}}}!function(y){y[y.Unknown=0]="Unknown",y[y.Cap=1]="Cap",y[y.Extend=2]="Extend",y[y.Trim=-1]="Trim",y[y.JustGeometry=3]="JustGeometry",y[y.Gap=4]="Gap"}(Jr||(Jr={}));class ns{constructor(y,k,M){this.curve0=y,this.curve1=k,this.swingPoint=M,this.flexure=Jr.Unknown}static constructArc(y,k,M){if(void 0!==k&&Q.isSameCoordinate(y.origin.distance(k),M.origin.distance(k))){const b=y.direction.angleToXY(M.direction),E=$.createStartEnd(k,y.origin),D=E.rotate90CCWXY();return Ti.create(k,E,D,At.createStartEndRadians(0,b.radians))}}shallowExtract(){return{curve0:this.curve0,curve1:this.curve1,fraction0:this.fraction0,fraction1:this.fraction1}}static link(y,k){y.nextJoint=k,k&&(k.previousJoint=y),y.curve1&&k&&!k.curve0?k.curve0=y.curve1:!y.curve1&&k&&k.curve0&&(y.curve1=k.curve0)}nextJointFraction0(y){return this.nextJoint&&void 0!==this.nextJoint.fraction0?this.nextJoint.fraction0:y}static addStrokes(y,k){k&&k.emitStrokes(y)}static addPoint(y,k){y.packedPoints.length>0&&(y.endPoint().isAlmostEqual(k)||y.packedPoints.push(k))}static collectStrokesFromChain(y,k,M=100){let b=-2*M;ns.visitJointsOnChain(y,(y=>{if(this.addStrokes(k,y.jointCurve),y.curve1&&void 0!==y.fraction1){const M=y.fraction1,b=y.nextJointFraction0(1);let E;0===M&&1===b?E=y.curve1.clone():M<b&&(E=y.curve1.clonePartialCurve(M,b)),E&&(y.jointCurve||this.addPoint(k,E.startPoint())),this.addStrokes(k,E)}return b++<M}),M)}static collectPrimitive(y,k){if(k){if(y.length>0){const M=y[y.length-1].endPoint(),b=k.startPoint();M.isAlmostEqual(b)||y.push(Ce.create(M,b))}y.push(k)}}static adjustJointToPrimitives(y){const k=y.jointCurve;if(k instanceof Me){if(y.curve0){const M=y.curve0.endPoint(),b=k.startPoint();M.isAlmostEqual(b)||k.packedPoints.setAtCheckedPointIndex(0,M)}if(y.curve1){const M=y.curve1.startPoint(),b=k.endPoint();M.isAlmostEqual(b)||k.packedPoints.setAtCheckedPointIndex(k.packedPoints.length-1,M)}}}static collectCurvesFromChain(y,k,M=100){if(void 0===y)return;let b=-2*M;ns.visitJointsOnChain(y,(y=>{if(this.adjustJointToPrimitives(y),this.collectPrimitive(k,y.jointCurve),y.curve1&&void 0!==y.fraction1){const M=y.fraction1,b=y.nextJointFraction0(1);let E;0===M&&1===b?E=y.curve1.clone():M<b&&(E=y.curve1.clonePartialCurve(M,b)),this.collectPrimitive(k,E)}return b++<M}),M)}static annotateChain(y,k,M=100){y&&ns.visitJointsOnChain(y,(y=>(y.annotateJointMode(k),!0)),M)}static visitJointsOnChain(y,k,M=100){let b=y;if(b){let E=0;for(;void 0!==b;){if(E++>=M+5)return!0;if(!k(b))return!1;if(b=b.nextJoint,b===y)break}}return!0}annotateExtension(y){if(this.curve0&&this.curve1){const k=this.curve0.fractionToPointAndDerivative(1),M=this.curve1.fractionToPointAndDerivative(0);k.direction.z=M.direction.z=0;const b=bt.closestApproachRay3dRay3d(k,M);if(b.approachType===V.Intersection&&b.detailA.fraction>=0&&b.detailB.fraction<=0){this.fraction0=1,this.fraction1=0,this.flexure=Jr.Extend;const E=k.getDirectionRef().angleToXY(M.getDirectionRef());if(y.needArc(E)){const y=ns.constructArc(k,this.curve0.baseCurveEnd,M);if(y)return void(this.jointCurve=y)}const D=y.numChamferPoints(E);if(D<=1)return void(this.jointCurve=Me.create(k.origin,b.detailA.point,M.origin));if(D>1){const y=2*D,b=E.radians/y,R=ns.constructArc(k,this.curve0.baseCurveEnd,M);if(void 0!==R){const E=1/Math.cos(b),X=Me.create();this.jointCurve=X,X.addPoint(k.origin);for(let k=0;k<D;k++){const M=(1+2*k)/y;X.addPoint(R.fractionAndRadialFractionToPoint(M,E))}return void X.addPoint(M.origin)}}}this.flexure=Jr.Gap,this.jointCurve=Ce.create(this.curve0.fractionToPoint(1),this.curve1.fractionToPoint(0)),this.fraction0=1,this.fraction1=0}}selectIntersectionIndexByFraction(y,k,M){let b=-1,E=Number.MAX_VALUE;for(let D=0;D<M.length;D++){const R=Math.abs(M[D].detailA.fraction-y)+Math.abs(M[D].detailB.fraction-k);R<E&&(E=R,b=D)}return b}annotateJointMode(y){if(!this.curve0&&this.curve1)this.flexure=Jr.Cap,this.fraction1=0;else if(this.curve0&&!this.curve1)this.flexure=Jr.Cap,this.fraction0=1;else if(this.curve0&&this.curve1)if(this.curve0.endPoint().isAlmostEqualXY(this.curve1.startPoint()))this.fraction0=1,this.fraction1=0,this.flexure=Jr.Trim;else if(this.curve0 instanceof Ce&&this.curve1 instanceof Ce){const k=this.curve0.fractionToPointAndDerivative(0),M=this.curve1.fractionToPointAndDerivative(0);k.direction.z=M.direction.z=0;const b=bt.closestApproachRay3dRay3d(k,M);b.approachType!==V.Intersection&&b.approachType!==V.PerpendicularChord||(this.fraction0=b.detailA.fraction,this.fraction1=b.detailB.fraction,this.fraction0>=1&&this.fraction1<=0?this.annotateExtension(y):this.fraction0<1&&this.fraction1>0?this.flexure=Jr.Trim:this.fraction0>1&&this.fraction1>1&&(this.flexure=Jr.Gap,this.jointCurve=Ce.create(this.curve0.fractionToPoint(1),this.curve1.fractionToPoint(0)),this.fraction0=1,this.fraction1=0))}else{const k=is.intersectionXYPairs(this.curve0,!1,this.curve1,!1),M=this.selectIntersectionIndexByFraction(1,0,k);M>=0?(this.flexure=Jr.Trim,this.fraction0=k[M].detailA.fraction,this.fraction1=k[M].detailB.fraction):this.annotateExtension(y)}}static removeDegeneratePrimitives(y,k,M){let b=y,E=0,D=0;if(b)for(;void 0!==b&&D++<M;){const M=b.nextJoint;if(b&&M&&b.previousJoint&&M.nextJoint&&void 0!==b.fraction1&&void 0!==M.fraction0){const D=b.fraction1,R=M.fraction0,X=M.fraction1,z=M.nextJoint.fraction0,N=D>=R||D>1;if(N&&(void 0!==X&&X>1||void 0!==X&&void 0!==z&&X>=z)){const y=M.nextJoint,E=new ns(b.curve0,y.curve1,void 0);ns.link(b.previousJoint,E),ns.link(E,y.nextJoint),E.annotateJointMode(k),E.previousJoint.annotateJointMode(k),E.nextJoint&&E.nextJoint.annotateJointMode(k)}else if(N){const D=new ns(b.curve0,M.curve1,void 0);if(ns.link(b.previousJoint,D),ns.link(D,M.nextJoint),D.annotateJointMode(k),D.previousJoint.annotateJointMode(k),D.nextJoint.annotateJointMode(k),E++,b===y&&(y=D),b=D,E>=1)return{newStart:y,numJointRemoved:E}}}if(b=b.nextJoint,b===y)break}return{newStart:y,numJointRemoved:E}}}class rs{constructor(){}static createOffsetSegment(y,k,M){if($.createStartEnd(y,k,this._unitAlong),this._unitAlong.z=0,this._unitAlong.normalizeInPlace()){this._unitAlong.rotate90CCWXY(this._unitPerp);const b=Ce.create(y.plusScaled(this._unitPerp,M,this._offsetA),k.plusScaled(this._unitPerp,M,this._offsetB));return os.applyBasePoints(b,y.clone(),k.clone()),b}}constructPolygonWireXYOffset(y,k,M){k&&!y[0].isAlmostEqual(y[y.length-1])&&(k=!1);const b=Se.create(M),E=y.length;let D,R,X;for(let Y=0;Y+1<E;++Y)if(X){const k=rs.createOffsetSegment(y[Y],y[Y+1],b.leftOffsetDistance);if(k){const M=new ns(D,k,y[Y]);ns.link(X,M),X=M,D=k}}else(D=rs.createOffsetSegment(y[Y],y[Y+1],b.leftOffsetDistance))&&(X=R=new ns(void 0,D,y[Y]));if(!D||!X||!R)return;const z=k?R:new ns(D,void 0,y[E-1]);ns.link(X,z),ns.annotateChain(R,b,E);for(let Y=0;Y++<5;){const y=ns.removeDegeneratePrimitives(R,b,E);if(R=y.newStart,0===y.numJointRemoved)break}const N=Me.create();return ns.collectStrokesFromChain(R,N,E),N.packedPoints.length>1?N.packedPoints.front().isAlmostEqual(N.packedPoints.back())?hi.create(N):oi.create(N):void 0}}rs._unitAlong=$.create(),rs._unitPerp=$.create(),rs._offsetA=j.create(),rs._offsetB=j.create();class os{constructor(){}static applyBasePoints(y,k,M){return void 0!==y&&(void 0!==k&&(y.baseCurveStart=k),void 0!==M&&(y.baseCurveEnd=M)),y}static createSingleOffsetPrimitiveXY(y,k){const M=y.constructOffsetXY(k);if(void 0!==M){if(Array.isArray(M)){const k=y.collectCurvePrimitives(void 0,!0,!0);if(k.length!==M.length)return;for(let y=0;y<k.length;++y)this.applyBasePoints(M[y],k[y].startPoint(),k[y].endPoint());return M}return this.applyBasePoints(M,y.startPoint(),y.endPoint())}}static constructCurveXYOffset(y,k){const M=y instanceof hi,b=we.create(k),E=[];for(const O of y.children){const y=os.createSingleOffsetPrimitiveXY(O,b);if(void 0===y);else if(y instanceof ae)E.push(y);else if(Array.isArray(y))for(const k of y)k instanceof ae&&E.push(k)}let D,R,X,z;for(const O of E)O&&(R=new ns(D,O,O.fractionToPoint(0)),void 0!==R&&void 0===z&&(z=R),X&&ns.link(X,R),X=R,D=O);z&&X&&y instanceof hi&&ns.link(X,z);const N=E.length;ns.annotateChain(z,b.jointOptions,N);const Y=[];return ns.collectCurvesFromChain(z,Y,N),Er.createLoopPathOrBagOfCurves(Y,M,!0)}}class as{static sumLengths(y){let k=0;if(y instanceof ae)k+=y.curveLength();else if(y instanceof si)k+=y.sumLengths();else if(Array.isArray(y))for(const M of y)k+=this.sumLengths(M);return k}static extendRange(y,k){if(Array.isArray(k))for(const M of k)this.extendRange(y,M);else k.extendRange(y);return y}static appendXYOffsets(y,k,M){let b=0;if(y instanceof ae){const E=os.constructCurveXYOffset(oi.create(y),k);E&&(b+=this.sumLengths(E),M.push(E))}else if(y instanceof hi||y instanceof oi){const E=os.constructCurveXYOffset(y,k);E&&(b+=this.sumLengths(E),M.push(E))}else if(y instanceof ri)for(const E of y.children)b+=this.appendXYOffsets(E,k,M);else if(Array.isArray(y))for(const E of y)b+=this.appendXYOffsets(E,k,M);return b}static collectInsideAndOutsideXYOffsets(y,k,M){const b=new ss(M,M);for(const X of y)b.captureCurve(X);const E=b.grabResult(!0),D=[],R=[];return as.appendXYOffsets(E,k,D)>as.appendXYOffsets(E,-k,R)?{outsideOffsets:D,insideOffsets:R,chains:E}:{insideOffsets:D,outsideOffsets:R,chains:E}}static constructCurveXYOffset(y,k){return os.constructCurveXYOffset(y,k)}static createSingleOffsetPrimitiveXY(y,k){return os.createSingleOffsetPrimitiveXY(y,k)}static collectChains(y,k=Q.smallMetricDistance,M){const b=new ss(k,M);for(const E of y)b.captureCurve(E);return b.grabResult(!0)}static collectChainsAsLineString3d(y,k,M,b=Q.smallMetricDistance,E){const D=new ss(b);for(const R of y)D.captureCurve(R);D.announceChainsAsLineString3d(k,M)}}class cs{constructor(){this.world=new j,this.local=new j,this.a=0,this.closestEdgeIndex=0,this.closestEdgeParam=0}invalidate(){this.world.setZero(),this.local.setZero(),this.a=0,this.closestEdgeIndex=0,this.closestEdgeParam=0}static create(y){return void 0===y?y=new cs:y.invalidate(),y}copyContentsFrom(y){this.world.setFrom(y.world),this.local.setFrom(y.local),this.a=y.a,this.closestEdgeIndex=y.closestEdgeIndex,this.closestEdgeParam=y.closestEdgeParam}get isValid(){return!this.local.isZero}get isInsideOrOn(){return this.isValid&&this.local.x>=0&&this.local.y>=0&&this.local.z>=0}get classify(){if(!this.isValid)return z.Unknown;if(this.isInsideOrOn){let y=0;return 0===Math.abs(this.local.x)&&++y,0===Math.abs(this.local.y)&&++y,0===Math.abs(this.local.z)&&++y,2===y?z.OnPolygonVertex:1===y?z.OnPolygonEdgeInterior:z.InsidePolygonProjectsToEdgeInterior}return 0===this.closestEdgeParam?z.OutsidePolygonProjectsToVertex:z.OutsidePolygonProjectsToEdgeInterior}}class ls{constructor(y,k,M){this.points=[],this.points.push(y),this.points.push(k),this.points.push(M),this.edgeLength2=[],this.edgeLength2.push(k.distanceSquared(M)),this.edgeLength2.push(y.distanceSquared(M)),this.edgeLength2.push(y.distanceSquared(k))}set(y,k,M){this.points[0].setFromPoint3d(y),this.points[1].setFromPoint3d(k),this.points[2].setFromPoint3d(M),this.edgeLength2[0]=this.points[1].distanceSquared(this.points[2]),this.edgeLength2[1]=this.points[0].distanceSquared(this.points[2]),this.edgeLength2[2]=this.points[0].distanceSquared(this.points[1])}setFrom(y){for(let k=0;k<3;++k)this.points[k].setFromPoint3d(y.points[k]),this.edgeLength2[k]=y.edgeLength2[k]}static createXYZXYZXYZ(y,k,M,b,E,D,R,X,z,N){return N?(N.points[0].set(y,k,M),N.points[1].set(b,E,D),N.points[2].set(R,X,z),N):new this(j.create(y,k,M),j.create(b,E,D),j.create(R,X,z))}static create(y,k,M,b){return b?(b.set(y,k,M),b):new this(y.clone(),k.clone(),M.clone())}clone(y){return ls.create(this.points[0],this.points[1],this.points[2],y)}cloneTransformed(y,k){return ls.create(y.multiplyPoint3d(this.points[0],k?.points[0]),y.multiplyPoint3d(this.points[1],k?.points[1]),y.multiplyPoint3d(this.points[2],k?.points[2]),k)}get area(){return.5*this.points[0].crossProductToPointsMagnitude(this.points[1],this.points[2])}edgeLengthSquared(y){return this.edgeLength2[Q.cyclic3dAxis(y)]}edgeLength(y){return Math.sqrt(this.edgeLengthSquared(y))}get aspectRatio(){return Q.safeDivideFraction(this.area,this.edgeLengthSquared(0)+this.edgeLengthSquared(1)+this.edgeLengthSquared(2),0)}get perimeter(){return this.edgeLength(0)+this.edgeLength(1)+this.edgeLength(2)}normal(y){const k=this.points[0].crossProductToPoints(this.points[1],this.points[2],y);if(k.tryNormalizeInPlace())return k}fractionToPoint(y,k,M,b){return j.createAdd3Scaled(this.points[0],y,this.points[1],k,this.points[2],M,b)}pointToFraction(y,k){const M=ls._workVector0=this.normal(ls._workVector0);if(void 0===M)return cs.create(k);const b=ls._workRay=bt.create(y,M,ls._workRay);return this.intersectRay3d(b,k)}static edgeOppositeVertexIndexToStartVertexIndex(y){return Q.cyclic3dAxis(y+1)}static edgeStartVertexIndexToOppositeVertexIndex(y){return Q.cyclic3dAxis(y-1)}static isInsideTriangle(y,k,M){return y>0&&k>0&&M>0}static isInsideOrOnTriangle(y,k,M){return y>=0&&k>=0&&M>=0}static isInRegionBeyondEdge(y,k,M){return y<0&&k>=0&&M>=0?0:y>=0&&k<0&&M>=0?1:y>=0&&k>=0&&M<0?2:-1}static isInRegionBeyondVertex(y,k,M){return k<0&&M<0?0:y<0&&M<0?1:y<0&&k<0?2:-1}static isOnVertex(y,k,M){return 1===y&&0===k&&0===M?0:0===y&&1===k&&0===M?1:0===y&&0===k&&1===M?2:-1}static isOnBoundedEdge(y,k,M){return 0===y&&k>0&&M>0?0:y>0&&0===k&&M>0?1:y>0&&k>0&&0===M?2:-1}static indexOfMinimum(y){let k=0,M=y(0);const b=y(1);return M>b&&(k=1,M=b),M>y(2)&&(k=2),k}distanceSquared(y,k,M,b,E,D){return-this.edgeLengthSquared(0)*(E-k)*(D-M)-this.edgeLengthSquared(1)*(D-M)*(b-y)-this.edgeLengthSquared(2)*(b-y)*(E-k)}closestVertexIndex(y,k,M){return ls.indexOfMinimum((b=>{const E=ls._workPoint=j.createZero(ls._workPoint);return E.setAt(b,1),this.distanceSquared(E.x,E.y,E.z,y,k,M)}))}dotProductOfEdgeVectorsAtVertex(y){const k=Q.cyclic3dAxis(y),M=Q.cyclic3dAxis(k+1),b=Q.cyclic3dAxis(M+1);return Q.dotProductXYZXYZ(this.points[M].x-this.points[k].x,this.points[M].y-this.points[k].y,this.points[M].z-this.points[k].z,this.points[b].x-this.points[k].x,this.points[b].y-this.points[k].y,this.points[b].z-this.points[k].z)}computeProjectionToEdge(y,k){y=Q.cyclic3dAxis(y);const M=Q.cyclic3dAxis(y+1);return k[Q.cyclic3dAxis(M+1)]+k[y]*this.dotProductOfEdgeVectorsAtVertex(M)/this.edgeLengthSquared(y)}closestPoint(y,k,M){const b=[y,k,M];let E=-1,D=0;return ls.isInsideTriangle(y,k,M)?(E=ls.indexOfMinimum((y=>b[y]*b[y]/this.edgeLengthSquared(y))),D=this.computeProjectionToEdge(E,b)):(E=ls.isInRegionBeyondVertex(y,k,M))>=0?(E=Q.cyclic3dAxis(E+1),D=this.computeProjectionToEdge(E,b),(D<0||D>1)&&(E=Q.cyclic3dAxis(E+1),D=this.computeProjectionToEdge(E,b),(D<0||D>1)&&(D=0,E=ls.edgeStartVertexIndexToOppositeVertexIndex(this.closestVertexIndex(y,k,M))))):(E=ls.isInRegionBeyondEdge(y,k,M))>=0?(D=this.computeProjectionToEdge(E,b),D<0?D=0:D>1&&(D=0,E=Q.cyclic3dAxis(E+1))):(E=ls.isOnBoundedEdge(y,k,M))>=0?D=1-b[ls.edgeOppositeVertexIndexToStartVertexIndex(E)]:(E=ls.isOnVertex(y,k,M))>=0&&(D=0,E=ls.edgeStartVertexIndexToOppositeVertexIndex(E)),e(),{closestEdgeIndex:E<0?-1:ls.edgeOppositeVertexIndexToStartVertexIndex(E),closestEdgeParam:D}}intersectRay3d(y,k){k=cs.create(k);const M=y.origin,b=y.direction,E=ls._workVector0=$.createStartEnd(this.points[0],this.points[1],ls._workVector0),D=ls._workVector1=$.createStartEnd(this.points[0],this.points[2],ls._workVector1),R=ls._workMatrix=xt.createColumns(E,D,b,ls._workMatrix),X=$.createStartEnd(this.points[0],M,ls._workVector0),z=ls._workVector1;if(void 0===R.multiplyInverse(X,z))return k;k.a=-z.z,y.fractionToPoint(k.a,k.world),k.local.set(1-z.x-z.y,z.x,z.y);const N=this.closestPoint(k.local.x,k.local.y,k.local.z);return k.closestEdgeIndex=N.closestEdgeIndex,k.closestEdgeParam=N.closestEdgeParam,k}intersectSegment(y,k,M){return ls._workRay=bt.createStartEnd(y,k,ls._workRay),this.intersectRay3d(ls._workRay,M)}snapLocationToEdge(y,k=Q.smallMetricDistance,M=Q.smallFloatingPoint){if(!y.isValid)return!1;if(M>0){let k=0,b=0;for(let E=0;E<3;E++){const D=Math.abs(y.local.at(E));D>0&&D<M&&(y.local.setAt(E,0),k++),b+=y.local.at(E)}if(k>0&&b>0)return y.local.scaleInPlace(1/b),1===k?(y.closestEdgeIndex=ls.edgeOppositeVertexIndexToStartVertexIndex(ls.isOnBoundedEdge(y.local.x,y.local.y,y.local.z)),y.closestEdgeParam=1-y.local.at(y.closestEdgeIndex)):(y.closestEdgeIndex=ls.isOnVertex(y.local.x,y.local.y,y.local.z),y.closestEdgeParam=0),this.fractionToPoint(y.local.x,y.local.y,y.local.z,y.world),!0}if(k>0){const M=y.closestEdgeIndex,b=(M+1)%3,E=(b+1)%3,D=ls._workPoint=this.points[M].interpolate(y.closestEdgeParam,this.points[b],ls._workPoint),R=y.world.distance(D);if(R>0&&R<k)return y.local.setAt(M,1-y.closestEdgeParam),y.local.setAt(b,y.closestEdgeParam),y.local.setAt(E,0),y.world.setFrom(D),!0}return!1}dotProductOfCrossProductsFromOrigin(y){return ls._workVector0=this.points[0].crossProductToPoints(this.points[1],this.points[2],ls._workVector0),ls._workVector1=y.points[0].crossProductToPoints(y.points[1],y.points[2],ls._workVector1),ls._workVector0.dotProduct(ls._workVector1)}centroid(y){return j.create((this.points[0].x+this.points[1].x+this.points[2].x)/3,(this.points[0].y+this.points[1].y+this.points[2].y)/3,(this.points[0].z+this.points[1].z+this.points[2].z)/3,y)}incenter(y){const k=this.edgeLength(0),M=this.edgeLength(1),b=this.edgeLength(2),E=Q.safeDivideFraction(1,k+M+b,0);return this.fractionToPoint(E*k,E*M,E*b,y)}circumcenter(y){const k=this.edgeLengthSquared(0),M=this.edgeLengthSquared(1),b=this.edgeLengthSquared(2),E=k*(M+b-k),D=M*(b+k-M),R=b*(k+M-b),X=Q.safeDivideFraction(1,E+D+R,0);return this.fractionToPoint(X*E,X*D,X*R,y)}isAlmostEqual(y,k){return this.points[0].isAlmostEqual(y.points[0],k)&&this.points[1].isAlmostEqual(y.points[1],k)&&this.points[2].isAlmostEqual(y.points[2],k)}}class hs{constructor(y=0){this._parentArray=[];for(let k=0;k<y;k++)this._parentArray.push(k)}get length(){return this._parentArray.length}isValidIndex(y){return 0<=y&&y<this._parentArray.length}addLeaf(){const y=this._parentArray.length;return this._parentArray.push(y),y}findRoot(y){if(!this.isValidIndex(y))return y;let k=y,M=this._parentArray[y];for(;M!==k;)k=M,M=this._parentArray[k];const b=k;for(k=y;k!==b;)M=this._parentArray[k],this._parentArray[k]=b,k=M;return b}mergeSubsets(y,k){if(!this.isValidIndex(y)||!this.isValidIndex(k))return y;const M=this.findRoot(y),b=this.findRoot(k);return M!==b&&(this._parentArray[M]=b),this.findRoot(y)}askParent(y){return this.isValidIndex(y)?this._parentArray[y]:y}countRoots(){let y=0;const k=this._parentArray.length;for(let M=0;M<k;M++)this._parentArray[M]===M&&y++;return y}countNonTrivialPaths(){let y=0;const k=this._parentArray.length;for(let M=0;M<k;M++){const k=this._parentArray[M];k!==M&&this._parentArray[k]!==k&&y++}return y}collectRootIndices(){const y=[],k=this._parentArray.length;for(let M=0;M<k;M++)this._parentArray[M]===M&&y.push(M);return y}}class ds{constructor(y,k){this._freeMasks=y,this._originalFreeMasks=y,this._firstFreeMask=k}static create(y){let k=0,M=1;for(let b=0;b<32;b++){if(M&y){k=M;break}M<<=1}if(0!==k)return new ds(y,k)}grabMask(){if(0===this._freeMasks)return 0;let y=this._firstFreeMask;for(;!(y&this._freeMasks);)y<<=1;return this._freeMasks&=~y,y}dropMask(y){y&=this._originalFreeMasks,this._freeMasks|=y}}(bo=Kr||(Kr={}))[bo.EXTERIOR=1]="EXTERIOR",bo[bo.BOUNDARY_EDGE=2]="BOUNDARY_EDGE",bo[bo.PRIMARY_EDGE=4]="PRIMARY_EDGE",bo[bo.VISITED=16]="VISITED",bo[bo.TRIANGULATED_FACE=256]="TRIANGULATED_FACE",bo[bo.NULL_FACE=512]="NULL_FACE",bo[bo.NULL_MASK=0]="NULL_MASK",bo[bo.ALL_GRAB_DROP_MASKS=4293918720]="ALL_GRAB_DROP_MASKS",bo[bo.ALL_MASK=4294967295]="ALL_MASK";class us{get id(){return this._id}get facePredecessor(){return this._facePredecessor}get faceSuccessor(){return this._faceSuccessor}get edgeMate(){return this._edgeMate}constructor(y=0,k=0,M=0,b=0){this._id=us._totalNodesCreated++,this.i=b,this.maskBits=0,this.x=y,this.y=k,this.z=M,this.sortAngle=void 0,this.sortData=void 0,this.edgeTag=void 0,this.faceTag=void 0,this._facePredecessor=this,this._faceSuccessor=this,this._edgeMate=this}faceStepY(y){let k=this;if(y>0)for(let M=0;M<y;M++)k=k.faceSuccessor;else if(y<0)for(let M=0;M>y;M--)k=k.facePredecessor;return k.y}static createHalfEdgePair(y){const k=new us,M=new us;return y&&(y.push(k),y.push(M)),us.setFaceLinks(k,M),us.setFaceLinks(M,k),us.setEdgeMates(k,M),k}static createHalfEdgePairWithCoordinates(y=0,k=0,M=0,b=0,E=0,D=0,R=0,X=0,z){const N=us.createHalfEdgePair(z),Y=N._edgeMate;return N.x=y,N.y=k,N.z=M,N.i=b,Y.x=E,Y.y=D,Y.z=R,Y.i=X,N}static setFaceLinks(y,k){y._faceSuccessor=k,k._facePredecessor=y}static setEdgeMates(y,k){y._edgeMate=k,k._edgeMate=y}static splitEdge(y,k=0,M=0,b=0,E=0,D){const R=new us(k,M,b,E),X=new us(k,M,b,E);if(D&&(D.push(R),D.push(X)),void 0===y)R._faceSuccessor=R._facePredecessor=R,X._faceSuccessor=X._facePredecessor=X,us.setEdgeMates(R,X);else{const k=y._faceSuccessor,M=y._edgeMate,b=M._faceSuccessor;us.setFaceLinks(R,k),us.setFaceLinks(y,R),us.setFaceLinks(M,X),us.setFaceLinks(X,b),us.setEdgeMates(R,M),us.setEdgeMates(X,y),this.transferEdgeProperties(y,R),this.transferEdgeProperties(M,X)}return R}static splitEdgeCreateSliverFace(y,k){const M=y.edgeMate,b=new us,E=new us;return k&&(k.push(b),k.push(E)),b._faceSuccessor=b._facePredecessor=E,E._faceSuccessor=E._facePredecessor=b,us.setEdgeMates(b,M),us.setEdgeMates(E,y),b.copyDataFrom(y,!0,!0,!1,!1),E.copyDataFrom(M,!0,!0,!1,!1),b}static transferEdgeProperties(y,k){k.edgeTag=y.edgeTag;for(const M of this._edgePropertyMasks)y.getMask(M)?k.setMask(M):k.clearMask(M)}get vertexSuccessor(){return this.facePredecessor.edgeMate}get vertexPredecessor(){return this.edgeMate.faceSuccessor}setMask(y){this.maskBits|=y}getMask(y){return this.maskBits&y}clearMask(y){this.maskBits&=~y}setMaskAroundVertex(y){let k=this;do{k.setMask(y),k=k.vertexSuccessor}while(k!==this)}setXYZAroundVertex(y,k,M){let b=this;do{b.x=y,b.y=k,b.z=M,b=b.vertexSuccessor}while(b!==this)}setMaskAroundFace(y){let k=this;do{k.setMask(y),k=k.faceSuccessor}while(k!==this)}setMaskAroundEdge(y){this.setMask(y),this.edgeMate.setMask(y)}clearMaskAroundEdge(y){this.clearMask(y),this.edgeMate.clearMask(y)}countEdgesAroundFace(){let y=0,k=this;do{y++,k=k.faceSuccessor}while(k!==this);return y}findAroundVertex(y){let k=this;do{if(k===y)return!0;k=k.vertexSuccessor}while(k!==this);return!1}findAroundFace(y){let k=this;do{if(k===y)return!0;k=k.faceSuccessor}while(k!==this);return!1}isMaskedAroundFace(y,k=!0){let M=this;if(k)do{if(!M.isMaskSet(y))return!1;M=M.faceSuccessor}while(M!==this);else do{if(M.isMaskSet(y))return!1;M=M.faceSuccessor}while(M!==this);return!0}setMaskAndEdgeTagAroundFace(y,k,M=!1){let b=this;do{if(b.setMask(y),b.edgeTag=k,M){const M=b.edgeMate;M.setMask(y),M.edgeTag=k}b=b.faceSuccessor}while(b!==this)}countEdgesAroundVertex(){let y=0,k=this;do{y++,k=k.vertexSuccessor}while(k!==this);return y}countMaskAroundFace(y,k=!0){let M=0,b=this;if(k)do{b.isMaskSet(y)&&M++,b=b.faceSuccessor}while(b!==this);else do{b.isMaskSet(y)||M++,b=b.faceSuccessor}while(b!==this);return M}countMaskAroundVertex(y,k=!0){let M=0,b=this;if(k)do{b.isMaskSet(y)&&M++,b=b.vertexSuccessor}while(b!==this);else do{b.isMaskSet(y)||M++,b=b.vertexSuccessor}while(b!==this);return M}findMaskAroundVertex(y,k=!0){let M=this;do{if(M.isMaskSet(y)===k)return M;M=M.vertexSuccessor}while(M!==this)}findMaskAroundFace(y,k=!0){let M=this;do{if(M.isMaskSet(y)===k)return M;M=M.faceSuccessor}while(M!==this)}findMaskAroundEdge(y,k=!0){if(this.isMaskSet(y)===k)return this;const M=this.edgeMate;return M.isMaskSet(y)===k?M:void 0}testAndSetMask(y){const k=this.maskBits&y;return this.maskBits|=y,k}setXYZFrom(y){this.x=y.x,this.y=y.y,this.z=y.z}setXYZ(y){this.x=y.x,this.y=y.y,this.z=y.z}isMaskSet(y){return!!(this.maskBits&y)}static filterIsMaskOn(y,k){return y.isMaskSet(k)}static filterIsMaskOff(y,k){return!y.isMaskSet(k)}static createEdgeXYXY(y,k,M,b,E,D){const R=new us(k,M),X=new us(E,D);return R._faceSuccessor=R._facePredecessor=R._edgeMate=X,X._faceSuccessor=X._facePredecessor=X._edgeMate=R,R._id=y,X._id=b,R}static pinch(y,k){if(y!==k){const M=y._facePredecessor,b=k._facePredecessor;k._facePredecessor=M,y._facePredecessor=b,b._faceSuccessor=y,M._faceSuccessor=k}}yankFromVertexLoop(){const y=this.edgeMate.faceSuccessor;if(y!==this)return us.pinch(this,y),y}decommission(){this._facePredecessor=void 0,this._faceSuccessor=void 0,this._edgeMate=void 0}static nodeToSelf(y){return y}static nodeToId(y){return y.id}static nodeToIdString(y){return y.id.toString()}static nodeToIdMaskXY(y){return{id:y.id,mask:us.nodeToMaskString(y),xy:[y.x,y.y]}}static nodeToIdXYString(y){return`${y.id.toString()}+${us.nodeToMaskString(y)}[${y.x},${y.y}]`}static nodeToIdXYZString(y){return`[${y.id.toString()}: ${y.x},${y.y},${y.z}]`}static nodeToMaskString(y){let k="";return y.isMaskSet(Kr.BOUNDARY_EDGE)&&(k+="B"),y.isMaskSet(Kr.PRIMARY_EDGE)&&(k+="P"),y.isMaskSet(Kr.EXTERIOR)&&(k+="X"),y.isMaskSet(Kr.NULL_FACE)&&(k+="N"),k}static nodeToXY(y){return[y.x,y.y]}vectorToFaceSuccessorXY(y){return J.create(this.faceSuccessor.x-this.x,this.faceSuccessor.y-this.y,y)}vectorToFaceSuccessor(y){const k=this.faceSuccessor;return $.create(k.x-this.x,k.y-this.y,k.z-this.z,y)}vectorToFacePredecessor(y){const k=this.facePredecessor;return $.create(k.x-this.x,k.y-this.y,k.z-this.z,y)}static isNodeVisibleInSector(y,k){if(k.vertexSuccessor===k)return!0;const M=k.faceSuccessor,b=k.facePredecessor,E=this.crossProductXYToTargets(k,M,y),D=this.crossProductXYToTargets(b,k,y);if(E>0&&D>0)return!0;const R=this.crossProductXYToTargets(b,k,M);return D<=0&&E<=0?0===D&&0===E&&0===R&&(b===M&&k.vertexSuccessor!==k?y===M:us.dotProductNodeToNodeVectorsXY(b,k,k,y)>0):0===R&&0!==D&&0!==E?b!==M:R<0}static crossProductXYToTargets(y,k,M){return Q.crossProductXYXY(k.x-y.x,k.y-y.y,M.x-y.x,M.y-y.y)}static dotProductNodeToNodeVectorsXY(y,k,M,b){return Q.dotProductXYXY(k.x-y.x,k.y-y.y,b.x-M.x,b.y-M.y)}static crossProductXYAlongChain(y,k,M){return Q.crossProductXYXY(k.x-y.x,k.y-y.y,M.x-k.x,M.y-k.y)}static isSectorConvex(y,k,M,b=0){const E=.5*us.crossProductXYAlongChain(y,k,M);return b=b??0,Math.abs(E)<=Math.abs(b)?us.dotProductNodeToNodeVectorsXY(y,k,k,M)>0:E>-b}isSectorConvex(y){return void 0===y&&(y=Q.smallMetricDistanceSquared*this.signedFaceArea()),us.isSectorConvex(this.facePredecessor,this,this.faceSuccessor,y)}isFaceConvex(y=Q.smallMetricDistanceSquared){let k=this;const M=y>0?y*k.signedFaceArea():0;do{if(!k.isSectorConvex(M))return!1;k=k.faceSuccessor}while(k!==this);return!0}isolateEdge(){const y=this.edgeMate;this.yankFromVertexLoop(),y.yankFromVertexLoop()}get isIsolatedEdge(){return this===this.vertexSuccessor&&this.edgeMate===this.edgeMate.vertexSuccessor}belowYX(y){return this.y<y.y||!(this.y>y.y)&&this.x<y.x}static testNodeMaskNotExterior(y){return!y.isMaskSet(Kr.EXTERIOR)}static testMateMaskExterior(y){return y.edgeMate.isMaskSet(Kr.EXTERIOR)}static sectorSweepRadiansXYZ(y,k){const M=y.faceSuccessor,b=y.facePredecessor;return W.orientedRadiansBetweenVectorsXYZ(M.x-y.x,M.y-y.y,M.z-y.z,b.x-y.x,b.y-y.y,b.z-y.z,k.x,k.y,k.z,!0)}static testFacePositiveAreaXY(y){return y.countEdgesAroundFace()>2&&y.signedFaceArea()>0}isEqualXY(y){return this.x===y.x&&this.y===y.y}distanceXY(y){return Q.distanceXYXY(this.x,this.y,y.x,y.y)}distanceXYZ(y){return Q.distanceXYZXYZ(this.x,this.y,this.z,y.x,y.y,y.z)}collectAroundFace(y){const k=[];let M=this;do{k.push(y?y(M):M),M=M.faceSuccessor}while(M!==this);return k}collectMaskedEdgesAroundVertex(y,k=!0,M){void 0===M?M=[]:M.length=0;let b=this;do{b.isMaskSet(y)===k&&M.push(b),b=b.vertexSuccessor}while(b!==this);return M}collectAroundVertex(y){const k=[];let M=this;do{k.push(y?y(M):M),M=M.vertexSuccessor}while(M!==this);return k}sumAroundFace(y){let k=this,M=0;do{M+=y(k),k=k.faceSuccessor}while(k!==this);return M}sumAroundVertex(y){let k=this,M=0;do{M+=y(k),k=k.vertexSuccessor}while(k!==this);return M}clearMaskAroundFace(y){let k=this;do{k.clearMask(y),k=k.faceSuccessor}while(k!==this)}clearMaskAroundVertex(y){let k=this;do{k.clearMask(y),k=k.vertexSuccessor}while(k!==this)}signedFaceArea(){let y=0,k=this.x,M=0;const b=this.y;let E,D=0,R=0,X=this;do{E=X.faceSuccessor,M=E.x,R=E.y-b,y+=(k-M)*(D+R),k=M,D=R,X=E}while(X!==this);return.5*y}fractionToPoint2d(y,k){const M=this.faceSuccessor;return H.create(this.x+(M.x-this.x)*y,this.y+(M.y-this.y)*y,k)}fractionToPoint3d(y,k){const M=this.faceSuccessor;return j.create(this.x+(M.x-this.x)*y,this.y+(M.y-this.y)*y,this.z+(M.z-this.z)*y,k)}fractionAlongAndPerpendicularToPoint2d(y,k,M){const b=this.faceSuccessor,E=b.x-this.x,D=b.y-this.y;return H.create(this.x+E*y-D*k,this.y+D*y+E*k,M)}getPoint3d(y){return j.create(this.x,this.y,this.z,y)}getPoint2d(y){return H.create(this.x,this.y,y)}getVector3dAlongEdge(y){const k=this.faceSuccessor;return $.create(k.x-this.x,k.y-this.y,k.z-this.z,y)}getVector2dAlongEdge(y){const k=this.faceSuccessor;return J.create(k.x-this.x,k.y-this.y,y)}fractionToX(y){const k=this.faceSuccessor;return this.x+(k.x-this.x)*y}fractionToY(y){const k=this.faceSuccessor;return this.y+(k.y-this.y)*y}fractionToZ(y){const k=this.faceSuccessor;return this.z+(k.z-this.z)*y}static transverseIntersectionFractions(y,k,M){const b=y.faceSuccessor,E=k.faceSuccessor;if(M||(M=J.create()),Mt.linearSystem2d(b.x-y.x,k.x-E.x,b.y-y.y,k.y-E.y,k.x-y.x,k.y-y.y,M))return M}static horizontalScanFraction(y,k){const M=y.faceSuccessor,b=M.y-y.y;return Q.isSameCoordinate(k,y.y)&&Q.isSameCoordinate(k,M.y)?y:Q.isSameCoordinate(b,0)?void 0:Q.conditionalDivideFraction(k-y.y,b)}static horizontalScanFraction01(y,k){const M=y.faceSuccessor,b=M.y-y.y;if(Q.isSameCoordinate(k,y.y)&&Q.isSameCoordinate(k,M.y))return;if(Q.isSameCoordinate(b,0))return;const E=Q.conditionalDivideFraction(k-y.y,b);return void 0!==E&&E>=0&&E<=1?E:void 0}copyDataFrom(y,k,M,b,E){k&&(this.x=y.x,this.y=y.y,this.z=y.z),M&&(this.i=y.i),b&&(us.transferEdgeProperties(y,this),this.edgeTag=y.edgeTag),E&&(this.faceTag=y.faceTag)}}us._totalNodesCreated=0,us._edgePropertyMasks=[Kr.BOUNDARY_EDGE,Kr.EXTERIOR,Kr.PRIMARY_EDGE,Kr.NULL_FACE];class fs{constructor(){this._numNodesCreated=0,this.allHalfEdges=[],this._maskManager=ds.create(Kr.ALL_GRAB_DROP_MASKS)}grabMask(y=!0){const k=this._maskManager.grabMask();return y&&this.clearMask(k),k}dropMask(y){this._maskManager.dropMask(y)}createEdgeXYZXYZ(y=0,k=0,M=0,b=0,E=0,D=0,R=0,X=0){return us.createHalfEdgePairWithCoordinates(y,k,M,b,E,D,R,X,this.allHalfEdges)}createEdgeIdId(y=0,k=0){return us.createHalfEdgePairWithCoordinates(0,0,0,y,0,0,0,k,this.allHalfEdges)}createEdgeXYZHalfEdge(y=0,k=0,M=0,b=0,E,D=0){const R=us.createHalfEdgePairWithCoordinates(y,k,M,b,E.x,E.y,E.z,D,this.allHalfEdges),X=R.faceSuccessor;return us.pinch(E,X),R}createEdgeHalfEdgeHalfEdge(y,k,M,b=0){const E=us.createHalfEdgePairWithCoordinates(y.x,y.y,y.z,k,M.x,M.y,M.z,b,this.allHalfEdges),D=E.faceSuccessor;return us.pinch(y,E),us.pinch(M,D),E}createEdgeXYAndZ(y,k,M,b){return us.createHalfEdgePairWithCoordinates(y.x,y.y,y.z,k,M.x,M.y,M.z,b,this.allHalfEdges)}splitEdge(y,k=0,M=0,b=0,E=0){return us.splitEdge(y,k,M,b,E,this.allHalfEdges)}splitEdgeCreateSliverFace(y){return us.splitEdgeCreateSliverFace(y,this.allHalfEdges)}splitEdgeAtFraction(y,k){return us.splitEdge(y,y.fractionToX(k),y.fractionToY(k),y.fractionToZ(k),0,this.allHalfEdges)}decommission(){for(const y of this.allHalfEdges)y.decommission();this.allHalfEdges.length=0,this.allHalfEdges=void 0}addEdgeXY(y,k,M,b){const E=us.createEdgeXYXY(this._numNodesCreated,y,k,this._numNodesCreated+1,M,b);return this._numNodesCreated+=2,this.allHalfEdges.push(E),this.allHalfEdges.push(E.faceSuccessor),E}clearMask(y){for(const k of this.allHalfEdges)k.maskBits&=~y}setMask(y){for(const k of this.allHalfEdges)k.maskBits|=y}reverseMask(y){for(const k of this.allHalfEdges)k.maskBits^=y}countMask(y){let k=0;for(const M of this.allHalfEdges)M.isMaskSet(y)&&k++;return k}collectSegments(){const y=[];for(const k of this.allHalfEdges)k.id<k.edgeMate.id&&y.push(Ce.create(j.create(k.x,k.y),j.create(k.faceSuccessor.x,k.faceSuccessor.y)));return y}countVertexLoops(){let y=0;return this.announceVertexLoops(((k,M)=>(y++,!0))),y}countFaceLoops(){let y=0;return this.announceFaceLoops(((k,M)=>(y++,!0))),y}countFaceLoopsWithMaskFilter(y,k){let M=0;return this.announceFaceLoops(((b,E)=>(y(E,k)&&M++,!0))),M}collectVertexLoops(){const y=[];return this.announceVertexLoops(((k,M)=>(y.push(M),!0))),y}collectFaceLoops(){const y=[];return this.announceFaceLoops(((k,M)=>(y.push(M),!0))),y}announceVertexLoops(y){this.clearMask(Kr.VISITED);for(const k of this.allHalfEdges)if(!k.getMask(Kr.VISITED)&&(k.setMaskAroundVertex(Kr.VISITED),!y(this,k)))break}announceFaceLoops(y){this.clearMask(Kr.VISITED);for(const k of this.allHalfEdges)if(!k.getMask(Kr.VISITED)&&(k.setMaskAroundFace(Kr.VISITED),!y(this,k)))break}announceEdges(y){this.clearMask(Kr.VISITED);for(const k of this.allHalfEdges){if(k.getMask(Kr.VISITED))continue;const M=k.edgeMate;if(k.setMask(Kr.VISITED),M.setMask(Kr.VISITED),!y(this,k))break}}announceNodes(y){for(const k of this.allHalfEdges)if(!y(this,k))break}countNodes(){return this.allHalfEdges.length}transformInPlace(y){for(const k of this.allHalfEdges)y.multiplyXYAndZInPlace(k)}yankAndDeleteEdges(y){const k=this.allHalfEdges.length;let M=0;for(let E=0;E<k;E++){const k=this.allHalfEdges[E];y(k)?k.yankFromVertexLoop():this.allHalfEdges[M++]=k}const b=k-M;return this.allHalfEdges.length=M,b}deleteIsolatedEdges(){const y=this.allHalfEdges.length;let k=0;for(let b=0;b<y;b++){const y=this.allHalfEdges[b];y.isIsolatedEdge||(this.allHalfEdges[k++]=y)}const M=y-k;return this.allHalfEdges.length=k,M}}class gs{constructor(y,k=Le){this._array=[],this._compare=y,this._clone=k}get length(){return this._array.length}get isEmpty(){return 0===this.length}[Symbol.iterator](){return this._array[Symbol.iterator]()}_swap(y,k){const M=this._array[y];this._array[y]=this._array[k],this._array[k]=M}_heapify(y){let k=-1;for(;;){const M=2*(y+1),b=M-1;if(k=b<this.length&&this._compare(this._array[b],this._array[y])<0?b:y,M<this.length&&this._compare(this._array[M],this._array[k])<0&&(k=M),k===y)break;this._swap(k,y),y=k}}sort(){for(let y=Math.ceil(this.length/2);y>=0;y--)this._heapify(y)}push(y){const k=this._clone(y);let M=this.length;for(this._array.push(k);0!==M;){const y=Math.floor((M-1)/2);if(!(this._compare(this._array[M],this._array[y])<0))break;this._swap(M,y),M=y}return k}append(y){const k=this._clone(y);return this._array.push(k),k}get front(){return this._peek(0)}pop(){return this._pop(0)}clear(){this._array.length=0}_pop(y){if(y<0||y>=this.length)return;const k=this._array[y];return this._swap(y,this.length-1),this._array.length--,this._heapify(y),k}_peek(y){return y<0||y>=this.length?void 0:this._array[y]}}class ps{constructor(y=(y,k)=>Gs.compareNodesYXUp(y,k)){this.priorityQueue=new gs(y),this.activeEdges=[]}popQueueToArray(){if(this.priorityQueue.isEmpty)return;const y=this.priorityQueue.pop();return this.activeEdges.push(y),y}popArrayToArrayIndex(y){if(y<this.activeEdges.length){const k=this.activeEdges.pop();this.activeEdges[y]=k}}removeArrayMembersWithY1Below(y){let k=0;const M=this.activeEdges.length;for(let b=0;b<M;b++){const M=this.activeEdges[b];M.faceSuccessor.y>=y&&(k<b&&(this.activeEdges[k]=M),k++)}this.activeEdges.length=k}}class ms{constructor(y){this.graph=y,this.upEdges=[],this.downEdges=[],this.bottomPeaks=[],this.topPeaks=[],this.localMin=[],this.localMax=[]}collectVerticalEventsAroundFace(y){let k,M,b,E,D=y;this.upEdges.length=0,this.downEdges.length=0,this.topPeaks.length=0,this.bottomPeaks.length=0,this.localMin.length=0,this.localMax.length=0;do{k=D.faceSuccessor,M=k.faceSuccessor,b=Gs.compareNodesYXUp(D,k)<0,E=Gs.compareNodesYXUp(k,M)<0,b?(this.upEdges.push(D),E||(Gs.crossProductToTargets(k,D,M)<0?this.localMax.push(k):this.topPeaks.push(k))):(this.downEdges.push(D),E&&(Gs.crossProductToTargets(k,D,M)>0?this.bottomPeaks.push(k):this.localMin.push(k))),D=k}while(D!==y)}collectVerticalEventFromEdgesInAndArray(y){let k,M,b,E,D;for(k of(this.upEdges.length=0,this.downEdges.length=0,this.topPeaks.length=0,this.bottomPeaks.length=0,this.localMin.length=0,this.localMax.length=0,y))M=k.faceSuccessor,b=M.faceSuccessor,E=Gs.compareNodesYXUp(k,M)<0,D=Gs.compareNodesYXUp(M,b)<0,E?(this.upEdges.push(k),D||(Gs.crossProductToTargets(M,k,b)<0?this.localMax.push(M):this.topPeaks.push(M))):(this.downEdges.push(k),D&&(Gs.crossProductToTargets(M,k,b)>0?this.bottomPeaks.push(M):this.localMin.push(M)))}swapArrays(){let y=this.downEdges;this.downEdges=this.upEdges,this.upEdges=y,y=this.localMax,this.localMax=this.localMin,this.localMin=y,y=this.topPeaks,this.topPeaks=this.bottomPeaks,this.bottomPeaks=y}findTopVisibleEdge(y,k,M){const b=y.y,E=y.x;let D,R,X=Number.MAX_SAFE_INTEGER;for(const z of k){const k=z.faceSuccessor;if(z===y||k===y)continue;if(Gs.compareNodesYXUp(y,z)*Gs.compareNodesYXUp(y,k)>=0)continue;const N=us.horizontalScanFraction01(z,b);void 0!==N&&(D=M*(z.fractionToX(N)-E),D>0&&D<X&&(R=z,X=D))}return R}highestUpPeakConnection(y,k,M){let b;for(const E of this.topPeaks){const D=E.y,R=E.x;if(!(void 0!==b&&Gs.compareNodesYXUp(E,b)<0)&&Gs.compareNodesYXUp(E,y)<0){if(k){const y=us.horizontalScanFraction01(k,D);if(void 0===y)continue;if(R<=k.fractionToX(y))continue}if(M){const y=us.horizontalScanFraction01(M,D);if(void 0===y)continue;if(M.fractionToX(y)<=R)continue}b=E}}return b}updateMaxNode(y,k,M){return y?k&&M(y,k)<0?k:y:k}negateXY(){for(const y of this.graph.allHalfEdges)y.x*=-1,y.y*=-1}downwardConnectionFromBottomPeak(y){let k;const i=(y,k)=>Gs.compareNodesYXUp(y,k),M=this.findTopVisibleEdge(y,this.upEdges,1),b=this.findTopVisibleEdge(y,this.downEdges,-1);k=this.updateMaxNode(k,M,i),b&&(k=this.updateMaxNode(k,b.faceSuccessor,i));const E=this.highestUpPeakConnection(y,b,M);return void 0!==E&&(k=this.updateMaxNode(k,E,i)),k}findVisibleSector(y,k){let M=y;do{if(us.isNodeVisibleInSector(k,M))return M;M=M.vertexSuccessor}while(M!==y)}joinNodes(y,k,M){const b=this.graph.createEdgeXYZXYZ(y.x,y.y,y.z,0,k.x,k.y,k.z,0),E=this.findVisibleSector(y,k),D=this.findVisibleSector(k,y);if(void 0!==E&&void 0!==D)return us.pinch(E,b),us.pinch(D,b.edgeMate),ms.announceEdge&&ms.announceEdge(this.graph,y,k,M),b}runRegularization(y=!0,k=!0){if(y){this.bottomPeaks.sort(((y,k)=>Gs.compareNodesYXUp(y,k)));for(const y of this.bottomPeaks){if(!Gs.isDownPeak(y))continue;const k=this.downwardConnectionFromBottomPeak(y);void 0!==k&&this.joinNodes(y,k,1)}}if(k){this.negateXY(),this.swapArrays(),this.bottomPeaks.sort(((y,k)=>Gs.compareNodesYXUp(y,k)));for(const y of this.bottomPeaks){if(!Gs.isDownPeak(y))continue;const k=this.downwardConnectionFromBottomPeak(y);void 0!==k&&this.joinNodes(y,k,-1)}this.negateXY(),this.swapArrays()}}regularizeFace(y,k=!0,M=!0){this.collectVerticalEventsAroundFace(y),this.runRegularization(k,M)}regularizeGraph(y=!0,k=!0){this.collectVerticalEventFromEdgesInAndArray(this.graph.allHalfEdges),this.runRegularization(y,k)}static isMonotoneFace(y){let k,M=0,b=0,E=y;do{const y=E.faceSuccessor,D=y.faceSuccessor,R=Gs.compareNodesYXUp(E,y),X=Gs.compareNodesYXUp(y,D);R*X<=0&&(R>0&&(M++,k=y),X>0&&b++)}while((E=E.faceSuccessor)!==y);return 1===M&&1===b?k:void 0}static collectMappedFaceRepresentatives(y,k,M,b,E){b&&(b.length=0),E&&(E.length=0);const D=Kr.VISITED;y.clearMask(D);for(const R of y.allHalfEdges)if(!R.getMask(D)&&(R.setMaskAroundFace(D),!k||R.signedFaceArea()>0)){const y=M(R);y?b&&b.push(y):E&&E.push(R)}}}class xs extends si{isSameGeometryClass(y){return y instanceof xs}get children(){return this._children}constructor(){super(),this.curveCollectionType="unionRegion",this._children=[]}static create(...y){const k=new xs;for(const M of y)k.tryAddChild(M);return k}dgnBoundaryType(){return 5}announceToCurveProcessor(y,k=-1){return y.announceUnionRegion(this,k)}cloneStroked(y){const k=new xs;let M;for(M of this._children){const b=M.cloneStroked(y);b&&k.children.push(b)}return k}cloneEmptyPeer(){return new xs}tryAddChild(y){return!(!y||!(y instanceof bi||y instanceof hi)||(this._children.push(y),0))}getChild(y){if(y<this._children.length)return this._children[y]}dispatchToGeometryHandler(y){return y.handleUnionRegion(this)}}class _s{constructor(){this._cachedObjects=[],this.numDrop=0,this.numCreate=0,this.numReuse=0}dropToCache(y){y&&(this.numDrop++,this.clearForCache(y),this._cachedObjects.push(y))}grabFromCache(){let y=this._cachedObjects.pop();return void 0===y?(y=this.createForCache(),this.numCreate++):this.numReuse++,y}dropAllToCache(y){for(;y.length>0;)this.dropToCache(y.pop())}}class ys extends _s{clearForCache(y){y.length=0}createForCache(){return new nt(10)}constructor(){super()}grabAndFill(y){const k=this.grabFromCache();return k.pushFrom(y),k}}class vs{get convexSets(){return this._convexSets}constructor(){this._convexSets=[]}toJSON(){const y=[];for(const k of this._convexSets)y.push(k.toJSON());return y}static fromJSON(y,k){if((k=k||new vs)._convexSets.length=0,!Array.isArray(y))return k;for(const M of y)k._convexSets.push(kn.fromJSON(M));return k}static createEmpty(y){return y?(y._convexSets.length=0,y):new vs}isAlmostEqual(y){if(this._convexSets.length!==y._convexSets.length)return!1;for(let k=0;k<this._convexSets.length;k++)if(!this._convexSets[k].isAlmostEqual(y._convexSets[k]))return!1;return!0}static createConvexSets(y,k){k=k||new vs;for(const M of y)k._convexSets.push(M);return k}clone(y){(y=y||new vs)._convexSets.length=0;for(const k of this._convexSets)y._convexSets.push(k.clone());return y}addConvexSet(y){y&&this._convexSets.push(y)}hasIntersectionWithRay(y,k){if(void 0===k){for(const k of this._convexSets)if(k.hasIntersectionWithRay(y))return!0;return!1}k.setNull();const M=ft.createNull();for(const b of this._convexSets)b.hasIntersectionWithRay(y,M)&&k.extendRange(M);return!k.isNull}isPointInside(y){for(const k of this._convexSets)if(k.isPointInside(y))return!0;return!1}isPointOnOrInside(y,k=Q.smallMetricDistance){for(const M of this._convexSets)if(M.isPointOnOrInside(y,k))return!0;return!1}isSphereInside(y,k){for(const M of this._convexSets)if(M.isSphereInside(y,k))return!0;return!1}isAnyPointInOrOnFromSegment(y){for(const k of this._convexSets)if(k.announceClippedSegmentIntervals(0,1,y.point0Ref,y.point1Ref))return!0;return!1}appendIntervalsFromSegment(y,k){for(const M of this._convexSets)M.announceClippedSegmentIntervals(0,1,y.point0Ref,y.point1Ref,((y,M)=>k.push(Re.create(y,M))))}transformInPlace(y){for(const k of this._convexSets)k.transformInPlace(y)}classifyPointContainment(y,k){for(const M of this._convexSets){const b=M.classifyPointContainment(y,k);if(b!==ro.StronglyOutside)return b}return ro.StronglyOutside}polygonClip(y,k){k.length=0,Array.isArray(y)&&(y=nt.create(y));const M=new nt;for(const b of this._convexSets){const E=new nt;b.polygonClip(y,E,M),0!==E.length&&k.push(E)}}announceClippedSegmentIntervals(y,k,M,b,E){let D=0;for(const R of this._convexSets)R.announceClippedSegmentIntervals(y,k,M,b,E)&&D++;return D>0}announceClippedArcIntervals(y,k){const M=vs._clipArcFractionArray;M.clear();for(const b of this._convexSets)for(const k of b.planes)k.appendIntersectionRadians(y,M);return y.sweep.radiansArrayToPositivePeriodicFractions(M),Rs.selectIntervals01(y,M,this,k)}computePlanePlanePlaneIntersectionsInAllConvexSets(y,k,M,b=!0){let E=0;for(const D of this._convexSets)E+=D.computePlanePlanePlaneIntersections(y,k,M,b);return E}multiplyPlanesByMatrix4d(y,k=!0,M=!0){if(k){const k=y.createInverse();return!!k&&this.multiplyPlanesByMatrix4d(k,!1,M)}for(const b of this._convexSets)b.multiplyPlanesByMatrix4d(y,!1,M);return!0}setInvisible(y){for(const k of this._convexSets)k.setInvisible(y)}addOutsideZClipSets(y,k,M){if(k){const M=kn.createEmpty();M.addZClipPlanes(y,k),this._convexSets.push(M)}if(M){const k=kn.createEmpty();k.addZClipPlanes(y,void 0,M),this._convexSets.push(k)}}takeConvexSets(y){let k;for(;void 0!==(k=y._convexSets.pop());)this._convexSets.push(k)}appendPolygonClip(y,k,M,b){const E=M.length,D=k.length;let R,X,z=[b.grabAndFill(y)],N=[];for(const Y of this._convexSets){for(;void 0!==(X=z.pop());)Y.appendPolygonClip(X,k,N,b),b.dropToCache(X);R=N,N=z,z=R}for(;void 0!==(X=z.pop());)M.push(X);M.length===E?Rs.restoreSingletonInPlaceOfMultipleShards(k,D,y,b):k.length===D&&Rs.restoreSingletonInPlaceOfMultipleShards(M,E,y,b)}}vs._clipArcFractionArray=new It;class Ps{static advanceIntervalDifference(y,k,M,b){const E=k.length;let D=y.low,R=y.high;for(;M<E;){const y=k[M];if(y.high<D)M++;else{if(!(y.high<=R)){y.low<R&&(R=y.low);break}y.low>D&&b.push(ft.createXX(D,y.low)),D=y.high,M++}}return D<R&&b.push(ft.createXX(D,R)),b}static differenceSorted(y,k){const M=y.length,b=[];for(let E=0;E<M;E++)Ps.advanceIntervalDifference(y[E],k,0,b);return b}static advanceIntervalIntersection(y,k,M){return k.low>y.high||(k.high>=y.high?(M.push(ft.createXX(k.low,y.high)),!0):(M.push(ft.createXX(k.low,k.high)),!1))}static intersectSorted(y,k){let M=0,b=0;const E=y.length,D=k.length,R=[];for(;M<E&&b<D;){const E=y[M],D=k[b];E.low<=D.low?Ps.advanceIntervalIntersection(E,D,R)?M++:b++:Ps.advanceIntervalIntersection(D,E,R)?b++:M++}return R}static advanceIntervalUnion(y,k,M){if(M>=k.length)return!1;const b=k[M];return!(b.low>y.high||(b.high>y.high&&(y.high=b.high),0))}static unionSorted(y,k){const M=y.length,b=k.length;let E=0,D=0;const R=[];for(;E<M&&D<b;){const M=y[E],b=k[D];let X;M.low<=b.low?(X=M.clone(),E++):(X=b.clone(),D++);let z=!0;do{const M=Ps.advanceIntervalUnion(X,y,E),b=Ps.advanceIntervalUnion(X,k,D);M&&E++,b&&D++,M||b||(z=!1)}while(z);R.push(X)}for(;E<M;)R.push(y[E++]);for(;D<b;)R.push(k[D++]);return R}static paritySorted(y,k){const M=[];for(const b of y)M.push(b.clone());for(const b of k)M.push(b.clone());return M.sort(As),Ps.simplifySortParity(M,!0),M}static sort(y){y.sort(As)}static simplifySortUnion(y,k=!1){if(y.length<2)return;y.sort(As);let M=0;for(let b=1;b<y.length;b++)y[b].low<=y[M].high?y[b].high>y[M].high&&(y[M].high=y[b].high):(M++,y[M].setFrom(y[b]));if(y.length=M+1,k){M=-1;for(let k=0;k<y.length;k++)y[k].low<y[k].high&&M<k&&y[++M].setFrom(y[k])}}static simplifySortParity(y,k=!1){const M=[];for(const X of y)X.low!==X.high&&(M.push(X.low),M.push(X.high));const b=M.length;M.sort(((y,k)=>y<k?-1:y>k?1:0));let E,D,R=0;for(let X=0;X<b;X+=2)if(E=M[X],D=M[X+1],k){for(;X+2<b&&M[X+2]===D;)X+=2,D=M[X+1];D>E&&ft.createXX(E,D,y[R++])}else ft.createXX(E,D,y[R++]);y.length=R}static testUnion(y,k){return this.countContainingRanges(y,k)>0}static testParity(y,k){let M=!1;for(const b of y)b.containsX(k)&&(M=!M);return M}static countContainingRanges(y,k){let M=0;for(const b of y)b.containsX(k)&&M++;return M}static getBreaks(y,k,M=!1,b=!1,E=!0){k||(k=new It(2*y.length)),E&&k.clear();for(const D of y)k.push(D.low),k.push(D.high);return M&&k.sort(),b&&k.compressAdjacentDuplicates(),k}static appendFractionalPoints(y,k,M,b,E,D,R,X){const z=y.length;if(z>0){void 0!==k&&X.push(y[0].fractionToPoint(k));for(let k=0;k<z;k++)void 0===M||!b&&y[k].low===y[k].high||X.push(y[k].fractionToPoint(M)),k>1&&void 0!==E&&(D||y[k].low!==y[k].high)&&X.push(Q.interpolate(y[k-1].high,E,y[k].low));void 0!==R&&X.push(y[z-1].fractionToPoint(R))}return X}static firstLowToLastHigh(y){return 0===y.length?ft.createNull():ft.createXX(y[0].low,y[y.length-1].high)}static sumLengths(y){let k=0;for(const M of y)k+=M.length();return k}static isSorted(y,k=!0){const M=y.length;if(k){for(let b=0;b+1<M;b++)if(y[b].high>=y[b+1].low)return!1}else for(let b=0;b+1<M;b++)if(y[b].high>y[b+1].low)return!1;return!0}}function As(y,k){return y.low<k.low?-1:y.low>k.low?1:y.high<k.high?-1:y.high>k.high?1:0}class Is{constructor(){this.points=[],this.planes=kn.createEmpty(),this.children=[],this.startIdx=-1,this.numPoints=-1}static createWithIndices(y,k,M){return(M=M||new Is).startIdx=y,M.numPoints=k,M.children.length=0,M}static createTreeForPolygon(y,k){return(k=k||new Is).empty(),Ss.createPointsRef(y).buildHullTree(k),k}static createHullAndInletsForPolygon(y,k){return(k=k||new Is).empty(),Ss.createPointsRef(y).buildHullAndInletsForPolygon(k),k}extractLoopsGo(y){y.push(ue.clonePoint3dArray(this.points));for(const k of this.children)k.extractLoopsGo(y)}extractLoops(){const y=[];return this.extractLoopsGo(y),y}empty(){this.points.length=0,this.planes.planes.length=0,this.children.length=0,this.startIdx=-1,this.numPoints=-1}clone(y){y=y||new Is;for(const k of this.points)y.points.push(k.clone());y.planes=kn.createEmpty();for(const k of this.planes.planes)y.planes.planes.push(k.clone());for(const k of this.children)y.children.push(k.clone());return y.startIdx=this.startIdx,y.numPoints=this.numPoints,y}addEmptyChild(y,k){const M=Is.createWithIndices(y,k);this.children.push(M)}addPlane(y){this.planes.addPlaneToConvexSet(y)}isPointOnOrInside(y){if(!this.planes.isPointOnOrInside(y,0))return!1;for(const k of this.children)if(k.isPointOnOrInside(y))return!1;return!0}captureConvexClipPlaneSetAsVoid(y){this.children.push(y)}appendCurvePrimitiveClipIntervals(y,k,M){(new ws).appendSingleClipPrimitive(this,y,k,M)}appendCurveCollectionClipIntervals(y,k,M){(new ws).appendCurveCollectionClip(this,y,k,M)}appendPolygonClip(y,k,M,b){const E=M.length,D=this.planes.clipInsidePushOutside(y,M,b);if(void 0===D)Rs.restoreSingletonInPlaceOfMultipleShards(M,E,y,b);else{let y,E,R=[D],X=[];for(const k of this.children){for(X.length=0;void 0!==(E=R.pop());)k.appendPolygonClip(E,M,X,b),b.dropToCache(E);y=X,X=R,R=y}for(;void 0!==(E=R.pop());)k.push(E)}}depth(){let y=0;for(const k of this.children)y=Math.max(y,k.depth());return 1+y}}class Ss{constructor(){this._points=[],this._stack=[]}static createPointsRef(y,k){return(k=k||new Ss)._points=y,Ur.areaXY(y)<0&&k._points.reverse(),k._points[k._points.length-1].isAlmostEqualMetric(k._points[0])&&k._points.pop(),k}get period(){return this._points.length}indexAfter(y){return(y+1)%this._points.length}indexBefore(y){return(y+this._points.length-1)%this._points.length}pushIndex(y){this._stack.push(y)}static cross(y,k,M){return y.crossProductToPointsXY(k,M)}cyclicStackPoint(y){let k;const M=this._stack;return k=y>0?y:y+10*M.length,k%=M.length,this._points[M[k]]}signFromStackTip(y,k){const M=this.cyclicStackPoint(-2),b=this.cyclicStackPoint(-1),E=this._points[y];return k*Ss.cross(M,b,E)>=0?1:-1}get indexOfMaxX(){let y=0;const k=this._points,M=this._points.length;for(let b=1;b<M;b++)k[b].x>k[y].x&&(y=b);return y}extendHullChain(y,k,M){for(;this._stack.length>1&&this.signFromStackTip(y,k)<0;)this._stack.pop();M&&this.pushIndex(y)}collectHullChain(y,k,M){if(this._stack.length=0,k>2){let b=y;for(let y=0;y<k;y++)this.extendHullChain(b,M,!0),b=this.indexAfter(b)}}collectHullPointsInArray(y,k,M,b){if(y.length=0,M>2){let b=k;for(let k=0;k<M;k++)y.push(this._points[b]),b=this.indexAfter(b)}}buildHullTreeGo(y,k,M=!0){this.collectHullChain(y.startIdx,y.numPoints,k?1:-1),y.points.length=0;const b=this._stack,E=this._points,D=b.length;for(let R=0;R<D;R++){const M=b[R];if(y.points.push(E[M]),R+1<D){let D=b[R+1];if(D===this.indexAfter(M)){const b=Wr.createEdgeAndUpVector(E[M],E[D],$.create(0,0,1),W.createRadians(0));void 0!==b&&(k&&b.negateInPlace(),y.addPlane(b))}else D<M&&(D+=this.period),y.addEmptyChild(M,D-M+1)}}if(M)for(const R of y.children)this.buildHullTreeGo(R,!k);else for(const R of y.children)this.collectHullPointsInArray(R.points,R.startIdx,R.numPoints,k?-1:1);return!0}buildHullAndInletsForPolygon(y){return Is.createWithIndices(this.indexOfMaxX,this.period+1,y),this.buildHullTreeGo(y,!0,!1)}buildHullTree(y){return Is.createWithIndices(this.indexOfMaxX,this.period+1,y),this.buildHullTreeGo(y,!0)}}class ws{constructor(){this._stackDepth=0,this._intervalStack=[]}setCurveRef(y){this._curve=y}popSegmentFrame(){this._stackDepth>0&&(this._topOfStack.length=0,this._stackDepth-=1)}clearSegmentStack(){for(;this._stackDepth>0;)this.popSegmentFrame()}pushEmptySegmentFrame(){for(this._stackDepth+=1;this._intervalStack.length<this._stackDepth;)this._intervalStack.push([]);this._topOfStack.length=0}get _topOfStack(){return this._intervalStack[this._stackDepth-1]}set _topOfStack(y){const k=this._stackDepth;k>0&&(this._intervalStack[k-1]=y)}stackEntry(y){return y<=this._stackDepth?this._intervalStack[this._stackDepth-1-y]:[]}isTopOfStackEmpty(){return 0===this._topOfStack.length}appendSingleClipToStack(y,k){const M=ws._fractionIntervals;if(this._curve instanceof Ce){let M,b;return this._curve.announceClipIntervals(y,((y,k,E)=>{M=y,b=k}))&&k.push(ft.createXX(M,b)),!0}if(this._curve instanceof Ti){const b=this._curve;M.length=0,b.announceClipIntervals(y,((y,k,b)=>{M.push(y),M.push(k)}));for(let y=0;y<M.length;y+=2)k.push(ft.createXX(M[y],M[y+1]));return!0}if(this._curve instanceof Me&&this._curve.points.length>1){const M=this._curve;let b,E;const D=M.points.length,R=1/(D-1);for(let X=0;X<D-1;X++)Ce.create(M.points[X],M.points[X+1]).announceClipIntervals(y,((y,k,M)=>{b=y,E=k}))&&k.push(ft.createXX((X+b)*R,(X+E)*R));return!0}if(this._curve instanceof Be){const b=this._curve;M.length=0,b.announceClipIntervals(y,((y,k,b)=>{M.push(y),M.push(k)}));for(let y=0;y<M.length;y+=2)k.push(ft.createXX(M[y],M[y+1]));return!0}return!1}recurse(y){if(this.pushEmptySegmentFrame(),this.appendSingleClipToStack(y.planes,this._topOfStack),Ps.sort(this._topOfStack),!this.isTopOfStackEmpty())for(const k of y.children){if(this.recurse(k),this.isTopOfStackEmpty())this.popSegmentFrame();else{const y=Ps.differenceSorted(this.stackEntry(1),this.stackEntry(0));this.popSegmentFrame(),this._topOfStack=y}if(this.isTopOfStackEmpty())break}}appendSingleClipPrimitive(y,k,M,b){if(this.setCurveRef(k),this.clearSegmentStack(),this.recurse(y),1!==this._stackDepth)return;const E=this._topOfStack;for(const D of E){const y=D.low,b=D.high,E=k.fractionToPoint(y),R=k.fractionToPoint(b);M.push(Pt.createCapture(vt.createCurveFractionPoint(k,y,E),vt.createCurveFractionPoint(k,b,R)))}this.popSegmentFrame()}appendCurveCollectionClip(y,k,M,b){for(const E of k.children)E instanceof ae?this.appendSingleClipPrimitive(y,E,M,b):E instanceof si&&this.appendCurveCollectionClip(y,E,M,b)}}ws._fractionIntervals=[],function(y){y[y.None=0]="None",y[y.XLow=1]="XLow",y[y.XHigh=2]="XHigh",y[y.YLow=4]="YLow",y[y.YHigh=8]="YHigh",y[y.ZLow=16]="ZLow",y[y.ZHigh=32]="ZHigh",y[y.XAndY=15]="XAndY",y[y.All=63]="All"}(so||(so={}));class Cs{fetchClipPlanesRef(){return this.ensurePlaneSets(),this._clipPlanes}get invisible(){return this._invisible}constructor(y,k=!1){this._clipPlanes=y,this._invisible=k}static createCapture(y,k=!1){let M;return y instanceof vs&&(M=y),y instanceof kn&&(M=vs.createConvexSets([y])),new Cs(M,k)}toJSON(){const y={};return this._clipPlanes&&(y.clips=this._clipPlanes.toJSON()),this._invisible&&(y.invisible=!0),{planes:y}}arePlanesDefined(){return void 0!==this._clipPlanes}clone(){const y=this._clipPlanes?this._clipPlanes.clone():void 0;return new Cs(y,this._invisible)}ensurePlaneSets(){}pointInside(y,k=Q.smallMetricDistanceSquared){this.ensurePlaneSets();let M=!0;return this._clipPlanes&&(M=this._clipPlanes.isPointOnOrInside(y,k)),M}isPointOnOrInside(y,k=Q.smallMetricDistanceSquared){this.ensurePlaneSets();let M=!0;return this._clipPlanes&&(M=this._clipPlanes.isPointOnOrInside(y,k)),M}announceClippedSegmentIntervals(y,k,M,b,E){this.ensurePlaneSets();let D=!1;return this._clipPlanes&&(D=this._clipPlanes.announceClippedSegmentIntervals(y,k,M,b,E)),D}announceClippedArcIntervals(y,k){this.ensurePlaneSets();let M=!1;return this._clipPlanes&&(M=this._clipPlanes.announceClippedArcIntervals(y,k)),M}multiplyPlanesByMatrix4d(y,k=!0,M=!0){if(k){const k=y.createInverse();return!!k&&this.multiplyPlanesByMatrix4d(k,!1,M)}return this._clipPlanes&&this._clipPlanes.multiplyPlanesByMatrix4d(y),!0}transformInPlace(y){return this._clipPlanes&&this._clipPlanes.transformInPlace(y),!0}setInvisible(y){this._invisible=y}containsZClip(){if(void 0!==this.fetchClipPlanesRef())for(const y of this._clipPlanes.convexSets)for(const k of y.planes)if(Math.abs(k.inwardNormalRef.z)>1e-6&&Math.abs(k.distance)!==Number.MAX_VALUE)return!0;return!1}classifyPointContainment(y,k){this.ensurePlaneSets();const M=this._clipPlanes;let b=ro.StronglyInside;if(M&&(b=M.classifyPointContainment(y,!1)),this._invisible&&!k)switch(b){case ro.StronglyInside:return ro.StronglyOutside;case ro.StronglyOutside:return ro.StronglyInside;case ro.Ambiguous:return ro.Ambiguous}return b}static fromJSON(y){if(y)return Fs.fromClipShapeJSON(y)||Cs.fromJSONClipPrimitive(y)}static fromJSONClipPrimitive(y){const k=y?.planes;if(!k)return;const M=k.clips?vs.fromJSON(k.clips):void 0,b=void 0!==k.invisible&&k.invisible;return new Cs(M,b)}}class Ts{constructor(y,k,M,b){this.pointA=j.create(y.x,y.y,b),this.pointB=j.create(k.x,k.y,b),this.normal=M}static makeUnitPerpendicularToBisector(y,k,M){let b=k.normal.minus(y.normal);if(void 0!==b.normalize(b)||(b=$.createStartEnd(y.pointA,k.pointB),void 0!==b.normalize(b)))return M&&b.scale(-1,b),b}}class Fs extends Cs{constructor(y=[],k,M,b,E=!1,D=!1){super(void 0,D),this._isMask=!1,this._polygon=y,this.initSecondaryProps(E,k,M,b)}get invisible(){return this._invisible}get transformFromClip(){return this._transformFromClip}get transformToClip(){return this._transformToClip}get transformValid(){return void 0!==this.transformFromClip}get zLowValid(){return void 0!==this._zLow}get zHighValid(){return void 0!==this._zHigh}get transformIsValid(){return void 0!==this._transformFromClip}get zLow(){return this._zLow}get zHigh(){return this._zHigh}get polygon(){return this._polygon}get isMask(){return this._isMask}setPolygon(y){y[0].isAlmostEqual(y[y.length-1])||y.push(y[0].clone()),this._polygon=y}ensurePlaneSets(){void 0===this._clipPlanes&&(this._clipPlanes=vs.createEmpty(),this.parseClipPlanes(this._clipPlanes),this._transformFromClip&&this._clipPlanes.transformInPlace(this._transformFromClip))}initSecondaryProps(y,k,M,b){this._isMask=y,this._zLow=k,this._zHigh=M,void 0!==b?(this._transformFromClip=b,this._transformToClip=b.inverse()):(this._transformFromClip=pt.createIdentity(),this._transformToClip=pt.createIdentity())}toJSON(){const y={points:this._polygon.map((y=>y.toJSON()))};return this.invisible&&(y.invisible=!0),this._transformFromClip&&!this._transformFromClip.isIdentity&&(y.trans=this._transformFromClip.toJSON()),this.isMask&&(y.mask=!0),void 0!==this.zLow&&this.zLow!==-Number.MAX_VALUE&&(y.zlow=this.zLow),void 0!==this.zHigh&&this.zHigh!==Number.MAX_VALUE&&(y.zhigh=this.zHigh),{shape:y}}static fromClipShapeJSON(y,k){const M=y?.shape;if(!M)return;const b=M.points?M.points.map((y=>j.fromJSON(y))):[],E=M.trans?pt.fromJSON(M.trans):void 0,D="number"==typeof M.zlow?M.zlow:void 0,R="number"==typeof M.zhigh?M.zhigh:void 0,X="boolean"==typeof M.mask&&M.mask,z="boolean"==typeof M.invisible&&M.invisible;return Fs.createShape(b,D,R,E,X,z,k)}static createFrom(y,k){const M=Fs.createEmpty(!1,!1,void 0,k);M._invisible=y._invisible;for(const b of y._polygon)M._polygon.push(b.clone());return M._isMask=y._isMask,M._zLow=y._zLow,M._zHigh=y._zHigh,M._transformToClip=y._transformToClip?y._transformToClip.clone():void 0,M._transformFromClip=y._transformFromClip?y._transformFromClip.clone():void 0,M}static createShape(y=[],k,M,b,E=!1,D=!1,R){if(y.length<3)return;const X=y.slice(0);return X[0].isAlmostEqual(X[X.length-1])?X[0].clone(X[X.length-1]):X.push(X[0].clone()),R?(R._clipPlanes=void 0,R._invisible=D,R._polygon=X,R.initSecondaryProps(E,k,M,b),R):new Fs(X,k,M,b,E,D)}static createBlock(y,k,M=!1,b=!1,E,D){const R=y.low,X=y.high,z=[];for(let N=0;N<5;N++)z.push(j.create());return z[0].x=z[3].x=z[4].x=R.x,z[1].x=z[2].x=X.x,z[0].y=z[1].y=z[4].y=R.y,z[2].y=z[3].y=X.y,Fs.createShape(z,so.None!==(k&so.ZLow)?R.z:void 0,so.None!==(k&so.ZHigh)?X.z:void 0,E,M,b,D)}static createEmpty(y=!1,k=!1,M,b){return b?(b._clipPlanes=void 0,b._invisible=k,b._polygon.length=0,b.initSecondaryProps(y,void 0,void 0,M),b):new Fs([],void 0,void 0,M,y,k)}get isValidPolygon(){return!(this._polygon.length<3||!this._polygon[0].isExactEqual(this._polygon[this._polygon.length-1]))}clone(y){return Fs.createFrom(this,y)}parseClipPlanes(y){const k=this._polygon;if(3===k.length&&!this._isMask&&k[0].isExactEqual(k[k.length-1]))return this.parseLinearPlanes(y,this._polygon[0],this._polygon[1]),!0;if(!this.isMask){const k=Ur.testXYPolygonTurningDirections(this.polygon);if(0!==k)return this.parseConvexPolygonPlanes(y,this._polygon,k,!1),!0}return this.parsePolygonPlanes(y,this._polygon,this.isMask),!0}parseLinearPlanes(y,k,M,b){const E=k.vectorTo(M);if(0===E.magnitude())return!1;E.normalize(E);const D=kn.createEmpty();if(void 0===b){const y=J.create(-E.y,E.x);D.planes.push(Wr.createNormalAndPoint($.create(E.x,E.y),j.createFrom(k),this._invisible)),D.planes.push(Wr.createNormalAndPoint($.create(-E.x,-E.y),j.createFrom(M),this._invisible)),D.planes.push(Wr.createNormalAndPoint($.create(y.x,y.y),j.createFrom(k),this._invisible)),D.planes.push(Wr.createNormalAndPoint($.create(-y.x,-y.y),j.createFrom(k),this._invisible))}else{const y=j.create(k.x,k.y,-b),E=j.create(M.x,M.y,-b),R=$.createFrom(E),X=R.crossProduct($.createFrom(y)).normalize();let z=$.createFrom(y).crossProduct(X).normalize();D.planes.push(Wr.createNormalAndDistance(X,0,this._invisible)),D.planes.push(Wr.createNormalAndDistance(z,0,this._invisible)),X.negate(),z=R.crossProduct(X).normalize(),D.planes.push(Wr.createNormalAndDistance(X,0,this._invisible)),D.planes.push(Wr.createNormalAndDistance(z,0,this._invisible))}return D.addZClipPlanes(this._invisible,this._zLow,this._zHigh),y.addConvexSet(D),!0}parseConvexPolygonPlanes(y,k,M,b,E){const D=[],R=M<0;for(let X=0;X<k.length-1;X++){const y=void 0===E?0:-E,M=$.createStartEnd(k[X],k[X+1]),b=M.magnitude();if(M.normalize(M),b>1e-8){const b=$.create(R?M.y:-M.y,R?-M.x:M.x);D.push(new Ts(k[X],k[X+1],b,y))}}if(D.length<3)return!1;if(b){const k=D.length-1;for(let M=0;M<=k;M++){const b=D[M],E=D[M?M-1:k],X=D[M===k?0:M+1],z=kn.createEmpty(),N=Ts.makeUnitPerpendicularToBisector(E,b,!R),Y=Ts.makeUnitPerpendicularToBisector(b,X,R);N&&z.planes.push(Wr.createNormalAndPoint(N,b.pointA,this._invisible,!0)),z.planes.push(Wr.createNormalAndPoint(b.normal,b.pointB,this._invisible,!1)),Y&&z.planes.push(Wr.createNormalAndPoint(Y,X.pointA,this._invisible,!0)),y.addConvexSet(z),y.addOutsideZClipSets(this._invisible,this._zLow,this._zHigh)}}else{const k=kn.createEmpty();if(void 0===E)for(const y of D)k.planes.push(Wr.createNormalAndPoint($.create(y.normal.x,y.normal.y),y.pointA));else if(R)for(const y of D)k.planes.push(Wr.createNormalAndDistance($.createFrom(y.pointA).crossProduct($.createFrom(y.pointB)).normalize(),0));else for(const y of D)k.planes.push(Wr.createNormalAndDistance($.createFrom(y.pointB).crossProduct($.createFrom(y.pointA)).normalize(),0));k.addZClipPlanes(this._invisible,this._zLow,this._zHigh),y.addConvexSet(k)}return!0}parsePolygonPlanes(y,k,M,b){const E=Mi.compressDanglers(k,!0),r=(k,M)=>{if(!M.isMaskSet(Kr.EXTERIOR)){const k=M.collectAroundFace((y=>{if(!y.isMaskSet(Kr.EXTERIOR))return j.create(y.x,y.y,0)}));k.push(k[0].clone());const E=Ur.testXYPolygonTurningDirections(k);this.parseConvexPolygonPlanes(y,k,E,!1,b)}return!0};if(M){const k=ue.clonePoint3dArray(E),M=Is.createHullAndInletsForPolygon(k).extractLoops();if(0===M.length)return!1;const D=M[0],R=Ur.testXYPolygonTurningDirections(D);this.parseConvexPolygonPlanes(y,D,-R,!0,b);for(let y=1;y<M.length;y++){const k=Us.createTriangulatedGraphFromSingleLoop(M[y]);k&&(Us.flipTriangles(k),k.announceFaceLoops(r))}return!0}{const y=Us.createTriangulatedGraphFromSingleLoop(E);if(void 0===y)return!1;Us.flipTriangles(y),y.announceFaceLoops(r)}return!0}multiplyPlanesByMatrix4d(y,k=!0,M=!0){return this.ensurePlaneSets(),super.multiplyPlanesByMatrix4d(y,k,M)}transformInPlace(y){return y.isIdentity||(super.transformInPlace(y),this._transformFromClip?y.multiplyTransformTransform(this._transformFromClip,this._transformFromClip):this._transformFromClip=y.clone(),this._transformToClip=this._transformFromClip.inverse()),!0}get isXYPolygon(){return 0!==this._polygon.length&&(void 0===this._transformFromClip||this._transformFromClip.matrix.columnZ().magnitudeXY()<1e-8)}performTransformToClip(y){void 0!==this._transformToClip&&this._transformToClip.multiplyPoint3d(y,y)}performTransformFromClip(y){void 0!==this._transformFromClip&&this._transformFromClip.multiplyPoint3d(y,y)}}class ks{constructor(y){this._keepInside=y,this._clippers=[],this._intervalsA=[],this._intervalsB=[]}toJSON(){const y=[];for(const M of this._clippers){const k=M;k.toJSON&&y.push(k.toJSON())}const k={};return k[this.operationName]=y,k}captureChild(y){if(Array.isArray(y))for(const k of y)this.captureChild(k);else this._clippers.push(y)}toggleResult(){return this.selectResult(!this._keepInside)}selectResult(y){const k=this._keepInside;return this._keepInside=y,k}testedAnnounceNN(y,k,M){return y<k?(M&&M(y,k),1):0}testedAnnounceNNC(y,k,M,b){return y<k?(b&&b(y,k,M),1):0}swapAB(){const y=this._intervalsA;this._intervalsA=this._intervalsB,this._intervalsB=y}announcePartsNN(y,k,M,b,E){let D=0;if(y)for(const R of k)D+=this.testedAnnounceNN(R.low,R.high,E);else{let y=M;for(const M of k)D+=this.testedAnnounceNN(y,M.low,E),y=M.high;D+=this.testedAnnounceNN(y,b,E)}return D>0}announcePartsNNC(y,k,M,b,E,D){let R=0;if(y)for(const X of k)R+=this.testedAnnounceNNC(X.low,X.high,E,D);else{let y=M;for(const M of k)R+=this.testedAnnounceNNC(y,M.low,E,D),y=M.high;R+=this.testedAnnounceNNC(y,b,E,D)}return R>0}isPointOnOrInside(y){const k=this.isPointOnOrInsideChildren(y);return this._keepInside?k:!k}announceClippedSegmentIntervals(y,k,M,b,E){this._intervalsA.length=0;const r=(y,k)=>{this._intervalsB.push(ft.createXX(y,k))};let D=0;for(const R of this._clippers)this._intervalsB.length=0,R.announceClippedSegmentIntervals(y,k,M,b,r),Ps.simplifySortUnion(this._intervalsB),0===D?this.swapAB():this._intervalsA=this.combineIntervals(this._intervalsA,this._intervalsB),D++;return this.announcePartsNN(this._keepInside,this._intervalsA,y,k,E)}announceClippedArcIntervals(y,k){this._intervalsA.length=0;const i=(y,k)=>{this._intervalsB.push(ft.createXX(y,k))};let M=0;for(const b of this._clippers)this._intervalsB.length=0,b.announceClippedArcIntervals(y,i),Ps.simplifySortUnion(this._intervalsB),0===M?this.swapAB():this._intervalsA=this.combineIntervals(this._intervalsA,this._intervalsB),M++;return this.announcePartsNNC(this._keepInside,this._intervalsA,0,1,y,k)}}class Ms extends ks{get operationName(){return this._keepInside?"AND":"NAND"}constructor(y){super(y)}isPointOnOrInsideChildren(y){for(const k of this._clippers)if(!k.isPointOnOrInside(y))return!1;return!0}combineIntervals(y,k){return Ps.intersectSorted(y,k)}appendPolygonClip(y,k,M,b){Rs.doPolygonClipSequence(y,this._clippers,this._keepInside?k:M,this._keepInside?M:k,void 0,oo.passToNextStep,oo.acceptOut,oo.acceptIn,b)}}class bs{get clips(){return this._clips}constructor(y){this.boundingRange=ut.createNull(),this._clips=y||[]}get isValid(){return this._clips.length>0}static createEmpty(y){return y?(y._clips.length=0,y):new bs}static createCapture(y,k){return k?(k._clips=y,k):new bs(y)}static create(y,k){const M=[];for(const b of y)M.push(b.clone());return bs.createCapture(M,k)}clone(y){const k=y||new bs;k._clips.length=0;for(const M of this._clips)k._clips.push(M.clone());return k.boundingRange.setFrom(this.boundingRange),k}toJSON(){return this.isValid?this.clips.map((y=>y.toJSON())):[]}static fromJSON(y,k){if((k=k||new bs).clear(),!Array.isArray(y))return k;try{for(const M of y){const y=Cs.fromJSON(M);y&&k._clips.push(y)}}catch{k.clear()}return k}clear(){this._clips.length=0}appendClone(y){this._clips.push(y.clone())}appendReference(y){this._clips.push(y)}appendShape(y,k,M,b,E=!1,D=!1){const R=Fs.createShape(y,k,M,b,E,D);return!!R&&(this._clips.push(R),!0)}pointInside(y,k=Q.smallMetricDistanceSquared){return this.isPointOnOrInside(y,k)}isPointOnOrInside(y,k=Q.smallMetricDistanceSquared){if(!this.boundingRange.isNull&&!this.boundingRange.containsPoint(y))return!1;for(const M of this._clips)if(!M.pointInside(y,k))return!1;return!0}ensureProxyClipNode(){if(this._clipNodeProxy)return!0;this._clipNodeProxy=new Ms(!0);let y=0;for(const k of this._clips){const M=k.fetchClipPlanesRef();M&&(y++,this._clipNodeProxy.captureChild(M))}return y>0}announceClippedSegmentIntervals(y,k,M,b,E){return this.ensureProxyClipNode(),!!this._clipNodeProxy&&this._clipNodeProxy.announceClippedSegmentIntervals(y,k,M,b,E)}announceClippedArcIntervals(y,k){return this.ensureProxyClipNode(),!!this._clipNodeProxy&&this._clipNodeProxy.announceClippedArcIntervals(y,k)}appendPolygonClip(y,k,M,b){this.ensureProxyClipNode(),this._clipNodeProxy&&this._clipNodeProxy.appendPolygonClip(y,k,M,b)}transformInPlace(y){for(const k of this._clips)if(!1===k.transformInPlace(y))return!1;return this.boundingRange.isNull||y.multiplyRange(this.boundingRange,this.boundingRange),!0}extractBoundaryLoops(y,k){let M=so.None,b=-Number.MAX_VALUE,E=Number.MAX_VALUE;const D=[];let R,X=0;if(0===this._clips.length)return D;const z=pt.createIdentity();for(const N of this._clips)if(N instanceof Fs){if(void 0!==R&&N!==R){let y=pt.createIdentity(),k=pt.createIdentity();R.transformValid&&N.transformValid&&(y=N.transformFromClip.clone(),k=R.transformToClip.clone()),z.setFrom(k.multiplyTransformTransform(y))}if(R||(R=N),y[X]=[],void 0!==N.polygon){M=so.XAndY,N.zHighValid&&(M|=so.ZHigh,E=N.zHigh),N.zLowValid&&(M|=so.ZLow,b=N.zLow);for(const k of N.polygon)y[X].push(k.clone());z.multiplyPoint3dArray(y[X],y[X]),X++}}return D.push(M),D.push(b),D.push(E),k&&R&&k.setFrom(R.transformFromClip),D}setInvisible(y){for(const k of this._clips)k.setInvisible(y)}parseClipPlanes(){for(const y of this._clips)y.fetchClipPlanesRef()}multiplyPlanesByMatrix4d(y,k=!0,M=!0){if(k){const k=y.createInverse();return!!k&&this.multiplyPlanesByMatrix4d(k,!1,M)}for(const b of this._clips)b.multiplyPlanesByMatrix4d(y,!1,M);return!0}classifyPointContainment(y,k=!1){let M=ro.Ambiguous;for(const b of this._clips){const E=b.classifyPointContainment(y,k);if(ro.Ambiguous===E)return ro.Ambiguous;if(ro.Ambiguous===M)M=E;else if(M!==E)return ro.Ambiguous}return M}classifyRangeContainment(y,k){const M=y.corners();return this.classifyPointContainment(M,k)}isAnyLineStringPointInside(y){for(const k of this._clips){const M=k.fetchClipPlanesRef();if(void 0!==M)for(let k=0;k+1<y.length;k++){const b=Ce.create(y[k],y[k+1]);if(M.isAnyPointInOrOnFromSegment(b))return!0}}return!1}sumSizes(y,k,M){let b=0;for(let E=k;E<M;E++)b+=y[E].x1-y[E].x0;return b}isLineStringCompletelyContained(y){const k=[];for(let M=0;M+1<y.length;M++){const b=Ce.create(y[M],y[M+1]);let E=0,D=0;for(const y of this._clips){const M=y.fetchClipPlanesRef();if(void 0!==M){M.appendIntervalsFromSegment(b,k);const y=k.length;if(E+=this.sumSizes(k,D,y),D=y,E>=bs._TARGET_FRACTION_SUM)break}}if(E<bs._TARGET_FRACTION_SUM)return!1}return!0}toCompactString(){function t(y){return`${y.toString()}_`}function i(y){let k=y.invisible?1:0;return k|=y.interior?2:0,`${function(y){const k=y.toString();return e(k.length),k}(k)}${M=y.inwardNormalRef,`${t(M.x)}${t(M.y)}${t(M.z)}`}${t(y.distance)}`;var M}function s(y){let k="";for(const M of y.planes)k=`${k}${i(M)}`;return`${k}_`}function n(y){let k=(y.invisible?1:0).toString();e(k.length);const M=y.fetchClipPlanesRef();if(M)for(const b of M.convexSets)k=`${k}${s(b)}`;return`${k}_`}let y="";for(const k of this.clips)y=`${y}${n(k)}`;return`${y}_`}}bs._TARGET_FRACTION_SUM=.99999999,function(y){y.fromClipVector=function(y){if(!y||!y.isValid)return;const k=y;void 0===k.clipString&&(k.clipString=y.toCompactString());const M=k;return e(M.clipString),M}}(no||(no={}));class Es{constructor(y,k){this._positiveOffsetLeft=y,this._positiveOffsetRight=k,this._turnDegrees=60}static createUnit(y,k,M,b=!0){let E=k,D=k+1;const R=y.length-1;M?k<0?(E=R-1,D=R):k>=R&&(E=0,D=1):0===k?(E=0,D=1):D>R&&(E=R-1,D=R);const X=y.vectorIndexIndex(E,D);if(X)return b&&(X.z=0),X.normalize(X)}static createDirectedPlane(y,k,M,b,E=!1){return Wr.createNormalAndPointXYZXYZ(k.x*b,k.y*b,k.z*b,y.x+M*k.x,y.y+M*k.y,y.z+M*k.z,E,E)}createChamferCut(y,k,M,b){const E=M.angleToXY(b).degrees;if(Math.abs(E)>this._turnDegrees){const D=M.interpolate(.5,b);D.rotate90CCWXY(D),D.normalizeInPlace(),E>0?y.addPlaneToConvexSet(Es.createDirectedPlane(k,D,-this._positiveOffsetRight,1,!1)):y.addPlaneToConvexSet(Es.createDirectedPlane(k,D,this._positiveOffsetLeft,-1,!1))}}createOffsetFromSegment(y,k,M,b,E){if(void 0===b)return;void 0===M&&(M=b),void 0===E&&(E=b);const D=M.interpolate(.5,b);D.normalizeInPlace();const R=b.rotate90CCWXY(),X=b.interpolate(.5,E);X.normalizeInPlace();const z=kn.createEmpty();return z.addPlaneToConvexSet(Es.createDirectedPlane(y,R,this._positiveOffsetLeft,-1,!1)),z.addPlaneToConvexSet(Es.createDirectedPlane(y,R,-this._positiveOffsetRight,1,!1)),z.addPlaneToConvexSet(Es.createDirectedPlane(y,D,0,1,!0)),z.addPlaneToConvexSet(Es.createDirectedPlane(k,X,0,-1,!0)),this.createChamferCut(z,y,M,b),this.createChamferCut(z,k,b,E),z}static createClipBetweenOffsets(y,k,M,b,E){const D=new Es(k,M),R=vs.createEmpty();if(y.length>1){const k=Q.isSmallMetricDistance(y.distanceIndexIndex(0,y.length-1));for(let M=0;M+1<y.length;M++){const X=this.createUnit(y,M-1,k),z=this.createUnit(y,M,k),N=this.createUnit(y,M+1,k),Y=D.createOffsetFromSegment(y.getPoint3dAtUncheckedPointIndex(M),y.getPoint3dAtUncheckedPointIndex(M+1),X,z,N);Y?.addZClipPlanes(!1,b,E),Y&&R.addConvexSet(Y)}}else{const y=kn.createEmpty();y?.addZClipPlanes(!1,b,E),y.planes.length>0&&R.addConvexSet(y)}return R}}!function(y){y[y.StronglyInside=1]="StronglyInside",y[y.Ambiguous=2]="Ambiguous",y[y.StronglyOutside=3]="StronglyOutside"}(ro||(ro={})),(Eo=oo||(oo={}))[Eo.acceptIn=1]="acceptIn",Eo[Eo.acceptOut=-1]="acceptOut",Eo[Eo.passToNextStep=0]="passToNextStep",function(y){y[y.ClipRequired=0]="ClipRequired",y[y.TrivialReject=1]="TrivialReject",y[y.TrivialAccept=2]="TrivialAccept"}(ao||(ao={}));class Rs{static selectIntervals01(y,k,M,b){k.push(0),k.push(1),k.sort();let E,D,R=k.atUncheckedIndex(0);const X=Rs._selectIntervals01TestPoint,z=k.length;for(let N=1;N<z;N++)if(E=k.atUncheckedIndex(N),E>R+Q.smallFraction){if(D=.5*(R+E),D>=0&&D<=1&&(y.fractionToPoint(D,X),M.isPointOnOrInside(X))){if(!b)return!0;b(R,E,y)}R=E}return!1}static announceNNC(y,k,M){if(M)for(const b of y)M(b.low,b.high,k);return y.length>0}static collectClippedCurves(y,k){const M=[];return y.announceClipIntervals(k,((y,k,b)=>{if(k!==y){const E=b.clonePartialCurve(y,k);E&&M.push(E)}})),M}static clipAnyRegion(y,k){let M;const b=Rs._workTransform=Fi.createRightHandedFrame(void 0,y,Rs._workTransform);if(!b)return M;const E=b?.inverse();if(!E)return M;const D=y.cloneTransformed(E);if(!D)return M;const R=Rs._workRange=D.range(),X=R.xLength(),z=R.yLength(),N=Me.createRectangleXY(R.low,X,z,!0);N.tryTransformInPlace(b);const Y=[],O=new ys;if(k.appendPolygonClip?.(N.packedPoints,Y,[],O),0===Y.length)return M;for(const B of Y){const y=hi.createPolygon(B);y.tryTransformInPlace(E);const k=Er.regionBooleanXY(D,y,ko.Intersection);k&&(k.tryTransformInPlace(b),M?M.tryAddChild(k)||M.children.push(...k.children):M=k instanceof xs?k:xs.create(k))}return M}static clipAnyCurve(y,k){if(y instanceof ae)return Rs.collectClippedCurves(y,k);if(y.isAnyRegion()){const M=Rs.clipAnyRegion(y,k);return M?[M]:[]}const M=[];if(y instanceof oi||y instanceof ri)for(const b of y.children){const y=Rs.clipAnyCurve(b,k);M.push(...y)}return M}static clipPolygonToClipShape(y,k){const M=this.clipPolygonToClipShapeReturnGrowableXYZArrays(y,k),b=[];for(const E of M)b.push(E.getPoint3dArray());return b}static clipPolygonToClipShapeReturnGrowableXYZArrays(y,k){const M=[],b=k.fetchClipPlanesRef();return b&&b.polygonClip(y,M),M}static pointSetSingleClipStatus(y,k,M){if(0===k.convexSets.length)return ao.TrivialAccept;for(const b of k.convexSets){let k=!1,E=!1;for(const D of b.planes){let b=0,R=0;const X=D.distance-M,z=j.create(),N=$.create();for(let k=0;k<y.length;k++)y.getPoint3dAtUncheckedPointIndex(k,z),N.setFrom(z),N.dotProduct(D.inwardNormalRef)>X?b++:R++;if(E=0!==R||E,0===b){k=!0;break}}if(!E)return ao.TrivialAccept;if(!k)return ao.ClipRequired}return ao.TrivialReject}static announceLoopsOfConvexClipPlaneSetIntersectRange(y,k,M,b=!0,E=!0,D=!1){const R=new nt;if(b)if(y instanceof kn)for(const X of y.planes){if(D&&X.invisible)continue;const b=X.intersectRange(k,!0),E=new nt;b&&(y.polygonClip(b,E,R,X),E.length>0&&M(E))}else if(D&&y.invisible);else{const b=y.intersectRange(k,!0);b&&M(b)}if(E){const b=k.corners();for(let k=0;k<6;k++){const E=ut.faceCornerIndices(k),D=new nt,X=Me.createIndexedPoints(b,E);y instanceof kn?(y.polygonClip(X.packedPoints,D,R),D.length>0&&M(D)):(y.clipConvexPolygonInPlace(X.packedPoints,R),X.packedPoints.length>0&&M(X.packedPoints))}}}static loopsOfConvexClipPlaneIntersectionWithRange(y,k,M=!0,b=!0,E=!1){const D=[];if(y instanceof vs)for(const R of y.convexSets)this.announceLoopsOfConvexClipPlaneSetIntersectRange(R,k,(y=>{y.length>0&&D.push(hi.createPolygon(y))}),M,b,E);else(y instanceof kn||y instanceof Wr)&&this.announceLoopsOfConvexClipPlaneSetIntersectRange(y,k,(y=>{y.length>0&&D.push(hi.createPolygon(y))}),M,b,E);return D}static rangeOfConvexClipPlaneSetIntersectionWithRange(y,k){const M=ut.createNull();return this.announceLoopsOfConvexClipPlaneSetIntersectRange(y,k,(y=>{y.length>0&&M.extendArray(y)}),!0,!0,!1),M}static rangeOfClipperIntersectionWithRange(y,k,M=!0){if(void 0===y)return k.clone();if(y instanceof kn)return this.rangeOfConvexClipPlaneSetIntersectionWithRange(y,k);if(y instanceof vs){const M=ut.createNull();for(const b of y.convexSets){const y=this.rangeOfConvexClipPlaneSetIntersectionWithRange(b,k);M.extendRange(y)}return M}if(y instanceof Cs)return M&&y.invisible?k.clone():this.rangeOfClipperIntersectionWithRange(y.fetchClipPlanesRef(),k);if(y instanceof bs){const b=k.clone();for(const E of y.clips)if(M&&E.invisible);else{const y=this.rangeOfClipperIntersectionWithRange(E,k,M);b.intersect(y,b)}return b}return k.clone()}static doesClipperIntersectRange(y,k,M=!0){if(void 0===y)return!0;if(y instanceof kn)return this.doesConvexClipPlaneSetIntersectRange(y,k);if(y instanceof vs){for(const M of y.convexSets)if(this.doesConvexClipPlaneSetIntersectRange(M,k))return!0;return!1}if(y instanceof Cs)return!(!M||!y.invisible)||this.doesClipperIntersectRange(y.fetchClipPlanesRef(),k);if(y instanceof bs){const b=k.clone();for(const E of y.clips)if(M&&E.invisible);else{const y=this.rangeOfClipperIntersectionWithRange(E,k,M);b.intersect(y,b)}return!b.isNull}return!1}static doesConvexClipPlaneSetIntersectRange(y,k,M=!0,b=!0,E=!1){const D=new nt;if(M)for(const R of y.planes){if(E&&R.invisible)continue;const M=R.intersectRange(k,!0);if(M){const k=new nt;if(y.polygonClip(M,k,D,R),k.length>0)return!0}}if(b){const M=k.corners();for(let k=0;k<6;k++){const b=ut.faceCornerIndices(k),E=new nt,R=Me.createIndexedPoints(M,b);if(y.polygonClip(R.packedPoints,E,D),E.length>0)return!0}}return!1}static createClipperFromTransformedRange3d(y,k,M){k||(k=pt.createIdentity());const b=ar.create();b.addTransformedRangeMesh(k,y);const E=b.claimPolyface(),D=this._workClipper=kn.createConvexPolyface(E,this._workClipper).clipper;if(D.planes.length>0)return D;if(M){e(E.data.point.length);for(let y=0;y<2;++y){const k=E.data.point.getPoint3dAtCheckedPointIndex(y);k&&M.push(k)}}}static rangeIntersectPointOrSegment(y,k,M,b){const E=b?(y,k,E)=>{b.extendPoint(E.fractionToPoint(y),M),b.extendPoint(E.fractionToPoint(k),M)}:void 0;let D=!1;if(k.length>1){const M=Ce.createCapture(k[0],k[1]),b=kn.createRange3dPlanes(y);D=M.announceClipIntervals(b,E)}else k.length>0&&(D=y.containsPoint(k[0]),D&&b&&b.extendPoint(k[0],M));return D}static doLocalRangesIntersect(y,k,M,b,E){const D=this._workTransform=b.inverse(this._workTransform);if(!D)return!1;let R=M;E&&(R=this._workRange=M.clone(this._workRange),R.expandInPlace(E));const X=[],z=D.multiplyTransformTransform(k,D),N=this.createClipperFromTransformedRange3d(y,z,X);return N?this.doesClipperIntersectRange(N,R):this.rangeIntersectPointOrSegment(R,X,b)}static rangeOfIntersectionOfLocalRanges(y,k,M,b,E){const D=ut.createNull(E),R=this._workTransform=b.inverse(this._workTransform);if(!R)return D;const X=[],z=R.multiplyTransformTransform(k,R),N=this.createClipperFromTransformedRange3d(y,z,X);return N?this.announceLoopsOfConvexClipPlaneSetIntersectRange(N,M,(y=>{y.extendRange(D,b)})):this.rangeIntersectPointOrSegment(M,X,b,D),D}static isClipper(y){return!!(y&&y.isPointOnOrInside&&y.announceClippedSegmentIntervals&&y.announceClippedArcIntervals)}static restoreSingletonInPlaceOfMultipleShards(y,k,M,b){if(y&&y.length>k+1){for(;y.length>k;){const k=y.pop();b.dropToCache(k)}y.push(b.grabAndFill(M))}}static createXYOffsetClipFromLineString(y,k,M,b,E){return Array.isArray(y)?Es.createClipBetweenOffsets(new ce(y),k,M,b,E):Es.createClipBetweenOffsets(y,k,M,b,E)}static captureOrDrop(y,k,M,b){y.length>=k?M.push(y):b.dropToCache(y)}static clipSegmentToLLeftOfLineXY(y,k,M,b,E,D=1e-14){const R=k.x-y.x,X=k.y-y.y,z=-(R*(M.y-y.y)-X*(M.x-y.x)),N=-(R*(b.y-y.y)-X*(b.x-y.x));if(!(z<D&&N<D))if(z*N>0)z>0&&E.setNull();else{if(z*N<0){const y=-z/(N-z);return z<0?E.intersectRangeXXInPlace(0,y):E.intersectRangeXXInPlace(y,1)}z>0?E.intersectRangeXXInPlace(1,1):N>0&&E.intersectRangeXXInPlace(0,0)}}static clipSegmentToCCWTriangleXY(y,k,M,b,E,D,R=1e-14){D.isNull||(this.clipSegmentToLLeftOfLineXY(y,k,b,E,D,R),D.isNull||(this.clipSegmentToLLeftOfLineXY(k,M,b,E,D,R),D.isNull||this.clipSegmentToLLeftOfLineXY(M,y,b,E,D,R)))}static clipSegmentBelowPlaneXY(y,k,M,b,E=1e-14){const D=y.altitudeXY(k.x,k.y),R=y.altitudeXY(M.x,M.y);if(!(D<E&&R<E))if(D*R>0)D>0&&b.setNull();else{if(D*R<0){const y=-D/(R-D);return D<0?b.intersectRangeXXInPlace(0,y):b.intersectRangeXXInPlace(y,1)}D>0?b.intersectRangeXXInPlace(1,1):R>0&&b.intersectRangeXXInPlace(0,0)}}static clipSegmentBelowPlanesXY(y,k,M,b,E=1e-14){const D=y.length;for(let R=0;!b.isNull&&R<D;R++)this.clipSegmentBelowPlaneXY(y[R],k,M,b,E)}static announcePolylineClip(y,k,M){for(let b=0;b+1<k.length;b++)y.announceClippedSegmentIntervals(0,1,k[b],k[b+1],((y,E)=>{M(k[b].interpolate(y,k[b+1]),k[b].interpolate(E,k[b+1]))}))}static sumPolylineClipLength(y,k){let M=0;for(let b=0;b+1<k.length;b++){const E=k[b].distance(k[b+1]);y.announceClippedSegmentIntervals(0,1,k[b],k[b+1],((y,k)=>{M+=Math.abs(k-y)*E}))}return M}static doPolygonClipSequence(y,k,M,b,E,D,R,X,z){void 0===z&&(z=new ys);let N=[z.grabAndFill(y)],Y=[];const O=[],B=[],V=M?M.length:0,U=b?b.length:0;let L;for(const Z of k)if(Z.appendPolygonClip){for(;void 0!==(L=N.pop());)Z.appendPolygonClip(L,O,B,z),Xs(D,O,M,b,Y,z),Xs(R,B,M,b,Y,z),z.dropToCache(L);const y=N;N=Y,Y=y}Xs(X,N,M,b,E,z),b?.length===U&&Rs.restoreSingletonInPlaceOfMultipleShards(M,V,y,z),M?.length===V&&Rs.restoreSingletonInPlaceOfMultipleShards(b,U,y,z)}static doPolygonClipParitySequence(y,k,M,b,E){void 0===E&&(E=new ys);let D=[E.grabAndFill(y)],R=[],X=[],z=[];const N=[],Y=[];let O;for(const B of k)if(B.appendPolygonClip){for(;void 0!==(O=R.pop());)B.appendPolygonClip(O,N,Y,E),Xs(oo.acceptOut,N,X,z,void 0,E),Xs(oo.acceptIn,Y,X,z,void 0,E),E.dropToCache(O);for(;void 0!==(O=D.pop());)B.appendPolygonClip(O,N,Y,E),Xs(oo.acceptIn,N,X,z,void 0,E),Xs(oo.acceptOut,Y,X,z,void 0,E),E.dropToCache(O);const y=R;R=X,X=y;const k=D;D=z,z=k}0===D.length?M?.push(E.grabAndFill(y)):0===D.length?b?.push(E.grabAndFill(y)):(Ds(R,M,E),Ds(D,b,E))}static createComplementaryClips(y){const k=y.planes,M=ft.createNull(),b=k.length,E=[];for(const D of k){const y=kn.createEmpty();y.addPlaneToConvexSet(D.cloneNegated()),E.push(y)}for(let D=0;D<b;D++)for(let R=D+1;R<b;R++){const b=Ln.planePlaneIntersectionRay(k[D],k[R]);if(b&&y.hasIntersectionWithRay(b,M)){const y=k[R].inwardNormalRef.minus(k[D].inwardNormalRef),M=Wr.createNormalAndPoint(y,b.origin);if(M){const y=M.cloneNegated();E[D].addPlaneToConvexSet(M),E[R].addPlaneToConvexSet(y)}}}return vs.createConvexSets(E)}}function Ds(y,k,M){if(void 0===k)M.dropAllToCache(y);else for(const b of y)k.push(b);y.length=0}function Xs(y,k,M,b,E,D){let R;if(y===oo.acceptIn?R=M:y===oo.acceptOut?R=b:y===oo.passToNextStep&&(R=E),void 0===R)D.dropAllToCache(k);else for(const X of k)R.push(X);k.length=0}Rs._selectIntervals01TestPoint=j.create();class zs{constructor(y,k){this._graph=y,this._candidates=[],this._mask=k,this._graph.clearMask(k)}clear(){for(;void 0!==this.chooseAndRemoveAny(););}getLength(){let y=0;for(const k of this._candidates)k.isMaskSet(this._mask)&&y++;return y}getNumCandidates(){return this._candidates.length}get graph(){return this._graph}teardown(){this._graph.dropMask(this._mask),this._candidates.length=0}get mask(){return this._mask}popAndReturn(){const y=this._candidates.length;if(0===y)return;const k=this._candidates[y-1];return this._candidates.pop(),k}getAtIndex(y){if(y>=0&&y<this._candidates.length){const k=this._candidates[y];if(k.isMaskSet(this._mask))return k}}addToSet(y){return!y.isMaskSet(this._mask)&&(this._candidates.push(y),this.setMaskInScope(y),!0)}isCandidateInSet(y){return y.isMaskSet(this._mask)}removeFromSet(y){return!!y.isMaskSet(this._mask)&&(this.clearMaskInScope(y),!0)}chooseAndRemoveAny(){for(;;){const y=this.popAndReturn();if(!y)return;if(this.removeFromSet(y))return y}}[Symbol.iterator](){return new Os(this)}addAroundFace(y){let k=y;do{this.addToSet(k),k=k.faceSuccessor}while(k!==y)}addAroundVertex(y){let k=y;do{this.addToSet(k),k=k.vertexSuccessor}while(k!==y)}}class Ns extends zs{constructor(y,k){super(y,k)}static create(y){const k=y.grabMask();if(k!==Kr.NULL_MASK)return new Ns(y,k)}setMaskInScope(y){y.setMaskAroundEdge(this._mask)}clearMaskInScope(y){y.clearMaskAroundEdge(this._mask)}countHalfEdgesAroundCandidate(y){return y?2:0}}class Os{constructor(y){this._markSet=y,this._nextReadIndex=0}next(){const y=this._markSet.getNumCandidates();for(;this._nextReadIndex<y;){const y=this._markSet.getAtIndex(this._nextReadIndex++);if(void 0!==y)return{done:!1,value:y}}return{done:!0,value:void 0}}[Symbol.iterator](){return this}}class Ys{constructor(y,k,M,b,E,D){this._x=k,this._y=M,this._z=b,this._u=E,this._v=D,this._node=y}set(y,k,M,b,E,D){return this._x=k,this._y=M,this._z=b,this._u=E,this._v=D,this._node=y,this}setFrom(y){this._x=y.x,this._y=y.y,this._z=y.z,this._u=y.u,this._v=y.v,this._node=y.node}static createNodeAndRayOrigin(y,k,M){const b=y.x,E=y.y,D=y.z,R=b-k.origin.x,X=E-k.origin.y,z=Q.dotProductXYXY(R,X,k.direction.x,k.direction.y),N=Q.crossProductXYXY(k.direction.x,k.direction.y,R,X);return M?M.set(y,b,E,D,z,N):new Ys(y,b,E,D,z,N)}static create(y,k=0,M=0,b=0,E=0,D=0){return new Ys(y,k,M,b,E,D)}get node(){return this._node}get x(){return this._x}get y(){return this._y}get z(){return this._z}get u(){return this._u}get v(){return this._v}getXYZAsPoint3d(y){return j.create(this._x,this._y,this._z,y)}getUVAsPoint2d(y){return H.create(this._u,this._v,y)}classifyU(y,k){const M=this.u-y;return Math.abs(M)<=k?0:M>=0?1:-1}classifyV(y,k){const M=y-this._v;return Math.abs(M)<=k?0:M>=0?1:-1}}!function(y){y[y.None=0]="None",y[y.Vertex=1]="Vertex",y[y.Edge=2]="Edge",y[y.Face=3]="Face",y[y.ExteriorFace=4]="ExteriorFace"}(co||(co={}));class Bs{constructor(y,k,M,b,E,D,R,X,z){this._node=y,this.x=k,this.y=M,this.z=b,this._topo=E,this._edgeFraction=D,this._iTag=R,this._dTag=X,this._isExteriorTarget=z}setFrom(y){this._node=y._node,this.x=y.x,this.y=y.y,this.z=y.z,this._topo=y._topo,this._edgeFraction=y._edgeFraction,this._iTag=y._iTag,this._dTag=y._dTag}resetAsUnknown(){this._node=void 0,this._topo=co.None}static create(){return new Bs(void 0,0,0,0,co.None)}getITag(){return this._iTag}setITag(y){this._iTag=y}getDTag(){return this._dTag}setDTag(y){this._dTag=y}getTopo(){return this._topo}static createEdgeAtFraction(y,k){const M=y.faceSuccessor,b=Q.interpolate(y.x,k,M.x),E=Q.interpolate(y.y,k,M.y),D=Q.interpolate(y.z,k,M.z);return new Bs(y,b,E,D,co.Edge,k)}resetAsFace(y,k){return this._topo=co.Face,y&&(this._node=y),k&&(this.x=k.x,this.y=k.y,this.z=k.z),this._isExteriorTarget=void 0,this}resetAsUndefinedWithTag(y){return this._topo=co.None,this._dTag=0,this._iTag=0,this._dTag=y,this._node=void 0,this._isExteriorTarget=void 0,this}resetAtEdgeAndFraction(y,k){this._topo=co.Edge,this._node=y;const M=y.faceSuccessor;return this._edgeFraction=k,this.x=Q.interpolate(y.x,k,M.x),this.y=Q.interpolate(y.y,k,M.y),this.z=Q.interpolate(y.z,k,M.z),this._isExteriorTarget=void 0,this}static createVertex(y){return new Bs(y,y.x,y.y,y.z,co.Vertex)}resetAsVertex(y){return this._topo=co.Vertex,this._node=y,this._edgeFraction=0,this.setXYZFromNode(y),this._isExteriorTarget=void 0,this}setIsExteriorTarget(y){this._isExteriorTarget=y}setXYZFromNode(y){this.x=y.x,this.y=y.y,this.z=y.z}get edgeFraction(){return this._edgeFraction}get isExteriorTarget(){return void 0!==this._isExteriorTarget&&this._isExteriorTarget}get isFace(){return this._topo===co.Face}get isEdge(){return this._topo===co.Edge}get isVertex(){return this._topo===co.Vertex}get isUnclassified(){return this._topo===co.None}get node(){return this._node}clonePoint(y){return j.create(this.x,this.y,this.z,y)}isAtXY(y,k){return this._topo!==co.None&&Q.isSameCoordinate(this.x,y)&&Q.isSameCoordinate(this.y,k)}}!function(y){y[y.NoHits=0]="NoHits",y[y.TargetOnVertex=1]="TargetOnVertex",y[y.TargetOnEdge=2]="TargetOnEdge",y[y.Bracket=3]="Bracket",y[y.TargetBefore=4]="TargetBefore",y[y.TargetAfter=5]="TargetAfter"}(uo||(uo={}));class Vs{constructor(y){this._tol=y}static create(y=Q.smallMetricDistance){return new Vs(y)}panic(){return Bs.create()}reAimFromEdge(y,k,M){const b=y.node,E=Ys.createNodeAndRayOrigin(b,k),D=Ys.createNodeAndRayOrigin(b.edgeMate,k),R=-E.classifyV(0,this._tol),X=-D.classifyV(0,this._tol);let z;if(R*X<0)z=R>0?y.resetAsFace(E.node):y.resetAsFace(D.node);else if(0===R||0===X){const k=E.classifyU(M,this._tol),b=D.classifyU(M,this._tol);if(0===R&&0===k)z=y.resetAsVertex(E.node),z.setITag(1);else if(0===X&&0===b)z=y.resetAsVertex(D.node),z.setITag(1);else if(0===R&&0===X)if(k*b<0){const k=(M-E.u)/(D.u-E.u);z=y.resetAtEdgeAndFraction(E.node,k),z.setITag(1)}else k<0&&b<0?z=E.u>D.u?y.resetAsVertex(E.node):y.resetAsVertex(D.node):(y.resetAsUnknown(),z=this.panic());else 0===R?z=0===E.classifyU(0,this._tol)?y.resetAsVertex(E.node):y.resetAsFace(X>0?D.node:E.node):(e(),z=0===D.classifyU(0,this._tol)?y.resetAsVertex(D.node):y.resetAsFace(R>0?E.node:D.node))}else y.resetAsUnknown(),z=this.panic();return z}reAimFromVertex(y,k,M){e(k.origin.isExactEqual(y));const b=y.node;let E=b;const o=k=>{if(Math.abs(k-M)<=this._tol)y.resetAsVertex(E.faceSuccessor).setITag(1);else if(k>M)y.resetAtEdgeAndFraction(E,M/k);else{if(!(k>this._tol))return!1;y.resetAsVertex(E.faceSuccessor)}return!0};do{const M=Ys.createNodeAndRayOrigin(E.faceSuccessor,k),b=Ys.createNodeAndRayOrigin(E.facePredecessor,k),D=M.u,R=b.u,X=M.v,z=b.v;if(Math.abs(X)<=this._tol){if(o(D))return y;if(Math.abs(D)<=this._tol&&X<=0&&z>this._tol&&(D>=0||D<0&&R>this._tol))return y.resetAsFace(E,E)}else if(X<-this._tol){if(z>this._tol)return y.resetAsFace(E,E);if(z>=-this._tol)if(Math.abs(R)<=this._tol){if(z>0&&(R>=0||D>this._tol&&R<0))return y.resetAsFace(E,E)}else if(D>this._tol&&R<0)return y.resetAsVertex(E.faceSuccessor)}E=E.vertexSuccessor}while(E!==b);return this.panic()}reAimAroundFace(y,k,M,b,E){e(y.isMaskSet(Kr.EXTERIOR)),b.resetAsUndefinedWithTag(-Number.MAX_VALUE),E.resetAsUndefinedWithTag(Number.MAX_VALUE);const D=Ys.createNodeAndRayOrigin(y,k);let R,X=y;do{const y=X.faceSuccessor;R=Ys.createNodeAndRayOrigin(y,k,R);const z=D.u,N=R.u,Y=D.v,O=R.v;if(Math.abs(O)<this._tol){const k=Bs.createVertex(y);if(k.setDTag(N),Math.abs(N-M)<this._tol)return E.setFrom(k),b.setFrom(k),uo.TargetOnVertex;N>M&&N<E.getDTag()&&E.setFrom(k),N<M&&N>b.getDTag()&&b.setFrom(k)}else if(Y*O<0){const y=-Y/(O-Y),k=Q.interpolate(z,y,N),R=Bs.createEdgeAtFraction(D.node,y);if(R.setDTag(k),Math.abs(k-M)<=this._tol)return E.setFrom(R),b.setFrom(R),uo.TargetOnEdge;k>M&&k<E.getDTag()&&E.setFrom(R),k<M&&k>b.getDTag()&&b.setFrom(R)}D.setFrom(R),X=X.faceSuccessor}while(X!==y);return E.setITag(0),b.setITag(0),b.isUnclassified?E.isUnclassified?uo.NoHits:uo.TargetBefore:E.isUnclassified?uo.TargetAfter:uo.Bracket}setSearchRay(y,k,M){M.origin.setFromPoint3d(y),$.createStartEnd(M.origin,k,M.direction),M.direction.z=0;const b=M.direction.magnitudeXY();return!(b<this._tol||(M.a=b,M.direction.scaleInPlace(1/b),0))}}!function(y){y[y.Ignore=0]="Ignore",y[y.Replace=1]="Replace",y[y.ReplaceIfLarger=2]="ReplaceIfLarger",y[y.ReplaceIfSmaller=3]="ReplaceIfSmaller"}(po||(po={}));class Ls{constructor(y,k){this._graph=y,this._edgeSet=Ns.create(y),this._searcher=Bs.create(),this._tolerance=k}static create(y,k=Q.smallMetricDistance){return new Ls(y,k)}get graph(){return this._graph}retriangulateFromBaseVertex(y){const k=y.countEdgesAroundFace();if(k<4||y.isMaskSet(Kr.EXTERIOR))return;this._edgeSet.addAroundFace(y);const M=k-3;let b=y.faceSuccessor,E=y;for(let D=0;D<M;D++)b=b.faceSuccessor,E=this._graph.createEdgeHalfEdgeHalfEdge(E,0,b,0),b=E.faceSuccessor,this._edgeSet.addToSet(E)}reset(){this._searcher=Bs.create()}get currentPosition(){return this._searcher}searchForNearestEdgeOrVertex(y){const k=Bs.create();k.setDTag(Number.MAX_VALUE);const M=j.create();let b,E;for(const D of this._graph.allHalfEdges){const R=D.faceSuccessor;b=Mt.lineSegment3dXYClosestPointUnbounded(D,R,y),void 0!==b&&(b>1?(E=y.distanceXY(R),E<k.getDTag()&&(k.resetAsVertex(R),k.setDTag(E))):b<0?(E=y.distanceXY(D),E<k.getDTag()&&(k.resetAsVertex(D),k.setDTag(E))):(D.fractionToPoint3d(b,M),E=y.distanceXY(M),E<k.getDTag()&&k.resetAtEdgeAndFraction(D,b)))}return k}searchForNearestVertex(y){const k=Bs.create();let M;k.setDTag(Number.MAX_VALUE);for(const b of this._graph.allHalfEdges)M=y.distanceXY(b),M<k.getDTag()&&(k.resetAsVertex(b),k.setDTag(M));return k}resetSearch(y,k){this._searcher=k?this.searchForNearestEdgeOrVertex(y):this.searchForNearestVertex(y)}reclassifyFaceHit(y){if(void 0===this._searcher.node||!this._searcher.isFace||this._searcher.node.isMaskSet(Kr.EXTERIOR))return!1;const k=j.create(y.x,y.y),M=this._searcher.node.collectAroundFace((y=>{const k=j.create(y.x,y.y);return k.node=y,k})),b=Ur.closestPointOnBoundary(M,k,this._tolerance);if(e((b.code,z.OnPolygonEdgeInterior)),b.a>this._tolerance)return!1;const E=M[b.closestEdgeIndex].node,D=b.closestEdgeParam<.5?E:E.faceSuccessor;return b.point.distanceSquaredXY(D)<=this._tolerance*this._tolerance?this._searcher.resetAsVertex(D):this._searcher.resetAtEdgeAndFraction(E,b.closestEdgeParam),!0}reclassifyEdgeHit(y){if(void 0===this._searcher.node||!this._searcher.isEdge||this._searcher.node.isMaskSet(Kr.BOUNDARY_EDGE))return!1;const k=j.create(y.x,y.y),M=[];for(let R=this._searcher.node.faceSuccessor;R!==this._searcher.node;R=R.faceSuccessor){const y=j.create(R.x,R.y);y.node=R,M.push(y)}for(let R=this._searcher.node.vertexPredecessor;R!==this._searcher.node.edgeMate;R=R.faceSuccessor){const y=j.create(R.x,R.y);y.node=R,M.push(y)}const b=Ur.closestPointOnBoundary(M,k,this._tolerance);if(b.a>this._tolerance)return!1;const E=M[b.closestEdgeIndex].node,D=b.closestEdgeParam<.5?E:E.faceSuccessor;return b.code===z.OnPolygonVertex||b.point.distanceSquaredXY(D)<=this._tolerance*this._tolerance?this._searcher.resetAsVertex(D):this._searcher.resetAtEdgeAndFraction(E,b.closestEdgeParam),!0}updateZAroundVertex(y,k,M){po.Ignore!==M&&(po.ReplaceIfLarger===M&&k.z<=y.z||po.ReplaceIfSmaller===M&&k.z>=y.z||y.setXYZAroundVertex(y.x,y.y,k.z))}insertAndRetriangulate(y,k){if(this.moveToPoint(this._searcher,y),void 0===this._searcher.node)return!1;if(this.reclassifyFaceHit(y)||this.reclassifyEdgeHit(y),this._searcher.isFace){if(!this._searcher.node.isMaskSet(Kr.EXTERIOR)){const k=this._graph.createEdgeXYZHalfEdge(y.x,y.y,y.z,0,this._searcher.node,0);this.retriangulateFromBaseVertex(k),Us.flipTrianglesInEdgeSet(this._graph,this._edgeSet),this._searcher.resetAsVertex(k)}}else if(this._searcher.isEdge){const k=this._graph.splitEdgeAtFraction(this._searcher.node,this._searcher.edgeFraction),M=k.vertexPredecessor;this.updateZAroundVertex(k,y,po.Replace),this.retriangulateFromBaseVertex(k),this.retriangulateFromBaseVertex(M),Us.flipTrianglesInEdgeSet(this._graph,this._edgeSet),this._searcher.resetAsVertex(k)}else this._searcher.isVertex&&this.updateZAroundVertex(this._searcher.node,y,k);return!0}moveToPoint(y,k,M){const b=Vs.create(this._tolerance);if(y.setITag(0),y.isUnclassified&&(function(y,k,M,b){for(const E of y.allHalfEdges)if(!E.isMaskSet(b))return k.resetAtEdgeAndFraction(E,.5),!0}(this.graph,y,0,Kr.NULL_MASK),y.isUnclassified))return!1;let E=0;const D=bt.createXAxis();for(;0===y.getITag()&&E<2&&(void 0===M||M(y));){if(!b.setSearchRay(y,k,D))return!1;if(y.isFace){const M=Bs.create(),R=Bs.create();switch(b.reAimAroundFace(y.node,D,D.a,M,R)){case uo.NoHits:y.resetAsUnknown();break;case uo.TargetOnVertex:case uo.TargetOnEdge:y.setFrom(M),y.setITag(1);break;case uo.Bracket:y.resetAsFace(M.node,k),y.setITag(1);break;case uo.TargetBefore:y.resetAsFace(y.node,k),y.setITag(1);break;case uo.TargetAfter:y.node===M.node&&y.isFace&&(M.isEdge||M.isVertex)?E++:E=0,y.setFrom(M)}}else if(y.isEdge){if(b.reAimFromEdge(y,D,D.a),y.isUnclassified)break}else if(y.isVertex&&(b.reAimFromVertex(y,D,D.a),y.isUnclassified))break}return!!y.isAtXY(k.x,k.y)||E>1&&(void 0!==y.node&&y.setIsExteriorTarget(!0),!1)}}class Us{static flipEdgeBetweenTriangles(y,k,M,b,E,D){us.pinch(y,E),us.pinch(M,b),us.pinch(D,M),us.pinch(E,k),E.x=k.x,E.y=k.y,E.z=k.z,E.i=k.i,M.i=D.i,M.x=D.x,M.y=D.y,M.z=D.z}static computeInCircleDeterminantIsStrongPositive(y){const k=y.faceSuccessor,M=k.faceSuccessor;if(M.faceSuccessor!==y)return!1;const b=y.edgeMate,E=b.faceSuccessor.faceSuccessor;if(E.faceSuccessor!==b)return!1;const D=k.x-y.x,R=k.y-y.y,X=M.x-y.x,z=M.y-y.y;if(Q.crossProductXYXY(D,R,X,z)<0)return!1;const N=E.x-y.x,Y=E.y-y.y,O=N*N+Y*Y,B=X*X+z*z,V=D*D+R*R,U=Q.tripleProduct(N,Y,O,X,z,B,D,R,V);return!(U<0)&&U>1e-12*(Math.abs(N*z*V)+Math.abs(Y*B*D)+Math.abs(O*X*R)+Math.abs(N*B*R)+Math.abs(Y*X*V)+Math.abs(O*z*D))}static flipTriangles(y){const k=Ns.create(y);for(const b of y.allHalfEdges)k.addToSet(b);const M=this.flipTrianglesInEdgeSet(y,k);return k.teardown(),M}static flipTrianglesInEdgeSet(y,k){const M=Kr.EXTERIOR|Kr.PRIMARY_EDGE|Kr.BOUNDARY_EDGE,b=10*y.allHalfEdges.length;let E,D=0,R=0;for(;void 0!==(E=k.chooseAndRemoveAny())&&(E.isMaskSet(M)||(Us.computeInCircleDeterminantIsStrongPositive(E)?(Us.flipEdgeBetweenTriangles(E.edgeMate.faceSuccessor,E.edgeMate.facePredecessor,E.edgeMate,E.faceSuccessor,E,E.facePredecessor),k.addAroundFace(E),k.addAroundFace(E.edgeMate),D++):R++,!(D+R>b))););return D}static createTriangulatedGraphFromPoints(y,k=po.ReplaceIfLarger,M=Q.smallMetricDistance){if(y.length<3)return;const b=[],E=[];ue.computeConvexHullXY(y,b,E,!0);const D=new fs,R=Ls.create(D,M),X=Us.createFaceLoopFromCoordinates(D,b,!0,!0);if(void 0!==X){for(const y of E)R.insertAndRetriangulate(y,k);return X.countEdgesAroundFace()>3?Us.createTriangulatedGraphFromSingleLoop(b):D}}static createTriangulatedGraphFromLoops(y){if(y.length<1)return;const k=Kr.BOUNDARY_EDGE|Kr.PRIMARY_EDGE,M=new fs,b=[];let E=-1e4,D=-1;for(let z=0;z<y.length;z++){let R=Us.directCreateFaceLoopFromCoordinates(M,y[z]);if(R){R=R.faceSuccessor;const y=R.vertexSuccessor;R.setMaskAroundFace(k),y.setMaskAroundFace(k);const M=R.signedFaceArea(),X=Math.abs(M);b.push(M>=0?R:y),(0===z||X>E)&&(E=X,D=z)}}if(0===b.length)return;const R=b[D];b[D]=b[b.length-1],b.pop(),R.vertexSuccessor.setMaskAroundFace(Kr.EXTERIOR);for(let z=0;z<b.length;z++){const y=b[z];y.setMaskAroundFace(Kr.EXTERIOR),b[z]=this.getLeftmost(y.vertexSuccessor)}const X=Us.spliceLeftMostNodesOfHoles(M,R,b);return X&&Us.triangulateSingleFace(M,X)?M:void 0}static triangulateAllPositiveAreaFaces(y){const k=y.collectFaceLoops();let M=0;for(const b of k)b.countEdgesAroundFace()>3&&b.signedFaceArea()>0&&(Us.triangulateSingleFace(y,b)||M++);return 0===M}static triangulateAllInteriorFaces(y,k){const M=y.collectFaceLoops(),b=k?y.grabMask():Kr.NULL_MASK;let E,D,R=0,X=0;for(const z of M)if(z.countEdgesAroundFace()>3){if(z.getMask(Kr.EXTERIOR))continue;if(k&&(R=y.countNodes(),D=z.collectAroundFace(),E=this._workTransform=Fi.createRightHandedLocalToWorld(D,this._workTransform),E?.multiplyInversePoint3dArrayInPlace(D)),Us.triangulateSingleFace(y,z,k)||X++,E&&D){for(let k=R;k<y.countNodes();++k)D.push(y.allHalfEdges[k]);E.multiplyPoint3dArrayInPlace(D)}}return y.dropMask(b),0===X}static createTriangulatedGraphFromSingleLoop(y){const k=new fs,M=Us.createFaceLoopFromCoordinates(k,y,!0,!0);if(M&&!(k.countNodes()<6)&&Us.triangulateSingleFace(k,M))return Us.flipTriangles(k),k}static interiorEdgeSplit(y,k,M){let b=0,E=0,D=0;if(Array.isArray(M))b=M[0],E=M[1],D=M.length>2?M[3]:0;else{const y=M;y.hasOwnProperty("x")&&(b=y.x),y.hasOwnProperty("y")&&(E=y.y),y.hasOwnProperty("z")&&(D=y.z)}return k&&Us.isAlmostEqualXAndYXY(k,b,E)?k:y.splitEdge(k,b,E,D)}static getUnwrappedLength(y){let k,M,b,E,D=y.length;for(;D>1&&(y instanceof it?(k=y.getXAtUncheckedPointIndex(0),M=y.getYAtUncheckedPointIndex(0),b=y.getXAtUncheckedPointIndex(D-1),E=y.getYAtUncheckedPointIndex(D-1)):Q.isArrayOfNumberArray(y,D,2)?(k=y[0][0],M=y[0][1],b=y[D-1][0],E=y[D-1][1]):(k=y[0].x,M=y[0].y,b=y[D-1].x,E=y[D-1].y),Q.isAlmostEqualNumber(k,b)&&Q.isAlmostEqualNumber(M,E));)--D;return D}static directCreateFaceLoopFromCoordinates(y,k){const M=this.getUnwrappedLength(k);let b;if(k instanceof it){const E=j.create();for(let D=0;D<M;D++)k.getPoint3dAtCheckedPointIndex(D,E),b=Us.interiorEdgeSplit(y,b,E)}else for(let E=0;E<M;E++)b=Us.interiorEdgeSplit(y,b,k[E]);return b}static directCreateChainsFromCoordinates(y,k,M=0){const b=new Zs(y,M);return ht.streamXYZ(k,b),b.claimSeeds()}static maskAndOrientNewFaceLoop(y,k,M,b,E){if(k){const y=(k=k.faceSuccessor).signedFaceArea(),D=k.edgeMate;b!==Kr.NULL_MASK&&(k.setMaskAroundFace(b),D.setMaskAroundFace(b));let R=k;M&&y<0&&(R=D);const X=R.vertexSuccessor;return E!==Kr.NULL_MASK&&X.setMaskAroundFace(E),R}}static createFaceLoopFromCoordinates(y,k,M,b){const E=Us.directCreateFaceLoopFromCoordinates(y,k);return Us.maskAndOrientNewFaceLoop(y,E,M,Kr.BOUNDARY_EDGE|Kr.PRIMARY_EDGE,b?Kr.EXTERIOR:Kr.NULL_MASK)}static createFaceLoopFromCoordinatesAndMasks(y,k,M,b,E){const D=Us.directCreateFaceLoopFromCoordinates(y,k);return Us.maskAndOrientNewFaceLoop(y,D,M,b,E)}static joinNeighborsOfEar(y,k){const M=y.createEdgeXYZXYZ(k.facePredecessor.x,k.facePredecessor.y,k.facePredecessor.z,k.facePredecessor.i,k.faceSuccessor.x,k.faceSuccessor.y,k.faceSuccessor.z,k.faceSuccessor.i),b=M.edgeMate;us.pinch(k.faceSuccessor,b),us.pinch(k.facePredecessor,M),k.setMaskAroundFace(Kr.TRIANGULATED_FACE)}static isInteriorTriangle(y){if(!y.isMaskSet(Kr.TRIANGULATED_FACE)||y.isMaskSet(Kr.EXTERIOR))return!1;const k=y.faceSuccessor;if(!k.isMaskSet(Kr.TRIANGULATED_FACE)||k.isMaskSet(Kr.EXTERIOR))return!1;const M=k.faceSuccessor;return!(!M.isMaskSet(Kr.TRIANGULATED_FACE)||M.isMaskSet(Kr.EXTERIOR))&&M.faceSuccessor===y}static doPostCutFlips(y){let k=y,M=k.facePredecessor,b=M.edgeMate;for(;Us.isInteriorTriangle(M)&&Us.isInteriorTriangle(b)&&Us.computeInCircleDeterminantIsStrongPositive(M);){const y=b.faceSuccessor;Us.flipEdgeBetweenTriangles(y,y.faceSuccessor,y.facePredecessor,k,k.facePredecessor,k.faceSuccessor),k=M,M=k.facePredecessor,b=M.edgeMate}return k}static triangulateSingleFace(y,k,M=!1){if(!k)return Us.setDebugGraph(y),!1;let b,E,D,R=k.countEdgesAroundFace(),X=0;for(k.clearMaskAroundFace(Kr.TRIANGULATED_FACE);!k.isMaskSet(Kr.TRIANGULATED_FACE);){if(D=k?.facePredecessor,b=k.faceSuccessor,E=b.faceSuccessor,b===k||E===k)return!0;if(E.faceSuccessor===k)return k.setMaskAroundFace(Kr.TRIANGULATED_FACE),!0;if(!Q.isAlmostEqualXAndY(E,D)||E.findAroundVertex(D)){if(++X>R)return Us.setDebugGraph(y),!1;Us.isEar(k)?(R--,X=0,k.faceSuccessor.faceSuccessor!==k.facePredecessor?(Us.joinNeighborsOfEar(y,k),M||(k=Us.doPostCutFlips(k)),k=k.faceSuccessor.edgeMate.faceSuccessor):(k.setMaskAroundFace(Kr.TRIANGULATED_FACE),k=b.faceSuccessor)):k=b}else{const y=E.faceSuccessor;if(this.nodeInTriangle(D,k,b,y)){const y=E.vertexPredecessor;us.pinch(D.vertexSuccessor,y)}else us.pinch(D,E),k.setMaskAroundFace(Kr.TRIANGULATED_FACE);k=E}}return!0}static claimDebugGraph(){const y=Us.sDebugGraph;return Us.sDebugGraph=void 0,Us.sEnableDebugGraphCapture=!1,y}static setDebugGraph(y){Us.sEnableDebugGraphCapture&&(Us.sDebugGraph=y)}static clearAndEnableDebugGraphCapture(y){Us.sEnableDebugGraphCapture=y,Us.sDebugGraph=void 0}static findAroundOrAtVertex(y,k){return!!y.findAroundVertex(k)||Q.isAlmostEqualXAndY(y,k)}static isEar(y){const k=y.facePredecessor,M=y,b=y.faceSuccessor,E=Us.signedTolerancedCCWTriangleArea(k,M,b);if(E<=0)return!1;const D=this._planes;if(!_t.createOriginAndTargetXY(k,M,D[0])||!_t.createOriginAndTargetXY(M,b,D[1])||!_t.createOriginAndTargetXY(b,k,D[2]))return!1;const R=this._earRange,X=this._edgeRange,z=this._edgeInterval;gt.createXYXYXY(k.x,k.y,M.x,M.y,b.x,b.y,R),R.expandInPlace(Q.smallMetricDistance);let N=b;const Y=1e-10*E;for(;N!==k;){const y=N.faceSuccessor;if(gt.createXYXY(N.x,N.y,y.x,y.y,X),R.intersectsRange(X)&&(ft.createXX(-1e-8,1.00000001,z),Rs.clipSegmentBelowPlanesXY(D,N,y,z,Y),!z.isNull))if(z.low>.99999999){if(!this.findAroundOrAtVertex(k,y)&&!this.findAroundOrAtVertex(M,y)&&!this.findAroundOrAtVertex(b,y))return!1}else if(z.high<1e-8){if(!this.findAroundOrAtVertex(k,N)&&!this.findAroundOrAtVertex(M,N)&&!this.findAroundOrAtVertex(b,N))return!1}else if(this.findAroundOrAtVertex(M,y)&&this.findAroundOrAtVertex(b,N));else if(!this.findAroundOrAtVertex(k,y)||!this.findAroundOrAtVertex(M,N))return!1;N=N.faceSuccessor}return!0}static spliceLeftMostNodesOfHoles(y,k,M){M.sort(((y,k)=>Us.compareX(y,k)));let b=0;for(const E of M)Us.eliminateHole(y,E,k)||b++;return 0===b?k:void 0}static compareX(y,k){return y.x-k.x}static eliminateHole(y,k,M){const b=Us.findHoleBridge(k,M);return!!b&&void 0!==Us.splitFace(y,b,k)}static findHoleBridge(y,k){let M=k;if(!M)return;const b=y.x,E=y.y;let D,R=-1/0;do{if(E<=M.y&&E>=M.faceSuccessor.y&&M.faceSuccessor.y!==M.y){const y=M.x+(E-M.y)*(M.faceSuccessor.x-M.x)/(M.faceSuccessor.y-M.y);if(y<=b&&y>R){if(R=y,y===b){if(E===M.y)return M;if(E===M.faceSuccessor.y)return M.faceSuccessor}D=M.x<M.faceSuccessor.x?M:M.faceSuccessor}}M=M.faceSuccessor}while(M!==k);if(!D)return;if(b===R)return D.facePredecessor;const X=D,z=D.x,N=D.y;let Y,O=1/0;for(M=D.faceSuccessor;M!==X;)b>=M.x&&M.x>=z&&b!==M.x&&Us.pointInTriangle(E<N?b:R,E,z,N,E<N?R:b,E,M.x,M.y)&&(Y=Math.abs(E-M.y)/(b-M.x),(Y<O||Y===O&&M.x>D.x)&&Us.locallyInside(M,y)&&(D=M,O=Y)),M=M.faceSuccessor;return D}static getLeftmost(y){let k=y,M=y;do{k.x<M.x&&(M=k),k=k.faceSuccessor}while(k!==y);return M}static pointInTriangle(y,k,M,b,E,D,R,X){return(E-R)*(k-X)-(y-R)*(D-X)>=0&&(y-R)*(b-X)-(M-R)*(k-X)>=0&&(M-R)*(D-X)-(E-R)*(b-X)>=0}static nodeInTriangle(y,k,M,b){return Us.signedTolerancedCCWTriangleArea(y,k,b)>0&&Us.signedTolerancedCCWTriangleArea(k,M,b)>0&&Us.signedTolerancedCCWTriangleArea(M,y,b)>0}static signedCWTriangleArea(y,k,M){return.5*((k.y-y.y)*(M.x-k.x)-(k.x-y.x)*(M.y-k.y))}static signedTolerancedCCWTriangleArea(y,k,M,b=1e-12){const E=k.x-y.x,D=k.y-y.y,R=M.x-y.x,X=M.y-y.y,z=.5*(E*X-D*R);return z<0?z:z<b*(E*E+D*D+(R*R+X*X))?0:z}static isAlmostEqualXAndYXY(y,k,M){return Q.isAlmostEqualNumber(y.x,k)&&Q.isAlmostEqualNumber(y.y,M)}static locallyInside(y,k){return Us.signedCWTriangleArea(y.facePredecessor,y,y.faceSuccessor)<0?Us.signedCWTriangleArea(y,k,y.faceSuccessor)>=0&&Us.signedCWTriangleArea(y,y.facePredecessor,k)>=0:Us.signedCWTriangleArea(y,k,y.facePredecessor)<0||Us.signedCWTriangleArea(y,y.faceSuccessor,k)<0}static splitFace(y,k,M){if(us.isNodeVisibleInSector(k,M)&&us.isNodeVisibleInSector(M,k)){const b=y.createEdgeXYZXYZ(k.x,k.y,k.z,k.i,M.x,M.y,M.z,M.i),E=b.faceSuccessor;return us.pinch(k,b),us.pinch(M,E),b}}static triangulateSingleMonotoneFace(y,k){let M,b=k.facePredecessor,E=k.faceSuccessor;for(;b!==E&&E!==k&&E.faceSuccessor!==b;){if(us.crossProductXYAlongChain(b,k,E)<=0)return!1;if(!k.belowYX(b))return!1;if(!k.belowYX(E))return!1;if(b.belowYX(E)){let D=b,R=k,X=E;for(;D!==X&&D.belowYX(E);){for(;X!==E&&X!==D&&X!==R&&us.crossProductXYAlongChain(D,R,X)>0;){if(M=Us.splitFace(y,D,X),void 0===M)return!1;D=M,R=D.faceSuccessor,X=R.faceSuccessor}X=R,R=D,D=D.facePredecessor}for(b=R,X=E,R=X.facePredecessor,D=R.facePredecessor;X.faceSuccessor!==D&&D!==b;){if(M=Us.splitFace(y,D,X),void 0===M)return!1;R=M,D=R.facePredecessor}if(X.faceSuccessor!==D){if(M=Us.splitFace(y,D,X),void 0===M)return!1;D=M}E=(k=D).faceSuccessor,b=k.facePredecessor}else{let D=b,R=k,X=E;for(;D!==X&&X.belowYX(b);){for(;D!==b&&X!==D&&X!==R&&us.crossProductXYAlongChain(D,R,X)>0;){if(M=Us.splitFace(y,D,X),void 0===M)return!1;D=M.facePredecessor,R=M}D=R,R=X,X=X.faceSuccessor}for(E=R,D=b,R=D.faceSuccessor,X=R.faceSuccessor;X.faceSuccessor!==D&&X!==E;){if(M=Us.splitFace(y,D,X),void 0===M)return!1;D=M,X=X.faceSuccessor}if(X.faceSuccessor!==D&&void 0===Us.splitFace(y,D,X))return!1;E=(k=E).faceSuccessor,b=k.facePredecessor}}return!0}}Us.sEnableDebugGraphCapture=!1,Us._edgeInterval=ft.createNull(),Us._earRange=gt.createNull(),Us._edgeRange=gt.createNull(),Us._planes=[_t.createXYPlane(),_t.createXYPlane(),_t.createXYPlane()];class Zs extends ot{constructor(y,k){super(),this._graph=y,this._id=k}startChain(y,k){super.startChain(y,k),this._baseNode=void 0,this._nodeB=void 0}handleXYZXYZ(y,k,M,b,E,D){this._nodeC=this._graph.createEdgeXYZXYZ(y,k,M,this._id,b,E,D,this._id),void 0===this._baseNode?(this._baseNode=this._nodeC,this._nodeB=this._baseNode.faceSuccessor):(us.pinch(this._nodeB,this._nodeC),this._nodeB=this._nodeC.faceSuccessor)}endChain(y,k){super.endChain(y,k),void 0!==this._baseNode&&(void 0===this._seeds&&(this._seeds=[]),this._seeds.push(this._baseNode)),this._baseNode=void 0,this._nodeB=void 0,this._nodeC=void 0}claimSeeds(){return void 0===this._seeds?[]:this._seeds}}class qs{constructor(){this.numUpEdge=0,this.numIntersectionTest=0,this.numSplit=0,this.numPopOut=0,this.numA0B0=0,this.numA0B1=0}}class Ws{constructor(y,k,M,b){this.index=y,this.radiusOfCurvature=k,this.node=M,this.radians=b}}class Gs{static compareNodesYXUp(y,k){return y.y<k.y?-1:y.y>k.y?1:y.x<k.x?-1:y.x>k.x?1:0}static isDownPeak(y){const k=y.facePredecessor,M=y.faceSuccessor;return this.compareNodesYXUp(y,k)<0&&this.compareNodesYXUp(y,M)<0&&this.crossProductToTargets(y,k,M)>0}static crossProductToTargets(y,k,M){return Q.crossProductXYXY(k.x-y.x,k.y-y.y,M.x-y.x,M.y-y.y)}static graphRange(y){const k=ut.create();for(const M of y.allHalfEdges)k.extendXYZ(M.x,M.y,M.z);return k}static segmentArrayToGraphEdges(y,k,M){const b=[];let E=0;for(const D of y){const y=k.createEdgeXYZXYZ(D.point0Ref.x,D.point0Ref.y,D.point0Ref.z,E,D.point1Ref.x,D.point1Ref.y,D.point1Ref.z,E+1),R=y.edgeMate;E+=2,y.setMaskAroundFace(M),b.push(y),b.push(R)}return b}static isolateAllEdges(y){for(const k of y.allHalfEdges){const y=k.vertexPredecessor;us.pinch(k,y)}}static isSectorConvexAfterEdgeRemoval(y,k,M,b=0){let E=y;do{if(E.isMaskSet(M)||E.edgeMate.isMaskSet(M))break;E=E.vertexSuccessor}while(E!==y&&E.isMaskSet(k));if(E===y)return!1;let D=y;do{if(D.isMaskSet(M)||D.edgeMate.isMaskSet(M))break;D=D.vertexPredecessor}while(D!==y&&D.isMaskSet(k));return D!==y&&us.isSectorConvex(E.edgeMate,y,D.faceSuccessor,b)}static markRemovableEdgesToExpandConvexFaces(y,k,M=Kr.BOUNDARY_EDGE){if(Kr.NULL_MASK===k)return 0;const b=y.grabMask(!0);let E=0;for(const D of y.allHalfEdges){if(!D.isMaskSet(b)&&!D.isMaskSet(M)&&!D.edgeMate.isMaskSet(M)){const y=Q.smallMetricDistanceSquared*(D.signedFaceArea()+D.edgeMate.signedFaceArea());this.isSectorConvexAfterEdgeRemoval(D,k,M,y)&&this.isSectorConvexAfterEdgeRemoval(D.edgeMate,k,M,y)&&(D.setMaskAroundEdge(k),++E)}D.setMaskAroundEdge(b)}return y.dropMask(b),E}static collectRemovableEdgesToExpandConvexFaces(y,k=Kr.BOUNDARY_EDGE){const M=[],b=y.grabMask(!0);if(0<this.markRemovableEdgesToExpandConvexFaces(y,b,k)){const k=y.grabMask(!0);for(const E of y.allHalfEdges)E.isMaskSet(b)&&!E.isMaskSet(k)&&(E.setMaskAroundEdge(k),M.push(E));y.dropMask(k)}return y.dropMask(b),M}static expandConvexFaces(y,k=Kr.BOUNDARY_EDGE){const M=y.grabMask(!0),b=this.markRemovableEdgesToExpandConvexFaces(y,M,k);return b>0&&e(y.yankAndDeleteEdges((y=>y.getMask(M)))),y.dropMask(M),b}static isEveryFaceConvex(y,k=Kr.EXTERIOR){const M=y.collectFaceLoops();for(const b of M)if(!b.isMaskedAroundFace(k)&&!b.isFaceConvex())return!1;return!0}}class Hs{static getCommonThetaEndIndex(y,k,M,b){let E=M+1;const D=y.getExtraData(k[M],0);for(;E<b;){const M=y.getExtraData(k[E],0);if(!W.isAlmostEqualRadiansAllowPeriodShift(D,M))return E;E++}return E}static set announceVertexNeighborhoodFunction(y){this._announceVertexNeighborhoodFunction=y}static doAnnounceVertexNeighborhood(y,k,M,b,E){if(this._announceVertexNeighborhoodFunction){const D=[];for(let R=b;R<E;R++){const b=y.getExtraData(k[R],1),E=y.getExtraData(k[R],0),X=M[b],z=this.curvatureSortKey(X);D.push(new Ws(k[R],z,X,E))}this._announceVertexNeighborhoodFunction(D)}}static secondarySortAroundVertex(y,k,M,b,E){const D=[];for(let R=b;R<E;){const b=this.getCommonThetaEndIndex(y,k,R,E);if(R+1<b){D.length=0;for(let E=R;E<b;E++){const b=M[y.getExtraData(k[E],1)],R=this.curvatureSortKey(b);D.push(new Ws(k[E],R,b))}D.sort(((y,k)=>y.radiusOfCurvature-k.radiusOfCurvature));for(let y=0;y<D.length;y++)k[R+y]=D[y].index}R=b}}static curvatureSortKey(y){const k=y.edgeTag;if(void 0!==k){const M=k.fraction,b=k.curve;if(b){let k=b.fractionToSignedXYRadiusOfCurvature(M);return void 0!==y.sortData&&y.sortData<0&&(k=-k),k}}return 0}static isNullFace(y){return y.isMaskSet(Kr.NULL_FACE)&&y.faceSuccessor.isMaskSet(Kr.NULL_FACE)&&y===y.faceSuccessor.faceSuccessor}static clusterAndMergeXYTheta(y,k){const M=y.allHalfEdges,b=M.length;y.clearMask(Kr.NULL_FACE);const E=new Ni(2,2,b);for(let B=0;B<b;B++){const y=M[B],k=y.x,b=y.y;us.pinch(y,y.vertexSuccessor),E.addDirect(k,b,0,B)}const D=Q.smallMetricDistance,R=E.clusterIndicesLexical(D);let X=0;const z=R.length;for(let B=0;B<z;B++)if(R[B]===Ni.clusterTerminator){if(B>X){const y=M[E.getExtraData(R[X],1)];for(let k=X+1;k<B;k++){const b=M[E.getExtraData(R[k],1)];b.x=y.x,b.y=y.y}}X=B+1}for(const B of R)if(B!==Ni.clusterTerminator){const y=M[B],b=y.faceSuccessor;let D=k;if(D){const k=y.edgeTag;(void 0===k||void 0===k.curve||k.curve instanceof Ce)&&(D=void 0)}let R=D?D(y):Math.atan2(b.y-y.y,b.x-y.x);W.isAlmostEqualRadiansAllowPeriodShift(R,-Math.PI)&&(R=Math.PI),E.setExtraData(B,0,R)}E.sortSubsetsBySingleKey(R,2);const N=[];let Y,O;X=0;for(let B=0;B<z;B++)if(R[B]===Ni.clusterTerminator){if(B>X){B>X+1&&this.secondarySortAroundVertex(E,R,M,X,B),this.doAnnounceVertexNeighborhood(E,R,M,X,B);const y=E.getExtraData(R[X],1);Y=E.getExtraData(R[X],0);let k=M[y];for(let b=X+1;b<B;b++){const y=E.getExtraData(R[b],1);O=E.getExtraData(R[b],0);const X=M[y];if(k.isMaskSet(Kr.NULL_FACE)){const y=N.findIndex((y=>k===y));y>=0&&(N[y]=N[N.length-1],N.pop()),k=X,Y=O}else if(X.isMaskSet(Kr.NULL_FACE)){const y=N.findIndex((y=>X===y));y>=0&&(N[y]=N[N.length-1],N.pop())}else{if(us.pinch(k,X),W.isAlmostEqualRadiansAllowPeriodShift(Y,O)){const y=k.faceSuccessor,M=X.edgeMate;if(y.isEqualXY(M)){const b=this.curvatureSortKey(k),E=this.curvatureSortKey(X);Q.isSameCoordinate(b,E,D)&&(us.pinch(y,M),k.setMask(Kr.NULL_FACE),M.setMask(Kr.NULL_FACE),N.push(M))}}k=X,Y=O}}}X=B+1}}static buildVerticalSweepPriorityQueue(y){const k=new ps;for(const M of y.allHalfEdges)Gs.compareNodesYXUp(M,M.faceSuccessor)<0&&k.priorityQueue.push(M);return k}static snapFractionToNode(y,k,M,b){return Q.isSameCoordinate(y.x,M.x)&&Q.isSameCoordinate(y.y,M.y)?b:k}static computeIntersectionFractionsOnEdges(y,k,M,b,E){const D=y.faceSuccessor,R=y.x,X=y.y,z=D.x-R,N=D.y-X,Y=k.faceSuccessor,O=k.x,B=k.y,V=Y.x-O,U=Y.y-B;return!!Mt.lineSegmentXYUVTransverseIntersectionUnbounded(R,X,z,N,O,B,V,U,M)&&(b.x=R+M.x*z,b.y=X+M.x*N,E.x=O+M.y*V,E.y=B+M.y*U,M.x=this.snapFractionToNode(b,M.x,y,0),M.x=this.snapFractionToNode(b,M.x,D,1),M.y=this.snapFractionToNode(E,M.y,k,0),M.y=this.snapFractionToNode(E,M.y,Y,1),Q.isIn01(M.x)&&Q.isIn01(M.y))}static splitIntersectingEdges(y){const k=new qs,M=this.buildVerticalSweepPriorityQueue(y);let b,E;const D=.99999999;let R;const X=J.create(),z=H.create(),N=H.create();let Y;const O=Q.smallMetricDistance;for(;void 0!==(b=M.priorityQueue.pop());){k.numUpEdge++;const B=M.activeEdges.length;for(M.removeArrayMembersWithY1Below(b.y-O),k.numPopOut+=B-M.activeEdges.length,R=0;R<M.activeEdges.length;R++)if(Y=M.activeEdges[R],E=Y.faceSuccessor,Q.isSameCoordinateXY(b.x,b.y,Y.x,Y.y))k.numA0B0++;else if(Q.isSameCoordinateXY(E.x,E.y,b.x,b.y))k.numA0B1++;else if(k.numIntersectionTest++,this.computeIntersectionFractionsOnEdges(b,Y,X,z,N)){if(X.x>1e-8&&X.x<D){const E=y.splitEdgeAtFraction(b,X.x);M.priorityQueue.push(E),k.numSplit++}if(X.y>1e-8&&X.y<D){const b=y.splitEdgeAtFraction(Y,X.y);M.priorityQueue.push(b),k.numSplit++}}M.activeEdges.push(b)}return k}static formGraphFromSegments(y){const k=new fs;return Gs.segmentArrayToGraphEdges(y,k,Kr.BOUNDARY_EDGE),this.splitIntersectingEdges(k),this.clusterAndMergeXYTheta(k),k}static formGraphFromChains(y,k=!0,M=Kr.PRIMARY_EDGE){if(y.length<1)return;const b=new fs,E=Us.directCreateChainsFromCoordinates(b,y);for(const D of E)D.setMaskAroundFace(M);return this.splitIntersectingEdges(b),this.clusterAndMergeXYTheta(b),k&&new ms(b).regularizeGraph(!0,!0),b}}class Js{static createPrimarySortVector(y){return void 0===y&&(y=this._defaultPrimarySortDirection.clone()),y.normalizeWithDefault(Js._defaultPrimarySortDirection.x,Js._defaultPrimarySortDirection.y,Js._defaultPrimarySortDirection.z)}constructor(y,k){this.tolerance=y,this.primarySortDirection=k}static createFromUnValidated(y){const k=new Js(Q.smallMetricDistance,Js.createPrimarySortVector());return void 0!==y&&(void 0!==y.tolerance&&(k.tolerance=y.tolerance),void 0!==y.primarySortDirection&&(k.primarySortDirection=Js.createPrimarySortVector())),k}clone(){return new Js(this.tolerance,this.primarySortDirection)}}Js._defaultPrimarySortDirection=$.create(.294234298,.72391399,.45234328798);class Qs{constructor(y){this._graph=new fs,this._options=y}set plane(y){this._plane=y}get plane(){return this._plane}set convexClipper(y){this._convexClipper=y}get convexClipper(){return this._convexClipper}static create(y){const k=Js.createFromUnValidated(y);return new Qs(k)}addSegment(y,k){this._graph.createEdgeXYZXYZ(y.x,y.y,y.z,0,k.x,k.y,k.z,0)}addLineSegment3dArray(y){for(const k of y)this.addSegment(k.point0Ref,k.point1Ref)}addSegmentsOnPlane(y,k=!1){if(!this._plane)return;const M=this._plane;let b,E=k?y.length-1:0,D=y.evaluateUncheckedIndexPlaneAltitude(E,M),R=k?0:1;for(;R<y.length;E=R++,D=b)b=y.evaluateUncheckedIndexPlaneAltitude(R,M),Q.isSmallMetricDistance(D)&&Q.isSmallMetricDistance(b)&&this._graph.createEdgeXYZXYZ(y.getXAtUncheckedPointIndex(E),y.getYAtUncheckedPointIndex(E),y.getZAtUncheckedPointIndex(E),0,y.getXAtUncheckedPointIndex(R),y.getYAtUncheckedPointIndex(R),y.getZAtUncheckedPointIndex(R),0)}primarySortKey(y){return this._options.primarySortDirection.dotProductXYZ(y.x,y.y,y.z)}static nodeCompareSortData(y,k){return y.sortData-k.sortData}static isIsolatedEnd(y){return y.vertexSuccessor===y}static isChainInteriorVertex(y){const k=y.vertexSuccessor;return k!==y&&k.vertexSuccessor===y}clusterAndMergeVerticesXYZ(){Gs.isolateAllEdges(this._graph);for(const b of this._graph.allHalfEdges)b.sortData=this.primarySortKey(b);const y=this._graph.allHalfEdges.slice();y.sort(((y,k)=>Qs.nodeCompareSortData(y,k)));const k=this._options.tolerance,M=y.length;for(let b=0;b<M;b++){const E=y[b],D=E.sortData+k;if(Qs.isIsolatedEnd(E))for(let R=b+1;R<M;R++){const M=y[R];if(Qs.isIsolatedEnd(M)){if(M.sortData>D)break;E.distanceXYZ(M)<=k&&(us.pinch(E,M),M.setXYZFrom(E))}}}}collectMaximalLineString3dFromStartNode(y,k,M){if(!k.isMaskSet(M)){const b=Me.create();for(b.addPointXYZ(k.x,k.y,k.z);k.setMask(M),k.edgeMate.setMask(M),k=k.faceSuccessor,b.addPointXYZ(k.x,k.y,k.z),!k.isMaskSet(M)&&Qs.isChainInteriorVertex(k););y.push(b)}}collectMaximalGrowableXYXArrayFromStartNode(y,k,M){if(!k.isMaskSet(M)){const b=new nt;for(b.pushXYZ(k.x,k.y,k.z);k.setMask(M),k.edgeMate.setMask(M),k=k.faceSuccessor,b.pushXYZ(k.x,k.y,k.z),!k.isMaskSet(M)&&Qs.isChainInteriorVertex(k););b.length>0&&y.push(b)}}exciseAndMarkSlingEdges(y){let k=0;for(const M of this._graph.allHalfEdges)if(M.distanceXYZ(M.edgeMate)<this._options.tolerance&&!M.isMaskSet(y)){const b=M.edgeMate;us.pinch(M,M.vertexPredecessor),us.pinch(b,b.vertexPredecessor),M.setMask(y),b.setMask(y),k++}return k}collectMaximalChains(){const y=[],k=Kr.VISITED;this.exciseAndMarkSlingEdges(k),this._graph.clearMask(k);for(const M of this._graph.allHalfEdges)Qs.isChainInteriorVertex(M)||this.collectMaximalLineString3dFromStartNode(y,M,k);for(const M of this._graph.allHalfEdges)this.collectMaximalLineString3dFromStartNode(y,M,k);return y}collectMaximalGrowableXYZArrays(){const y=[],k=Kr.VISITED;this.exciseAndMarkSlingEdges(k),this._graph.clearMask(k);for(const M of this._graph.allHalfEdges)Qs.isChainInteriorVertex(M)||this.collectMaximalGrowableXYXArrayFromStartNode(y,M,k);for(const M of this._graph.allHalfEdges)this.collectMaximalGrowableXYXArrayFromStartNode(y,M,k);return y}}class Ks{constructor(){this._unmatchedEdges=new Map,this._graph=new fs,this._halfEdgesAroundCurrentLoop=[]}get graph(){return this._graph}indexPairToString(y,k){return`${y.toString()},${k.toString()}`}insertLoop(y,k){if(y.length>2){let M=y[y.length-1];this._halfEdgesAroundCurrentLoop.length=0;for(const E of y){const y=this.indexPairToString(M,E),b=this._unmatchedEdges.get(y);if(void 0===b){const y=this.indexPairToString(E,M),b=this._graph.createEdgeIdId(M,E);void 0!==k&&k(b),this._unmatchedEdges.set(y,b.edgeMate),this._halfEdgesAroundCurrentLoop.push(b),b.edgeMate.setMask(Kr.EXTERIOR)}else this._halfEdgesAroundCurrentLoop.push(b),b.clearMask(Kr.EXTERIOR);M=E}let b=this._halfEdgesAroundCurrentLoop[this._halfEdgesAroundCurrentLoop.length-1];for(const y of this._halfEdgesAroundCurrentLoop){const k=b.faceSuccessor;us.pinch(y,k),b=y}return this._halfEdgesAroundCurrentLoop[0]}}}class js{constructor(y){this.positiveSum=this.negativeSum=0,this.numPositive=this.numNegative=this.numZero=0,this.largestPositiveValue=this.largestNegativeValue=0,y&&(this.negativeItemArray=[],this.positiveItemArray=[],this.zeroItemArray=[])}announceItem(y,k){k<0?(this.numNegative++,this.negativeSum+=k,this.negativeItemArray&&this.negativeItemArray.push(y),k<this.largestNegativeValue&&(this.largestNegativeValue=k,this.largestNegativeItem=y)):k>0?(this.numPositive++,this.positiveSum+=k,this.positiveItemArray&&this.positiveItemArray.push(y),k>this.largestPositiveValue&&(this.largestPositiveValue=k,this.largestPositiveItem=y)):(this.numZero++,this.zeroItemArray&&this.zeroItemArray.push(y))}}class $s{constructor(y,k=!0){this._targetMask=y,this._targetValue=k}testEdge(y){return y.isMaskSet(this._targetMask)===this._targetValue}}class tn{static signedFaceArea(y){return y.signedFaceArea()}static collectFaceAreaSummary(y,k=!1,M=y=>tn.signedFaceArea(y)){const b=new js(k);let E;E=y instanceof fs?y.collectFaceLoops():y;for(const D of E){const y=M(D);b.announceItem(D,y)}return b}static findMinimumAreaFace(y,k){return tn.collectFaceAreaSummary(y,!1,k).largestNegativeItem}static isTriangulatedCCW(y,k=!0,M=0){let b;b=y instanceof fs?y.collectFaceLoops():y;let E=0,D=0;for(const R of b){const y=R.countEdgesAroundFace();if(y>=3)if(R.signedFaceArea()>0){if(y>3&&(D++,D>M))return!1}else if(E++,E>1&&!k)return!1}return!0}static pushAndMaskAllNodesInFace(y,k,M,b){b.push(y),y.collectAroundFace((y=>{y.setMask(k),M.push(y)}))}static parityFloodFromSeed(y,k,M,b){const E=[];if(y.isMaskSet(k))return E;const D=b|k,R=[];for(tn.pushAndMaskAllNodesInFace(y,D,R,E);R.length>0;){const y=R.pop(),X=y.edgeMate;if(X&&!X.isMaskSet(k)){let z=y.isMaskSet(b);M&&!M.testEdge(y)||(z=!z),tn.pushAndMaskAllNodesInFace(X,z?D:k,R,E)}}return E}static correctParityInSingleComponent(y,k){const M=tn.findMinimumAreaFace(k);if(M)if(M.isMaskSet(y));else for(const b of k)b.isMaskSet(y)?b.clearMaskAroundFace(y):b.setMaskAroundFace(y)}static correctParityInComponentArrays(y,k){if(y!==Kr.NULL_MASK)for(const M of k)tn.correctParityInSingleComponent(y,M)}static collectConnectedComponentsWithExteriorParityMasks(y,k,M=Kr.NULL_MASK){const b=[],E=Kr.VISITED,D=M|E;y.clearMask(D);for(const R of y.allHalfEdges)if(!R.isMaskSet(E)){const y=tn.parityFloodFromSeed(R,E,k,M);b.push(y)}return tn.correctParityInComponentArrays(M,b),b}static exploreComponent(y,k,M,b=Kr.EXTERIOR,E=1/0){E<=0&&(E=1/0);const D=M|b;let R=0;const X=[];for(X.push(k);0!==X.length&&R<E;){const k=X.shift();if(k.isMaskSet(D))continue;y.push(k),++R;const s=y=>{y.setMask(M);const k=y.vertexSuccessor;k.isMaskSet(D)||X.push(k)};k.collectAroundFace(s)}if(0!==X.length){const y=X[0];for(;0!==X.length;){const y=X.shift();if(y.vertexSuccessor.isMaskSet(b))return y;if(y.edgeMate.isMaskSet(b))return y}return y}}static collectConnectedComponents(y,k=1/0,M=Kr.EXTERIOR){const b=[];0===y.countMask(M)&&(M=Kr.NULL_MASK);const E=Kr.VISITED,D=E|M,o=k=>{for(let M=k;M<y.countNodes();++M)if(!y.allHalfEdges[M].isMaskSet(D)&&y.allHalfEdges[M].edgeMate.isMaskSet(D)){k=M;break}return k};for(let R=0;R<y.countNodes();++R){if(y.allHalfEdges[R].isMaskSet(D))continue;const X=o(R);let z=y.allHalfEdges[X];do{const y=[];z=tn.exploreComponent(y,z,E,M,k),0!==y.length&&b.push(y)}while(void 0!==z);y.allHalfEdges[R].isMaskSet(E)||--R}return b}static pointInOrOnFaceXY(y,k,M){const b=new zt(k,M);let E=y,D=y.faceSuccessor;for(;!b.tryStartEdge(E.x,E.y,D.x,D.y);E=D){if(D===y)return ft.createXX(D.x,D.faceSuccessor.x).containsX(k)?0:-1;D=E.faceSuccessor}let R=D.faceSuccessor;for(;;){if(!b.advance(R.x,R.y))return b.classifyCounts();if(R===D)break;R=R.faceSuccessor}return b.classifyCounts()}static collectExtendedBoundaryLoopFromSeed(y,k,M,b){let E=0;for(;!y.getMask(k)&&M(y);){b(y,E++),y.setMask(k);const D=y.faceSuccessor;let R=D;for(;;){if(R.getMask(k))return;if(M(R)){y=R;break}if(R=R.vertexPredecessor,R===D)break}}}static collectExtendedBoundaryLoopsInGraph(y,k){const M=[],b=y.grabMask(!0),n=y=>0===y.getMask(k)&&0!==y.edgeMate.getMask(k),r=(y,k)=>{0===k&&M.push([]),M[M.length-1].push(y)};for(const E of y.allHalfEdges)this.collectExtendedBoundaryLoopFromSeed(E,b,n,r);return y.dropMask(b),M}}class en{static spaceTriangleAspectRatio(y,k,M){const b=.5*y.crossProductToPoints(k,M).magnitude(),E=y.distanceSquared(k)+k.distanceSquared(M)+M.distanceSquared(y);return Q.safeDivideFraction(b,E,0)}static spaceQuadDiagonalAspectRatio(y,k,M,b){const E=this.spaceTriangleAspectRatio(y,k,M),D=this.spaceTriangleAspectRatio(y,M,b);return Math.max(E,D)}static triangulateGreedyEarCut(y,k){const M=Ur.areaNormal(y),b=[],E=y.slice();for(Mi.removeClosurePoint(E);E.length>2;){let y,k=-1,D=0,R=E.length-2,X=E.length-1;for(y=0;y<E.length;R=X,X=y,y++){const b=this.spaceTriangleAspectRatio(E[R],E[X],E[y]);E[R].crossProductToPoints(E[X],E[y]).dotProduct(M)>0&&b>k&&(k=b,D=R)}if(k<=0)return!1;R=D,X=(R+1)%E.length,y=(X+1)%E.length;const z=[];z.push(E[R],E[X],E[y]),E.splice(X,1),b.push(z)}return k(y,b),!0}static triangulateSimplestSpaceLoopGo(y,k,M){const b=ue.countNonDuplicates(y);if(void 0!==M&&ue.sumEdgeLengths(y,!0,b)>M)return!1;if(b<3)return!1;if(3===b)return 0!==this.spaceTriangleAspectRatio(y[0],y[1],y[2])&&(k(y,[y.slice()]),!0);if(4===b){const M=this.spaceQuadDiagonalAspectRatio(y[0],y[1],y[2],y[3]),b=this.spaceQuadDiagonalAspectRatio(y[1],y[2],y[3],y[0]);return!(0===M&&0===b||(M>b?(k(y,[[y[0],y[1],y[2]],[y[2],y[3],y[0]]]),0):(k(y,[[y[0],y[1],y[3]],[y[3],y[1],y[2]]]),0)))}return this.triangulateGreedyEarCut(y,k)}static triangulateSimplestSpaceLoop(y,k,M){return y instanceof Me?this.triangulateSimplestSpaceLoopGo(y.points,k,M):this.triangulateSimplestSpaceLoopGo(y,k,M)}}class sn{constructor(y=-1,k){this._facetIndex=y,this._detail=k||cs.create()}invalidate(y=!0){this._facetIndex=-1,y&&this._detail.invalidate(),this._normal=void 0,this._param=void 0,this._color=void 0}static create(y=-1,k,M){return M?M.invalidate(!1):M=new sn,M._facetIndex=y,void 0!==k&&M._detail!==k&&M._detail.copyContentsFrom(k),M}static createCapture(y,k){return new sn(y,k)}get facetIndex(){return this._facetIndex}get edgeCount(){return 3}get point(){return this._detail.world}get a(){return this._detail.a}get closestEdge(){return{startVertexIndex:this._detail.closestEdgeIndex,edgeParam:this._detail.closestEdgeParam}}get _isValid(){return this._facetIndex>=0}get isValid(){return this._isValid&&this._detail.isValid}get isConvex(){return!0}get isInsideOrOn(){return this._isValid&&this._detail.isInsideOrOn}get classify(){return this._detail.classify}clone(){const y=new sn;return y.copyContentsFrom(this),y}copyContentsFrom(y){this._facetIndex=y._facetIndex,this._detail.copyContentsFrom(y._detail),this._normal=y._normal?.clone(),this._param=y._param?.clone(),this._color=y._color}getNormal(y){if(this._detail.isValid&&void 0===this._normal&&void 0!==y){this._normal=$.create();const k=[this._detail.local.x,this._detail.local.y,this._detail.local.z];y.linearCombination(k,this._normal)}return this._normal}getParam(y){if(this._detail.isValid&&void 0===this._param&&void 0!==y){this._param=H.create();const k=[this._detail.local.x,this._detail.local.y,this._detail.local.z];y.linearCombination(k,this._param)}return this._param}getColor(y){if(this._detail.isValid&&void 0===this._color&&void 0!==y){const k=[this._detail.local.x,this._detail.local.y,this._detail.local.z];this._color=he.linearCombinationOfColors(y,k)}return this._color}getBarycentricCoordinates(){return[this._detail.local.x,this._detail.local.y,this._detail.local.z]}}class nn{constructor(y=-1,k=0,M){this._facetIndex=y,this._edgeCount=k,this._detail=M||Yr.create()}invalidate(y=!0){this._facetIndex=-1,this._edgeCount=0,y&&this._detail.invalidate()}static create(y=-1,k=0,M,b){return b?b.invalidate(!1):b=new nn,b._facetIndex=y,b._edgeCount=k,void 0!==M&&b._detail!==M&&b._detail.copyContentsFrom(M),b}static createCapture(y,k,M){return new nn(y,k,M)}get facetIndex(){return this._facetIndex}get edgeCount(){return this._edgeCount}get point(){return this._detail.point}get a(){return this._detail.a}get closestEdge(){return{startVertexIndex:this._detail.closestEdgeIndex,edgeParam:this._detail.closestEdgeParam}}get _isValid(){return this._facetIndex>=0&&this._edgeCount>=3}get isValid(){return this._isValid&&this._detail.isValid}get isConvex(){return!1}get isInsideOrOn(){return this._isValid&&this._detail.isInsideOrOn}get classify(){return this._detail.code}clone(){const y=new nn;return y.copyContentsFrom(this),y}copyContentsFrom(y){this._facetIndex=y._facetIndex,this._edgeCount=y._edgeCount,this._detail.copyContentsFrom(y._detail)}getNormal(){}getParam(){}getColor(){}getBarycentricCoordinates(){}}class rn extends nn{constructor(y=-1,k=0,M){super(y,k,M)}invalidate(y=!0){super.invalidate(y),this._normal=void 0,this._param=void 0,this._color=void 0,this._barycentricCoordinates=void 0}static create(y=-1,k=0,M,b){return b?b.invalidate(!1):b=new rn,super.create(y,k,M,b)}static createCapture(y,k,M){return new rn(y,k,M)}get isConvex(){return!0}clone(){const y=new rn;return y.copyContentsFrom(this),y}copyContentsFrom(y){super.copyContentsFrom(y),this._normal=y._normal?.clone(),this._param=y._param?.clone(),this._color=y._color,this._barycentricCoordinates=y._barycentricCoordinates?.slice()}getNormal(y,k,M=Q.smallMetricDistance){if(this._detail.isValid&&void 0===this._normal&&void 0!==y){const b=this.getBarycentricCoordinates(k,M);void 0!==b&&(this._normal=$.create(),y.linearCombination(b,this._normal))}return this._normal}getParam(y,k,M=Q.smallMetricDistance){if(this._detail.isValid&&void 0===this._param&&void 0!==y){const b=this.getBarycentricCoordinates(k,M);void 0!==b&&(this._param=H.create(),y.linearCombination(b,this._param))}return this._param}getColor(y,k,M=Q.smallMetricDistance){if(this._detail.isValid&&void 0===this._color&&void 0!==y){const b=this.getBarycentricCoordinates(k,M);void 0!==b&&(this._color=he.linearCombinationOfColors(y,b))}return this._color}getBarycentricCoordinates(y,k=Q.smallMetricDistance){return this._detail.isValid&&void 0===this._barycentricCoordinates&&void 0!==y&&(this._barycentricCoordinates=Ur.convexBarycentricCoordinates(y,this._detail.point,k)),this._barycentricCoordinates}}class on extends Float64Array{get vertexIndexA(){return this[0]}get vertexIndexB(){return this[1]}get facetIndex(){return this[2]}get isLowHigh(){return this[0]<this[1]}get lowVertexIndex(){return this[0]<this[1]?this[0]:this[1]}get highVertexIndex(){return this[0]>this[1]?this[0]:this[1]}static areDirectedPartners(y,k){return y[0]===k[1]&&y[1]===k[0]}static areUndirectedPartners(y,k){return y[0]===k[0]&&y[1]===k[1]||y[0]===k[1]&&y[1]===k[0]}static relativeOrientation(y,k){return y[0]===k[0]&&y[1]===k[1]?1:y[0]===k[1]&&y[1]===k[0]?-1:0}get isNullEdge(){return this[0]===this[1]}static lessThan(y,k){const M=y.lowVertexIndex,b=k.lowVertexIndex;if(M<b)return-1;if(b<M)return 1;const E=y.highVertexIndex,D=k.highVertexIndex;return E<D?-1:D<E?1:y.vertexIndexA-k.vertexIndexA}constructor(y,k,M){super(3),this[0]=y,this[1]=k,this[2]=M}toJSON(){return[this[0],this[1],this[2]]}static clusterToJSON(y){if(y instanceof on)return y.toJSON();const k=[];for(const M of y)k.push(M.toJSON())}static clusterArrayToJSON(y){const k=[];for(const M of y)k.push(on.clusterToJSON(M));return k}}class an{constructor(){this.edges=[]}addEdge(y,k,M){const b=new on(y,k,M);return this.edges.push(b),b}addPath(y,k,M=!0){if(0===y.length)return;const b=y.length-1;for(let E=0;E<b;E++)this.addEdge(y[E],y[E+1],k);M&&this.addEdge(y[b],y[0],k)}sort(){this.edges.sort(((y,k)=>on.lessThan(y,k)))}collectSortableEdgeCluster(y,k,M){if(void 0!==M&&k>y)if(k===y+1)M.push(this.edges[y]);else{const b=[];for(let M=y;M<k;M++)b.push(this.edges[M]);M.push(b)}}sortAndCollectClusters(y,k,M,b){this.sort(),y&&(y.length=0),k&&(k.length=0),M&&(M.length=0),b&&(b.length=0);const E=this.edges.length;let D;for(let R=0;R<E;R+=D){const X=this.edges[R];D=1;for(let y=R+1;y<E&&on.areUndirectedPartners(X,this.edges[y]);y++)D++;this.edges[R].isNullEdge?this.collectSortableEdgeCluster(R,R+D,M):2===D&&on.areDirectedPartners(X,this.edges[R+1])?this.collectSortableEdgeCluster(R,R+D,y):1===D?this.collectSortableEdgeCluster(R,R+1,k):this.collectSortableEdgeCluster(R,R+D,b)}}}class cn{constructor(y){this.numPositive=this.numNegative=0,this.firstEdgeIndex=y}recordOrientation(y){y>0?this.numPositive++:y<0&&this.numNegative++}}class ln{constructor(y){this._workArray=[],this._visitor=y.createVisitor(1),this._edges=Fn.createIndexedEdges(this._visitor),this._edgeToPartnerEdge=[],this._edgeToEdgeInComponent=[],this._facetToFirstEdgeInComponent=[],this._facetOrientation=[],this._components=[],this._mesh=y}edgeIdToFacetOrientation(y){const k=this._edges.edges[y].facetIndex;return this._facetOrientation[k]}setupUnoriented(){this._edges.sort();const y=this._edges.edges;let k=-1;const M=this._edges.edges.length;for(let b=0;b<M;b++){const y=this._edges.edges[b].facetIndex;y>k&&(k=y),this._edgeToEdgeInComponent.push(b),this._edgeToPartnerEdge.push(b)}for(let b=0;b<=k;b++)this._facetToFirstEdgeInComponent.push(-1),this._facetOrientation.push(0);for(let b=0;b<M;b++){const y=this._edges.edges[b].facetIndex,k=this._facetToFirstEdgeInComponent[y];-1===k?this._facetToFirstEdgeInComponent[y]=b:ln.swapEntries(this._edgeToEdgeInComponent,b,k)}for(let b=0;b<M;b++){let k=b+1;for(;k<M&&on.areUndirectedPartners(y[b],y[k]);)ln.swapEntries(this._edgeToPartnerEdge,b,k),k++;if(k>b+2)return!1}return!0}recordFacetInComponent(y,k){const M=this._components[this._components.length-1];this._facetOrientation[y]=k,M.recordOrientation(k)}initializeComponent(y){const k=this._edges.edges[y].facetIndex;this._components.push(new cn(y)),this.recordFacetInComponent(k,1)}pushFacetEdgesOnStack(y,k){ln.extractCyclicIndices(this._edgeToEdgeInComponent,y,this._workArray);for(const M of this._workArray)k.push(M)}doFlood(){const y=[],k=this._edges.edges,M=k.length,b=[];for(let E=0;E<M;E++)if(0===this.edgeIdToFacetOrientation(E)){let M;for(y.length=0,this.initializeComponent(E),this.pushFacetEdgesOnStack(E,y);void 0!==(M=y.pop());){const E=k[M].facetIndex,D=this._facetOrientation[E];ln.extractCyclicIndices(this._edgeToPartnerEdge,M,b);for(const R of b)if(R!==M){const b=k[R].facetIndex,E=this._facetOrientation[b];if(0===E){const E=on.areDirectedPartners(k[M],k[R])?D:-D;this.recordFacetInComponent(b,E),this.pushFacetEdgesOnStack(R,y),ln.swapEntries(this._edgeToEdgeInComponent,M,R)}else if(on.relativeOrientation(k[M],k[R])*D*E>0)return!1}}}return!0}doFacetReversals(){let y=0;for(this._visitor.reset();this._visitor.moveToNextFacet();){const k=this._visitor.currentReadIndex();this._facetOrientation[k]<0&&(y++,this._mesh.reverseSingleFacet(k))}return y}static doFixup(y){const k=new ln(y);if(!k.setupUnoriented())return!1;const M=k.doFlood();return M&&k.doFacetReversals(),M}static swapEntries(y,k,M){const b=y[k];y[k]=y[M],y[M]=b}static extractCyclicIndices(y,k,M){M.length=0;let b=k;do{M.push(b),b=y[b]}while(b!==k)}}class hn{constructor(y,k,M){this.index=y,this.area=k,this.normal=M}addWeightedNormal(y,k){this.area+=y,this.normal.addScaledInPlace(k,y)}divideNormalByArea(){this.normal.scaleInPlace(1/this.area)}}class dn{constructor(y,k,M){this.facetData=y,this.sectorClusterData=void 0,this.sectorIndex=k,this.vertexIndex=M}static cbSectorSort(y,k){return y.sectorIndex-k.sectorIndex}static cbVertexSort(y,k){return y.vertexIndex-k.vertexIndex}static pushToArray(y,k,M,b){y.push(new dn(k,M,b))}}class un{static buildFastAverageNormals(y,k){const M=y.createVisitor(0),b=$.create(0,0,1),E=Q.smallMetricDistanceSquared,D=[];let R=0,X=0;for(;M.moveToNextFacet();){let y=Ur.areaNormalGo(M.point),k=0;y?(k=y.magnitude(),k<E?(y.setFromVector3d(b),k=0):y.scaleInPlace(1/k)):(y=b.clone(),k=0);const z=new hn(R++,k,y);for(let b=0;b<M.pointCount;b++)dn.pushToArray(D,z,X++,M.clientPointIndex(b))}D.sort(((y,k)=>dn.cbVertexSort(y,k)));const z=[];let N=k.radians;N<1e-4&&(N=1e-4);let Y=0;for(let O=0;O<D.length;O++){const y=D[O],k=y.vertexIndex,M=y.facetData;if(void 0===y.sectorClusterData){const b=new hn(Y++,0,$.createZero());z.push(b),b.addWeightedNormal(1,y.facetData.normal);for(let y=O;y<D.length;y++){const E=D[y];if(E.vertexIndex!==k)break;E.facetData.normal.angleTo(M.normal).radians>N||void 0===E.sectorClusterData&&(b.addWeightedNormal(1,E.facetData.normal),E.sectorClusterData=b)}}}D.sort(((y,k)=>dn.cbSectorSort(y,k))),y.data.normalIndex=[],y.data.normal=new nt(D.length);for(const O of z)O.divideNormalByArea(),O.index=y.data.normal.length,y.data.normal.push(O.normal);for(const O of D)y.data.normalIndex.push(O.sectorClusterData.index)}static buildPerFaceNormals(y){const k=y.createVisitor(0),M=$.create(0,0,1),b=$.create(0,0,1),E=new nt(y.faceCount),D=[];for(;k.moveToNextFacet();){const y=E.length;Ur.unitNormal(k.point,M)?E.push(M):E.push(b);for(let M=0;M<k.pointCount;M++)D.push(y)}y.data.normalIndex=D,y.data.normal=E}}function fn(y){return void 0!==y&&y}class gn{constructor(){this.numActiveSectors=0,this.numInactiveSectors=0,this.averageNormal=$.create(),this.radiansSum=0,this.maxDeviationRadiansFromAverage=0}clear(){this.numActiveSectors=0,this.numInactiveSectors=0,this.averageNormal.setZero(),this.radiansSum=0,this.maxDeviationRadiansFromAverage=0}accumulateNormal(y,k,M){if(y.isMaskSet(M))this.numInactiveSectors++;else{const M=us.sectorSweepRadiansXYZ(y,k);this.averageNormal.addScaledInPlace(k,M),this.radiansSum+=M,this.numActiveSectors++}}finishNormalAveraging(){return!!(this.numActiveSectors>0&&this.averageNormal.normalizeInPlace())}recordDeviation(y,k){if(k){const k=this.averageNormal.radiansTo(y);this.maxDeviationRadiansFromAverage=Math.max(Math.abs(this.maxDeviationRadiansFromAverage),k)}}get maxDeviationRadians(){return this.maxDeviationRadiansFromAverage}}function pn(y){void 0!==_n.stringDebugFunction&&(_n.stringDebugFunction(`    Sector xyz    ${y.xyz.x},${y.xyz.y},${y.xyz.z} `),_n.stringDebugFunction(`           normal ${y.normal.x},${y.normal.y},${y.normal.z} `))}class mn{constructor(y,k){this.facetIndex=y,this.facetNormal=k}}class xn{constructor(y,k){this.xyz=k,this.normal=y,this.count=0}static edgeHasLargeExteriorAngleBetweenNormals(y,k,M,b,E=.5*Math.PI){const D=y.edgeTag,R=y.edgeMate.edgeTag;if(void 0!==D&&void 0!==R){y.vectorToFaceSuccessor(k);const X=D.normal.signedRadiansTo(R.normal,k);if(Q.split3WaySign(b,-1,1,1)*X>=E&&($.createAdd2Scaled(D.normal,1,R.normal,1,M),M.normalizeInPlace()))return!0}return!1}static almostEqualNormals(y,k,M=Q.smallAngleRadians){return y.normal.radiansTo(k.normal)<=M}static radiansBetweenNormals(y,k){return y.normal.radiansTo(k.normal)}setOffsetPointAtDistanceAtHalfEdge(y,k){y.getPoint3d(this.xyz),this.xyz.addScaledInPlace(this.normal,k)}static setXYZAtHalfEdge(y,k){const M=y.edgeTag;void 0!==M&&void 0!==k&&M.xyz.set(k.x,k.y,k.z)}setXYAndZ(y){this.xyz.set(y.x,y.y,y.z)}static setNormalAtHalfEdge(y,k,M){const b=y.edgeTag;void 0!==b&&(b.normal.set(k.x,k.y,k.z),void 0!==M&&b.setOffsetPointAtDistanceAtHalfEdge(y,M))}static sweepRadiansAroundNormal(y,k){const M=y.edgeTag,b=y.vertexSuccessor.edgeTag;if(void 0!==M&&void 0!==b)return M.normal.planarRadiansTo(b.normal,k)}static getSectorPointAtHalfEdge(y,k,M){const b=y.edgeTag;return void 0!==b&&(void 0!==k&&k.setFromPoint3d(b.xyz),void 0!==M&&M.push(b.xyz),!0)}static pushXYZ(y,k){const M=k.edgeTag;return void 0!==M&&y.push(M.xyz),M}static accumulateScaledNormalAtHalfEdge(y,k,M){const b=y.edgeTag;void 0!==b&&M.addScaledInPlace(b.normal,k)}}class _n{constructor(y,k,M){this._basePolyface=y,this._baseGraph=k,this._breakMaskA=k.grabMask(),this._breakMaskB=k.grabMask(),this._insideOfChamferFace=k.grabMask(),this._outsideOfChamferFace=k.grabMask(),this._insideChamferSling=k.grabMask(),this._outsideEndOfChamferFace=k.grabMask(),this._exteriorMask=Kr.EXTERIOR,this._offsetCoordinatesReassigned=k.grabMask(),this._smoothRadiansBetweenNormals=M.smoothSingleAngleBetweenNormals.radians,this._chamferTurnRadians=M.chamferAngleBetweenNormals.radians,this._smoothAccumulatedRadiansBetweenNormals=M.smoothAccumulatedAngleBetweenNormals.radians}get exteriorMask(){return this._exteriorMask}get breakMaskA(){return this._breakMaskA}get breakMaskB(){return this._breakMaskB}get insideOfChamferFace(){return this._insideOfChamferFace}get outsideOfChamferFace(){return this._outsideOfChamferFace}get insideChamferSling(){return this._insideChamferSling}get outsideEndOfChamferFace(){return this._outsideEndOfChamferFace}applyFaceNormalOffsetsToSectorData(y){this._baseGraph.announceNodes(((k,M)=>{const b=M.edgeTag;return void 0!==b&&b.setOffsetPointAtDistanceAtHalfEdge(M,y),!0}))}static buildOffsetMeshWithEdgeChamfers(y,k,M,b){const E=this.buildBaseGraph(y);if(void 0!==E){const D=new _n(y,E,b);D.applyFaceNormalOffsetsToSectorData(M),void 0!==_n.graphDebugFunction&&_n.graphDebugFunction("BaseGraph",E,D._breakMaskA,D._breakMaskB);const R=b.outputSelector?b.outputSelector:{outputOffsetsFromFaces:!0,outputOffsetsFromEdges:!0,outputOffsetsFromVertices:!0};fn(R.outputOffsetsFromFacesBeforeChamfers)&&D.announceFacetsWithSectorCoordinatesAroundFaces(k),D.addChamferTopologyToAllEdges(b,M),D.computeOffsetFacetIntersections(M),void 0!==_n.graphDebugFunction&&_n.graphDebugFunction("after computeEdgeChamfers",E,D._breakMaskA,D._breakMaskB),fn(R.outputOffsetsFromFaces)&&D.announceFacetsWithSectorCoordinatesAroundFaces(k),fn(R.outputOffsetsFromEdges)&&D.announceFacetsWithSectorCoordinatesAroundEdges(k),fn(R.outputOffsetsFromVertices)&&D.announceFacetsWithSectorCoordinatesAroundVertices(k)}}announceSimpleOffsetFromFaces(y,k){const M=new nt,b=j.create(),E=$.create(),r=y=>(y.getPoint3d(b),b.addInPlace(E),M.push(b),0);this._baseGraph.announceFaceLoops(((b,D)=>{if(!D.isMaskSet(Kr.EXTERIOR)){const b=D.faceTag;E.setFromVector3d(b.facetNormal.direction),E.scaleInPlace(k),M.length=0,D.sumAroundFace(r),y.addPolygonGrowableXYZArray(M)}return!0}))}announceFacetsWithSectorCoordinatesAroundFaces(y){const k=new nt,i=y=>{const M=y.edgeTag;return void 0!==M&&k.push(M.xyz),0};this._baseGraph.announceFaceLoops(((M,b)=>(b.isMaskSet(Kr.EXTERIOR)||(k.length=0,b.sumAroundFace(i),k.length>2&&y.addPolygonGrowableXYZArray(k)),!0)))}countBits(y){let k=0,M=y;for(;0!==M;)1&M&&k++,M>>=1;return k}announceFacetsWithSectorCoordinatesAroundEdges(y){const k=new nt,M=Q.smallMetricDistance,b=this._exteriorMask|this._outsideEndOfChamferFace|this._outsideOfChamferFace|this._insideOfChamferFace|this._insideChamferSling;this._baseGraph.announceEdges(((E,D)=>{if(void 0!==D.findMaskAroundEdge(this._exteriorMask))return!0;if(D.isMaskSet(b))return!0;{const E=D.faceSuccessor,R=D.edgeMate;if(!R.isMaskSet(b)){const b=R.faceSuccessor;k.clear(),xn.getSectorPointAtHalfEdge(D,void 0,k),xn.getSectorPointAtHalfEdge(E,void 0,k),xn.getSectorPointAtHalfEdge(R,void 0,k),xn.getSectorPointAtHalfEdge(b,void 0,k),ki.compressInPlaceByShortEdgeLength(k,M),k.length>2&&y.addPolygonGrowableXYZArray(k)}}return!0}))}getCoordinateString(y,k=!0,M=!1){return k?M?`${us.nodeToIdXYZString(y)} ==> ${us.nodeToIdXYZString(y.faceSuccessor)}`:`${us.nodeToIdXYZString(y)}`:M?`==> ${us.nodeToIdXYZString(y.faceSuccessor)}`:""}inspectMasks(y,k=!0,M=!1){return"[".concat(y.id.toString(),y.isMaskSet(this._exteriorMask)?"X":"",y.isMaskSet(this.breakMaskA)?"A":"",y.isMaskSet(this.breakMaskB)?"B":"",y.isMaskSet(this.insideChamferSling)?"(sling)":"",y.isMaskSet(this.insideOfChamferFace)?"(in chamfer)":"",y.isMaskSet(this.outsideEndOfChamferFace)?"(@sling)":"",y.isMaskSet(this.outsideOfChamferFace)?"(@chamfer)":"",this.getCoordinateString(y,k,M),"]")}announceFacetsWithSectorCoordinatesAroundVertices(y){const k=new nt,M=Q.smallMetricDistance;this._baseGraph.announceVertexLoops(((b,E)=>(E.findMaskAroundVertex(this._exteriorMask)||(k.length=0,E.sumAroundVertex((y=>(y.isMaskSet(this._insideChamferSling)||xn.getSectorPointAtHalfEdge(y,void 0,k),0))),ki.compressInPlaceByShortEdgeLength(k,M),k.length>2&&y.addPolygonGrowableXYZArray(k)),!0)))}static buildBaseGraph(y){const k=new Ks,M=y.createVisitor(),b=j.create(),E=j.create();for(M.reset();M.moveToNextFacet();){const D=Ur.centroidAreaNormal(M.point);if(void 0!==D){const R=k.insertLoop(M.pointIndex,(k=>{const M=k.edgeMate;y.data.getPoint(k.i,b),k.setXYZ(b),y.data.getPoint(M.i,E),M.setXYZ(E)})),X=new mn(M.currentReadIndex(),D);void 0!==R&&R.sumAroundFace((y=>(y.faceTag=X,y.edgeTag=new xn(D.direction.clone(),y.getPoint3d()),0)))}}return k.graph}setOffsetAtDistanceAroundVertex(y,k,M=!1){y.sumAroundVertex((b=>{const E=b.edgeTag;return void 0!==E&&(M&&this.isInsideChamferOrSling(y)||E.setOffsetPointAtDistanceAtHalfEdge(b,k)),0}))}setOffsetXYAndZAroundVertex(y,k){y.sumAroundVertex((y=>{const M=y.edgeTag;return void 0!==M&&(M.setXYAndZ(k),y.setMask(this._offsetCoordinatesReassigned)),0}))}announceNodeAndSectorPropertiesInSmoothSector(y,k){let M=0;for(let b=y;;b=b.vertexSuccessor){const E=b.edgeTag;if(void 0!==E&&(k(b,E),M++),b.isMaskSet(this._breakMaskB))return M;if(b.isMaskSet(this._exteriorMask))return M;if(b===y&&0===M)return M}}computeAverageNormalAndMaxDeviationAroundVertex(y,k){k.clear();const M=this._exteriorMask|this._insideChamferSling;if(y.sumAroundVertex((y=>{const b=y.edgeTag;return b&&k.accumulateNormal(y,b.normal,M),0})),k.finishNormalAveraging())return y.sumAroundVertex((y=>{const b=y.edgeTag;return b&&k.recordDeviation(b.normal,!y.isMaskSet(M)),0})),k.maxDeviationRadians}assignOffsetByAverageNormalAroundVertex(y,k,M,b){const E=this.computeAverageNormalAndMaxDeviationAroundVertex(y,M);return _n.stringDebugFunction&&(_n.stringDebugFunction(`XYZ ${us.nodeToIdXYZString(y)} Average Normal ${JSON.stringify(M.averageNormal.toJSON())}`),_n.stringDebugFunction(`           angle ratio ${M.radiansSum/(2*Math.PI)}   maxDeviation ${M.maxDeviationRadiansFromAverage}`)),void 0!==E&&E<=k&&(y.sumAroundVertex((y=>(xn.setNormalAtHalfEdge(y,M.averageNormal,b),0))),!0)}markBreakEdgesAndSaveAverageNormalsAroundVertex(y){y.clearMaskAroundVertex(this._breakMaskA),y.clearMaskAroundVertex(this._breakMaskB);const k=this._smoothRadiansBetweenNormals,M=this._smoothAccumulatedRadiansBetweenNormals;let b=0,E=y,D=0;do{const y=E.edgeMate,M=y.faceSuccessor;E.isMaskSet(this._exteriorMask)?y.isMaskSet(this._exteriorMask)||(M.setMask(this._breakMaskB),b++):E.isMaskSet(this._outsideOfChamferFace)?E.setMask(this._breakMaskA):E.isMaskSet(this._outsideEndOfChamferFace)?(E.setMask(this._breakMaskA),E.setMask(this._breakMaskB)):E.isMaskSet(this._insideChamferSling)||(E.isMaskSet(this._insideOfChamferFace)?(E.setMask(this._breakMaskA),E.setMask(this._breakMaskB),M.setMask(this._breakMaskB)):y.isMaskSet(this._exteriorMask)?(b++,E.setMask(this._breakMaskA)):xn.almostEqualNormals(E.edgeTag,M.edgeTag,k)?D++:(E.setMask(this._breakMaskA),b++,M.setMask(this._breakMaskB))),E=E.vertexSuccessor}while(E!==y);void 0!==_n.stringDebugFunction&&_n.stringDebugFunction(`   numSkip   ${D} `),0===b&&(y.setMask(this._breakMaskA),y.vertexPredecessor.setMask(this._breakMaskB),b=1);const R=E.findMaskAroundVertex(this._breakMaskA);if(void 0!==R){E=R;do{if(E.isMaskSet(this._breakMaskA)&&!E.isMaskSet(this._breakMaskB)){let y=0;do{const k=E.vertexSuccessor;y+=xn.radiansBetweenNormals(E.edgeTag,k.edgeTag),y>M&&(E.setMask(this._breakMaskB),k.setMask(this._breakMaskA),b++,y=0),E=k}while(!E.isMaskSet(this._breakMaskB))}else E=E.vertexSuccessor}while(E!==R)}if(b>0&&void 0!==R){E=R;const y=$.create(),k=$.create(),M=$.create();y.setZero();do{if(E.isMaskSet(this._breakMaskA)&&!E.isMaskSet(this._breakMaskB)){let b=E;for(y.setZero();;){b.vectorToFaceSuccessor(k),b.vectorToFacePredecessor(M);let E=k.signedRadiansTo(M,b.faceTag.facetNormal.direction);if(E<0&&(E+=2*Math.PI),xn.accumulateScaledNormalAtHalfEdge(b,E,y),b.isMaskSet(this._breakMaskB))break;b=b.vertexSuccessor}if(y.normalizeInPlace())for(b=E;xn.setNormalAtHalfEdge(b,y),!b.isMaskSet(this._breakMaskB);)b=b.vertexSuccessor}E=E.vertexSuccessor}while(E!==R)}}compute3SectorIntersection(y,k,M,b){const E=y.edgeTag,D=k.edgeTag,R=M.edgeTag;return Mt.intersect3Planes(E.xyz,E.normal,D.xyz,D.normal,R.xyz,R.normal,b)}compute3SectorIntersectionDebug(y,k,M,b){const E=y.edgeTag,D=k.edgeTag,R=M.edgeTag;if(void 0!==_n.stringDebugFunction){_n.stringDebugFunction(`compute3${this.inspectMasks(y)}${this.inspectMasks(k)}${this.inspectMasks(M)} `);for(const y of[E,D,R])pn(y)}const X=Mt.intersect3Planes(E.xyz,E.normal,D.xyz,D.normal,R.xyz,R.normal,b);return void 0!==_n.stringDebugFunction&&(void 0===X?_n.stringDebugFunction(" NO INTERSECTION"):_n.stringDebugFunction(` ComputedVector ${X.x},${X.y},${X.z} `)),X}compute2SectorIntersection(y,k,M){const b=y.edgeTag,E=k.edgeTag,D=b.normal.crossProduct(E.normal);return Mt.intersect3Planes(b.xyz,b.normal,E.xyz,E.normal,E.xyz,D,M)}addChamferTopologyToAllEdges(y,k){const M=[],b=y.chamferAngleBetweenNormals.radians,E=j.create(),D=$.create(),R=$.create(),X=$.create();this._baseGraph.announceEdges(((y,E)=>!xn.edgeHasLargeExteriorAngleBetweenNormals(E,D,X,k,b)||(M.push(E),!0)));for(const z of M)if(xn.edgeHasLargeExteriorAngleBetweenNormals(z,D,X,b)){const y=this._baseGraph.splitEdgeCreateSliverFace(z),M=y.facePredecessor,b=y.getPoint3d();b.addScaledInPlace(X,k);const N=bt.createCapture(b,X.clone()),Y=new mn(-1,N);let O=-1;for(const k of[y,M]){D.scale(O,R),k.getPoint3d(E),k.setMask(this._insideOfChamferFace),k.edgeMate.setMask(this._outsideOfChamferFace),k.faceTag=Y;const y=this._baseGraph.splitEdge(void 0,E.x,E.y,E.z,k.i),M=y.edgeMate;y.setMask(this._outsideEndOfChamferFace),y.faceTag=Y,M.setMask(this._insideChamferSling),us.pinch(k,y);const z=bt.create(E,R),N=new mn(-1,z);M.faceTag=N,k.edgeTag=new xn(X.clone(),b.clone()),y.edgeTag=new xn(X.clone(),b.clone()),M.edgeTag=new xn(R.clone(),E.clone());const B=this.compute3SectorIntersection(k,k.edgeMate,M),V=this.compute3SectorIntersection(y,y.vertexSuccessor,M);xn.setXYZAtHalfEdge(k,B),xn.setXYZAtHalfEdge(y,V),O*=-1}}}computeOffsetFacetIntersections(y){void 0!==_n.stringDebugFunction&&_n.stringDebugFunction("*****                                 recompute intersections");const k=[],M=j.create(),b=j.create(),E=2*y,D=new gn,R=W.degreesToRadians(25);this._baseGraph.announceVertexLoops(((X,z)=>{let N=z.findMaskAroundVertex(this._outsideEndOfChamferFace);if(void 0===N&&(N=z.findMaskAroundVertex(this._breakMaskA)),void 0===N&&(N=z),void 0!==_n.stringDebugFunction&&(_n.stringDebugFunction(""),_n.stringDebugFunction(` VERTEX LOOP   ${JSON.stringify(N.getPoint3d().toJSON())} `),N.sumAroundVertex((y=>(_n.stringDebugFunction(this.inspectMasks(y,!1,!0)),0)))),this.assignOffsetByAverageNormalAroundVertex(N,R,D,y))return!0;if(this.markBreakEdgesAndSaveAverageNormalsAroundVertex(N),this.setOffsetAtDistanceAroundVertex(N,y,!0),N.collectMaskedEdgesAroundVertex(this._breakMaskA,!0,k),void 0!==_n.stringDebugFunction){_n.stringDebugFunction(` BREAK EDGES from ${this.inspectMasks(N,!0,!1)}`);for(const y of k)_n.stringDebugFunction(this.inspectMasks(y,!1,!0))}if(k.length<=1);else if(2===k.length){const y=this.compute2SectorIntersection(k[0],k[1]);void 0!==y&&this.setOffsetXYAndZAroundVertex(N,y)}else if(3===k.length){void 0!==_n.stringDebugFunction&&_n.stringDebugFunction(` Vertex Update just ${k.length} `);const y=this.compute3SectorIntersection(k[0],k[1],k[2]);void 0!==y&&this.setOffsetXYAndZAroundVertex(N,y)}else{void 0!==_n.stringDebugFunction&&_n.stringDebugFunction(` Vertex Update breakEdges ${k.length} `),N.getPoint3d(M);for(let y=0;y<k.length;y++){const M=y,b=(M+1)%k.length,E=(b+1)%k.length;if(k[M].isMaskSet(this._outsideEndOfChamferFace)&&k[b].isMaskSet(this._outsideOfChamferFace)&&k[E].isMaskSet(this._insideOfChamferFace)){void 0!==_n.stringDebugFunction&&_n.stringDebugFunction(`    ChamferChamfer Fixup ${this.inspectMasks(k[M])} ${this.inspectMasks(k[b])} ${this.inspectMasks(k[E])} `);const D=this.compute3SectorIntersection(k[M],k[b],k[E]);if(void 0!==D){for(const y of[M,b,E])this.announceNodeAndSectorPropertiesInSmoothSector(k[y],((y,k)=>{k.setXYAndZ(D),y.setMask(this._offsetCoordinatesReassigned)}));y+=2}}}for(let y=0;y<k.length;y++){const M=y,E=(M+1)%k.length;this.isInsideSling(k[M],k[E])||(!this.isOffsetAssigned(k[M])&&k[E].isMaskSet(this.insideOfChamferFace)?this.transferXYZFromNodeToSmoothSector(k[E],k[M],"push left from chamfer",b):!this.isOffsetAssigned(k[E])&&k[M].isMaskSet(this.outsideEndOfChamferFace)&&this.transferXYZFromNodeToSmoothSector(k[M],k[E],"push right from chamfer",b))}for(let y=0;y<k.length;y++){const b=y,D=(b+1)%k.length,R=(D+1)%k.length;if(this.isInsideSling(k[b],k[D],k[R]))continue;if(this.isOffsetAssigned(k[D]))continue;void 0!==_n.stringDebugFunction&&_n.stringDebugFunction(`    Intersection Fixup ${this.inspectMasks(k[b])} ${this.inspectMasks(k[D])} ${this.inspectMasks(k[R])} `);const X=this.compute3SectorIntersection(k[b],k[D],k[R]);void 0!==X&&M.distance(X)<E&&this.announceNodeAndSectorPropertiesInSmoothSector(k[D],((y,k)=>{k.setXYAndZ(X),y.setMask(this._offsetCoordinatesReassigned)}))}}if(void 0!==_n.stringDebugFunction){const y=N.countMaskAroundVertex(this._offsetCoordinatesReassigned,!1),k=`   **** Vertex offset mask counts(TRUE ${N.countMaskAroundVertex(this._offsetCoordinatesReassigned,!0)})(FALSE ${y})`;_n.stringDebugFunction(k)}return!0}))}isInsideSling(y,k,M){return y.isMaskSet(this._insideChamferSling)||void 0!==k&&k.isMaskSet(this._insideChamferSling)||void 0!==M&&M.isMaskSet(this._insideChamferSling)}isInsideChamferOrSling(y){return y.isMaskSet(this._insideChamferSling)||y.isMaskSet(this._insideOfChamferFace)||y.isMaskSet(this._outsideEndOfChamferFace)}isOffsetAssigned(y,k,M){return y.isMaskSet(this._offsetCoordinatesReassigned)||void 0!==k&&k.isMaskSet(this._offsetCoordinatesReassigned)||void 0!==M&&M.isMaskSet(this._offsetCoordinatesReassigned)}transferXYZFromNodeToSmoothSector(y,k,M,b){void 0!==_n.stringDebugFunction&&_n.stringDebugFunction(`    ${M} ${this.inspectMasks(y)} to ${this.inspectMasks(k)}} `),xn.getSectorPointAtHalfEdge(y,b,void 0),this.announceNodeAndSectorPropertiesInSmoothSector(k,((y,k)=>{k.setXYAndZ(b),y.setMask(this._offsetCoordinatesReassigned)}))}}class yn{constructor(y){this._segmentPoint0=j.create(),this._segmentPoint1=j.create(),this._localSegmentPoint0=j.create(),this._localSegmentPoint1=j.create(),this._clipFractions=Re.create(0,1),this._localFrame=pt.createIdentity(),this._polygonRange=ut.create(),this._spacePoints=y,this._spacePointsRange=new ut,y.setRange(this._spacePointsRange),this._numSpacePoints=this._spacePoints.length}static create(y){if(y.length>1)return new yn(y.clone())}projectToPolygon(y,k,M,b){y.setRange(this._polygonRange);let E=0;if(!this._polygonRange.intersectsRangeXY(this._spacePointsRange))return E;for(let D=1;D+1<y.length;D++){E++;const R=y.fillLocalXYTriangleFrame(0,D,D+1,this._localFrame);if(R)for(let y=1;y<this._numSpacePoints;y++)if(E++,this._spacePoints.getPoint3dAtCheckedPointIndex(y-1,this._segmentPoint0),this._spacePoints.getPoint3dAtCheckedPointIndex(y,this._segmentPoint1),R.multiplyInversePoint3d(this._segmentPoint0,this._localSegmentPoint0),R.multiplyInversePoint3d(this._segmentPoint1,this._localSegmentPoint1),this._clipFractions.set(0,1),this._clipFractions.clipBy01FunctionValuesPositive(this._localSegmentPoint0.x,this._localSegmentPoint1.x)&&this._clipFractions.clipBy01FunctionValuesPositive(this._localSegmentPoint0.y,this._localSegmentPoint1.y)&&this._clipFractions.clipBy01FunctionValuesPositive(1-this._localSegmentPoint0.x-this._localSegmentPoint0.y,1-this._localSegmentPoint1.x-this._localSegmentPoint1.y)){E++;const D=this._localSegmentPoint0.interpolate(this._clipFractions.x0,this._localSegmentPoint1),R=this._localSegmentPoint0.interpolate(this._clipFractions.x1,this._localSegmentPoint1),X=this._localFrame.multiplyPoint3d(D),z=this._localFrame.multiplyPoint3d(R),N=this._localFrame.multiplyXYZ(D.x,D.y,0),Y=this._localFrame.multiplyXYZ(R.x,R.y,0),O=Q.inverseInterpolate01(this._localSegmentPoint0.z,this._localSegmentPoint1.z);if(void 0!==O&&O>this._clipFractions.x0&&O<this._clipFractions.x1){E++;const D=this._segmentPoint0.interpolate(O,this._segmentPoint1),R=D.clone();k(this._spacePoints,y-1,M,b,[X,D,N],2,1),k(this._spacePoints,y-1,M,b,[z,R,Y],1,2)}else this._localSegmentPoint0.z>0?k(this._spacePoints,y-1,M,b,[X,z,Y,N],3,2):k(this._spacePoints,y-1,M,b,[z,X,N,Y],2,3)}}return E}}class vn{constructor(y,k){this.edgePlane=y,this.clip=k,this._crossingPoints=[]}static createPointPointSweep(y,k,M){const b=$.createStartEnd(y,k),E=b.fractionOfProjectionToVector(M),D=b.plusScaled(M,-E),R=Wr.createNormalAndPoint(D,y),X=Wr.createNormalAndPoint(D,k),z=Wr.createOriginAndVectors(y,b,M);if(void 0!==R&&void 0!==X&&void 0!==z){X.negateInPlace();const y=kn.createPlanes([R,X]);return new vn(z,y)}}processPolygon(y,k){this._crossingPoints.length=0,Array.isArray(y)?qr.polygonPlaneCrossings(this.edgePlane,y,this._crossingPoints):Zr.polygonPlaneCrossings(this.edgePlane,y,this._crossingPoints),2===this._crossingPoints.length&&this.clip.announceClippedSegmentIntervals(0,1,this._crossingPoints[0],this._crossingPoints[1],((y,M)=>{k(this._crossingPoints[0].interpolate(y,this._crossingPoints[1]),this._crossingPoints[0].interpolate(M,this._crossingPoints[1]))}))}}class Pn{constructor(y,k){this._edgeClippers=y,void 0!==k&&(this._localToWorld=k.localToWorld,this._worldToLocal=k.worldToLocal,this._localRange=k.localRange)}static create(y,k){if(void 0===k&&(k=$.create(0,0,1)),y.length>1){const M=j.createZero(),b=j.createZero(),E=[];y.getPoint3dAtUncheckedPointIndex(0,M);let D=xt.createRigidHeadsUp(k);void 0===D&&(D=xt.createIdentity());const R=pt.createOriginAndMatrix(M,D),X=R.inverse(),z=y.getRange(X);for(let N=1;N<y.length;N++){y.getPoint3dAtUncheckedPointIndex(N,b);const D=vn.createPointPointSweep(M,b,k);void 0!==D&&(M.setFrom(b),E.push(D))}return new Pn(E,{localToWorld:R,worldToLocal:X,localRange:z})}}processPolygon(y,k){if(void 0===this._worldToLocal||void 0===this._localRange||ut.createTransformedArray(this._worldToLocal,y).intersectsRangeXY(this._localRange))for(const M of this._edgeClippers)M.processPolygon(y,k)}}class An{constructor(y,k,M){this._range=y,this._numXEdge=Math.max(k,1),this._numYEdge=Math.max(M,1),this._data=[];for(let b=0;b<M;b++){const y=[];for(let M=0;M<k;M++)y.push(void 0);this._data.push(y)}}get numXEdge(){return this._numXEdge}get numYEdge(){return this._numYEdge}xIndex(y){const k=(y-this._range.low.x)/(this._range.high.x-this._range.low.x),M=Math.floor(k*this._numXEdge);return M<0?0:M>this._numXEdge-1?this._numXEdge-1:M}yIndex(y){const k=(y-this._range.low.y)/(this._range.high.y-this._range.low.y),M=Math.floor(k*this._numYEdge);return M<0?0:M>this._numYEdge-1?this._numYEdge-1:M}static createWithEstimatedCounts(y,k,M){if(y.low.x>=y.high.x||y.low.y>=y.high.y)return;const b=gt.createXYXY(y.low.x,y.low.y,y.high.x,y.high.y),E=b.xLength(),D=b.yLength();let R,X;return D>E?(X=Math.ceil(Math.sqrt(D*k/(M*E))),R=Math.ceil(k/X)):(R=Math.ceil(Math.sqrt(E*k/(M*D))),X=Math.ceil(k/(R*M))),new An(b,R,X)}addDataAtXY(y,k,M){const b=this.xIndex(y),E=this.yIndex(k);let D=this._data[E][b];D||(D=[],this._data[E][b]=D),D.push(M)}getDataAtXY(y,k){const M=this.xIndex(y),b=this.yIndex(k);return this._data[b][M]}getDataAtIndex(y,k){if(!(y<0||y>=this._numXEdge||k<0||k>=this._numYEdge))return this._data[k][y]}isValidIndex(y,k){return!(y<0||y>=this._numXEdge||k<0||k>=this._numYEdge)}}class In{get indexGrid(){return this._buckets}constructor(y,k){this._points=y,this._buckets=k}static create(y,k){const M=y.length;if(y.length<1)return;const b=y.getRange();b.expandInPlace(1e3*Q.smallMetricDistance);const E=An.createWithEstimatedCounts(b,y.length,k);if(void 0===E)return;const D=new In(y,E),R=j.create();for(let X=0;X<M;X++)y.getPoint3dAtUncheckedPointIndex(X,R),E.addDataAtXY(R.x,R.y,X);return D}announcePointsInRange(y,k){const M=this._buckets.xIndex(y.low.x),b=this._buckets.xIndex(y.high.x),E=this._buckets.yIndex(y.low.y),D=this._buckets.yIndex(y.high.y),R=this._points.length;for(let X=M;X<=b;X++)for(let M=E;M<=D;M++){const b=this._buckets.getDataAtIndex(X,M);if(void 0!==b)for(const M of b)if(M<R){const b=this._points.getXAtUncheckedPointIndex(M),E=this._points.getYAtUncheckedPointIndex(M),D=this._points.getZAtUncheckedPointIndex(M);if(y.containsXY(b,E)&&!k(M,b,E,D))return}}}}class Sn{constructor(y=0){this._minMax=ft.createNull(),this._count=this._sumX=this._sumXX=0,this._origin=y}get count(){return this._count}get mean(){return this._count>0?this._sumX/this._count:0}get meanSquare(){return this._count>0?this._sumXX/this._count:0}get minMax(){return this._minMax.clone()}get standardDeviation(){if(this._count<1)return 0;const y=this.mean,k=this._sumXX,M=this._sumX;return Math.sqrt((k-2*y*M+this._count*y*y)/this._count)}clearSums(){this._count=this._sumX=this._sumXX=0,this._minMax.setNull()}get origin(){return this._origin}setOrigin(y){this._origin=y}shiftOriginAndSums(y){const k=y-this._origin;this._origin=y,this._sumXX=this._sumXX-2*k*this._sumX+this._count*k*k,this._sumX=this._sumX-this._count*k,this._minMax.cloneTranslated(-k,this._minMax)}accumulate(y){y-=this._origin,this._count+=1,this._sumX+=y,this._sumXX+=y*y,this._minMax.extendX(y)}accumulateArray(y){for(const k of y)this.accumulate(k)}clone(y){return y||(y=new Sn),this._minMax.clone(y._minMax),y._count=this._count,y._origin=this._origin,y._sumX=this._sumX,y._sumXX=this._sumXX,y}isAlmostEqual(y){return Q.isAlmostEqualNumber(this._sumX,y._sumX)&&Q.isAlmostEqualNumber(this._sumXX,y._sumXX)&&Q.isAlmostEqualNumber(this._origin,y._origin)&&this._count===y._count&&this._minMax.isAlmostEqual(y._minMax)}}class wn{constructor(){this.range=ut.createNull(),this.xSums=new Sn,this.ySums=new Sn,this.zSums=new Sn,this._workRange=ut.createNull()}accumulateGrowableXYZArrayRange(y){y.setRange(this._workRange),this.range.extendRange(this._workRange),this.xSums.accumulate(this._workRange.xLength()),this.ySums.accumulate(this._workRange.yLength()),this.zSums.accumulate(this._workRange.zLength())}}class Cn{constructor(y,k,M,b,E,D){this.vectorToEye=y,this.sideAngle=k,this.assembleChains=M,this.collectOnForwardFacets=b,this.collectOnSideFacets=E,this.collectOnRearFacets=D}static create(y,k,M,b,E,D){return new Cn(void 0===y?$.unitZ():y.clone(),void 0===k?W.createRadians(Q.smallAngleRadians):k.clone(),Q.resolveValue(M,!0),Q.resolveValue(b,!0),Q.resolveValue(E,!0),Q.resolveValue(D,!0))}get collectAll(){return!0===this.collectOnForwardFacets&&!0===this.collectOnSideFacets&&!0===this.collectOnRearFacets}collectFromThisFacetNormal(y){return void 0!==y&&(y.angleFromPerpendicular(this.vectorToEye).isMagnitudeLessThanOrEqual(this.sideAngle)?this.collectOnSideFacets:y.dotProduct(this.vectorToEye)>0?this.collectOnForwardFacets:this.collectOnRearFacets)}}class Tn{constructor(y=W.createDegrees(25),k=W.createDegrees(60),M=W.createDegrees(90)){this.smoothSingleAngleBetweenNormals=y.clone(),this.smoothAccumulatedAngleBetweenNormals=k.clone(),this.chamferAngleBetweenNormals=M.clone()}static create(y=W.createDegrees(25),k=W.createDegrees(60),M=W.createDegrees(120)){const b=y.clone(),E=k.clone(),D=M.clone();return b.degrees<1&&E.setDegrees(1),E.degrees<1&&E.setDegrees(1),E.degrees<15&&E.setDegrees(15),new Tn(b,E,D)}}!function(y){y[y.SelectNone=0]="SelectNone",y[y.SelectAny=1]="SelectAny",y[y.SelectAll=2]="SelectAll",y[y.SelectOneByParity=3]="SelectOneByParity"}(Io||(Io={}));class Fn{static visitorToLoop(y){const k=Me.createPoints(y.point.getPoint3dArray());return hi.create(k)}static indexedPolyfaceToLoops(y){const k=ri.create(),M=y.createVisitor(1);for(;M.moveToNextFacet();){const y=Fn.visitorToLoop(M);k.tryAddChild(y)}return k}static sumFacetAreas(y,k){let M=0;if(void 0!==y){if(y instanceof Ki)return Fn.sumFacetAreas(y.createVisitor(1),k);let b;for(void 0!==k&&(b=k.normalize()),y.reset();y.moveToNextFacet();){const k=Ur.areaNormal(y.point.getPoint3dArray());M+=b?k.dotProduct(b):k.magnitude()}}return M}static sumTetrahedralVolumes(y,k){let M=0;if(y instanceof Ki)return Fn.sumTetrahedralVolumes(y.createVisitor(0),k);let b=k;const E=j.create(),D=j.create(),R=j.create();for(y.reset();y.moveToNextFacet();){void 0===b&&(b=y.point.getPoint3dAtUncheckedPointIndex(0)),y.point.getPoint3dAtUncheckedPointIndex(0,E);for(let k=1;k+1<y.point.length;k++)y.point.getPoint3dAtUncheckedPointIndex(k,D),y.point.getPoint3dAtUncheckedPointIndex(k+1,R),M+=b.tripleProductToPoints(E,D,R)}return M/6}static sumVolumeBetweenFacetsAndPlane(y,k){if(y instanceof Ki)return Fn.sumVolumeBetweenFacetsAndPlane(y.createVisitor(0),k);const M=j.create(),b=j.create(),E=j.create(),D=$.create(),R=k.getNormalRef();let X,z,N,Y,O,B=0;const V=Ei.create(void 0,!0),U=Ei.create(void 0,!0),L=Xt.createZero(),Z=k.getProjectionToPlane();for(y.reset();y.moveToNextFacet();){y.point.getPoint3dAtUncheckedPointIndex(0,M),X=k.altitude(M),O=0;for(let V=1;V+1<y.point.length;V++)y.point.getPoint3dAtUncheckedPointIndex(V,b),y.point.getPoint3dAtUncheckedPointIndex(V+1,E),M.crossProductToPoints(b,E,D),z=k.altitude(b),N=k.altitude(E),Y=R.dotProduct(D),O+=Y,B+=Y*(X+z+N);L.setZero(),y.point.multiplyTransformInPlace(Z),Ur.addSecondMomentAreaProducts(y.point,M,L),O>0?V.accumulateProductsFromOrigin(M,L,1):U.accumulateProductsFromOrigin(M,L,1)}return V.shiftOriginAndSumsToCentroidOfSums(),U.shiftOriginAndSumsToCentroidOfSums(),{volume:B/6,positiveProjectedFacetAreaMoments:Ei.inertiaProductsToPrincipalAxes(V.origin,V.sums),negativeProjectedFacetAreaMoments:Ei.inertiaProductsToPrincipalAxes(U.origin,U.sums)}}static sumFacetSecondAreaMomentProducts(y,k){if(y instanceof Ki)return Fn.sumFacetSecondAreaMomentProducts(y.createVisitor(0),k);const M=Xt.createZero();for(y.reset();y.moveToNextFacet();)Ur.addSecondMomentAreaProducts(y.point,k,M);return M}static sumFacetSecondVolumeMomentProducts(y,k){if(y instanceof Ki)return Fn.sumFacetSecondVolumeMomentProducts(y.createVisitor(0),k);const M=Xt.createZero();for(y.reset();y.moveToNextFacet();)Ur.addSecondMomentVolumeProducts(y.point,k,M);return M}static computePrincipalAreaMoments(y){const k=y.data.getPoint(0);if(!k)return;const M=Fn.sumFacetSecondAreaMomentProducts(y,k);return Ei.inertiaProductsToPrincipalAxes(k,M)}static computePrincipalVolumeMoments(y){const k=y.data.getPoint(0);if(!k)return;const M=Fn.sumFacetSecondVolumeMomentProducts(y,k);return Ei.inertiaProductsToPrincipalAxes(k,M)}static areFacetsConvex(y){if(y instanceof Ki)return this.areFacetsConvex(y.createVisitor(0));for(y.setNumWrap(0),y.reset();y.moveToNextFacet();)if(y.pointCount>3&&!Ur.isConvex(y.point))return!1;return!0}static dihedralAngleSummary(y,k=!1){const M=new an,b=y.createVisitor(1);b.reset();const E=[];let D=0;for(;b.moveToNextFacet();){const y=b.pointCount-1,k=Ur.centroidAreaNormal(b.point);if(void 0===k)return-2;E.push(k);for(let E=0;E<y;E++)M.addEdge(b.clientPointIndex(E),b.clientPointIndex(E+1),D);D++}const R=[],X=[];if(M.sortAndCollectClusters(X,k?void 0:R,void 0,R),R.length>0)return-2;let z=0,N=0,Y=0;const O=$.create();for(const B of X){const k=B[0],M=B[1];if(k instanceof on&&M instanceof on&&y.data.point.vectorIndexIndex(k.vertexIndexA,k.vertexIndexB,O)){const y=E[k.facetIndex].direction.signedAngleTo(E[M.facetIndex].direction,O);y.isAlmostZero?N++:y.radians>0?z++:Y++}}return z>0&&0===Y?1:Y>0&&0===z?-1:N>0&&0===z&&0===Y?0:-2}static isConvexByDihedralAngleCount(y,k=!1){return this.dihedralAngleSummary(y,k)>0}static isPolyfaceManifold(y,k=!1){const M=new an,b=y.createVisitor(1);for(b.reset();b.moveToNextFacet();){const y=b.pointCount-1;for(let k=0;k<y;k++)M.addEdge(b.clientPointIndex(k),b.clientPointIndex(k+1),b.currentReadIndex())}const E=[];return M.sortAndCollectClusters(void 0,k?void 0:E,void 0,E),0===E.length}static isPolyfaceClosedByEdgePairing(y){return this.isPolyfaceManifold(y,!1)}static announceBoundaryEdges(y,k,M=!0,b=!0,E=!0){if(void 0===y||!M&&!b&&!E)return;const D=new an,R=y instanceof Ki?y.createVisitor(1):y;for(R.setNumWrap(1),R.reset();R.moveToNextFacet();){const y=R.pointCount-1;for(let k=0;k<y;k++)D.addEdge(R.clientPointIndex(k),R.clientPointIndex(k+1),R.currentReadIndex())}const X=[];if(D.sortAndCollectClusters(void 0,M?X:void 0,E?X:void 0,b?X:void 0),0===X.length)return;const z=R.clientPolyface(),N=j.create(),Y=j.create();for(const O of X){const y=O instanceof on?O:O[0],M=y.vertexIndexA,b=y.vertexIndexB;z.data.getPoint(M,N)&&z.data.getPoint(b,Y)&&k(N,Y,M,b,y.facetIndex)}}static boundaryEdges(y,k=!0,M=!0,b=!0){const E=new ri;if(Fn.announceBoundaryEdges(y,((y,k,M,b,D)=>{E.tryAddChild(Ce.create(y,k))}),k,M,b),0!==E.children.length)return E}static collectBoundaryEdges(y,k=!0,M=!0,b=!0){const E=new ss(Q.smallMetricDistance,Q.smallMetricDistance);return Fn.announceBoundaryEdges(y,((y,k)=>E.captureCurve(Ce.create(y,k))),k,M,b),E.grabResult(!0)}static createIndexedEdges(y){if(y instanceof Ki)return this.createIndexedEdges(y.createVisitor(1));const k=new an;for(y.reset();y.moveToNextFacet();){const M=y.pointCount-1;for(let b=0;b<M;b++)k.addEdge(y.clientPointIndex(b),y.clientPointIndex(b+1),y.currentReadIndex())}return k}static announceSilhouetteEdges(y,k,M,b=W.createSmallAngle()){if(y instanceof Ki)return this.announceSilhouetteEdges(y.createVisitor(1),k,M,b);const E=y.clientPolyface();if(void 0===E)return;y.setNumWrap(1);const D=[];this.createIndexedEdges(y).sortAndCollectClusters(D);const R=b.radians<0?-b.radians:b.radians,X=j.create(),z=j.create(),N=$.create(),h=k=>{if(!Fn.computeFacetUnitNormal(y,k,N))return{isSideFace:!1,perpAngle:0};const b=N.radiansFromPerpendicular(M);return{isSideFace:Math.abs(b)<=R,perpAngle:b}};for(const Y of D){if(!Array.isArray(Y)||2!==Y.length)continue;const y=Y[0].vertexIndexA,M=Y[0].vertexIndexB;if(!E.data.getPoint(y,X)||!E.data.getPoint(M,z))continue;const b=h(Y[0].facetIndex);if(b.isSideFace){k(X,z,y,M,Y[0].facetIndex);continue}const D=h(Y[1].facetIndex);D.isSideFace?k(z,X,M,y,Y[1].facetIndex):b.perpAngle*D.perpAngle<0&&k(X,z,y,M,Y[0].facetIndex)}}static collectSilhouetteEdges(y,k,M=W.createSmallAngle()){const b=new ss(Q.smallMetricDistance,Q.smallMetricDistance);return Fn.announceSilhouetteEdges(y,((y,k)=>b.captureCurve(Ce.create(y,k))),k,M),b.grabResult(!0)}static announceSweepLinestringToConvexPolyfaceXY(y,k,M){const b=yn.create(y);if(b){const y=k.createVisitor(0);for(y.reset();y.moveToNextFacet();)b.projectToPolygon(y.point,M,k,y.currentReadIndex())}}static setAsyncWorkLimit(y){const k=this._asyncWorkLimit;return this._asyncWorkLimit=y,k}static get asyncWorkLimit(){return this._asyncWorkLimit}static async continueAnnounceSweepLinestringToConvexPolyfaceXY(y,k,M){let b=0;for(;b<this.asyncWorkLimit&&k.moveToNextFacet();)b+=y.projectToPolygon(k.point,M,k.clientPolyface(),k.currentReadIndex());return b}static async asyncAnnounceSweepLinestringToConvexPolyfaceXY(y,k,M){const b=yn.create(y);this.awaitBlockCount=0;let E=0;if(b){const y=k.createVisitor(0);let D;for(;0<(D=await Promise.resolve(Fn.continueAnnounceSweepLinestringToConvexPolyfaceXY(b,y,M)));)E+=D,this.awaitBlockCount++}return E}static partitionFacetIndicesByVertexConnectedComponent(y){if(y instanceof Ki)return this.partitionFacetIndicesByVertexConnectedComponent(y.createVisitor(0));const k=new hs(this.visitorClientPointCount(y));for(y.reset();y.moveToNextFacet();){const M=y.pointIndex[0];for(const b of y.pointIndex)k.mergeSubsets(M,b)}const M=k.collectRootIndices(),b=[],E=M.length;for(let D=0;D<E;D++)b.push([]);for(y.reset();y.moveToNextFacet();){const D=y.pointIndex[0],R=k.findRoot(D);for(let k=0;k<E;k++)if(M[k]===R){b[k].push(y.currentReadIndex());break}}return b}static partitionFacetIndicesByVisibilityVector(y,k,M){if(y instanceof Ki)return this.partitionFacetIndicesByVisibilityVector(y.createVisitor(0),k,M);const b=[];for(let z=0;z<3;z++)b.push([]);const E=b[0],D=b[1],R=b[2],X=Math.max(M.radians,1e-8);for(y.reset();y.moveToNextFacet();){const M=Ur.areaNormalGo(y.point),b=y.currentReadIndex();if(M){const y=M.angleFromPerpendicular(k);Math.abs(y.radians)<X?R.push(b):M.dotProduct(k)<0?D.push(b):E.push(b)}}return b}static boundaryOfVisibleSubset(y,k,M,b=W.createDegrees(.001)){const E=this.partitionFacetIndicesByVisibilityVector(y,M,b);if(0===E[k].length)return;const D=Ji.createSubsetVisitor(y,E[k],1);return this.boundaryEdges(D,!0,!1,!1)}static announceBoundaryChainsAsLineString3d(y,k){const M=new ss(Q.smallMetricDistance);Fn.announceBoundaryEdges(y,((y,k,b,E)=>M.captureCurve(Ce.create(y,k))),!0,!1,!1),M.announceChainsAsLineString3d(k)}static cloneWithMaximalPlanarFacets(y,k){if(y instanceof Ki)return this.cloneWithMaximalPlanarFacets(y.createVisitor(0),k);const M=Fn.visitorClientFacetCount(y),b=Fn.collectEdgesByDihedralAngle(y,k),E=Fn.partitionFacetIndicesBySortableEdgeClusters(b,M),D=ar.create(),R=y,X=[],z=[],N=$.createZero();for(const V of E)if(1===V.length)R.moveToReadIndex(V[0])&&D.addFacetFromVisitor(R);else if(V.length>1){const y=$.createZero(),k=j.createZero();R.moveToReadIndex(V[0])&&R.point.getPoint3dAtCheckedPointIndex(0,k);for(const M of V)R.moveToReadIndex(M)&&Ur.areaNormalGo(R.point,N)&&y.addInPlace(N);z.push(bt.createCapture(k,y)),X.push(V)}const Y=Fn.clonePartitions(y,X);e((X.length,z.length)),e((X.length,Y.length));const O=pt.createIdentity(),B=pt.createIdentity();for(let V=0;V<Y.length;++V){const y=Y[V],k=[],M=[];Fn.announceBoundaryEdges(y,((y,b,E,D)=>{k.push(Ce.create(y,b)),M.push([y.clone(),b.clone()])}),!0,!1,!1);const b=as.collectChains(k,1e-4,1e-4);if(b&&(z[V].toRigidZFrame(O),O.inverse(B))){B.multiplyPoint3dArrayArrayInPlace(M);const y=!(b instanceof hi),k=Hs.formGraphFromChains(M,y,Kr.BOUNDARY_EDGE);if(k){tn.collectConnectedComponentsWithExteriorParityMasks(k,new $s(Kr.BOUNDARY_EDGE),Kr.EXTERIOR);const y=ar.graphToPolyface(k);D.addIndexedPolyface(y,!1,O)}}}return D.claimPolyface(!0)}static fillSimpleHoles(y,k,M){if(y instanceof Ki)return this.fillSimpleHoles(y.createVisitor(0),k,M);const b=ar.create(),E=[];Fn.announceBoundaryChainsAsLineString3d(y,(y=>{y.reverseInPlace(),E.push(y)}));for(const D of E){const y=D.points;let E=!1;D.isPhysicallyClosed?(void 0!==k.maxEdgesAroundHole&&y.length>k.maxEdgesAroundHole||void 0!==k.maxPerimeter&&ue.sumEdgeLengths(y,!1)>k.maxPerimeter||void 0!==k.upVector&&Ur.sumTriangleAreasPerpendicularToUpVector(y,k.upVector)<=0)&&(E=!0):E=!0,!E&&en.triangulateSimplestSpaceLoop(y,((y,k)=>{for(const M of k)b.addPolygon(M)}))||(E=!0),E&&void 0!==M&&M.push(D)}if(void 0!==k.includeOriginalMesh&&k.includeOriginalMesh)for(y.reset();y.moveToNextFacet();)b.addFacetFromVisitor(y);return b.claimPolyface(!0)}static clonePartitions(y,k){if(y instanceof Ki)return this.clonePartitions(y.createVisitor(0),k);y.setNumWrap(0);const M=[],b=Ie.createForFacets();b.needNormals=void 0!==y.normal,b.needParams=void 0!==y.param,b.needColors=void 0!==y.color,b.needTwoSided=y.twoSided;for(const E of k){const k=ar.create(b);y.reset();for(const M of E)y.moveToReadIndex(M),k.addFacetFromVisitor(y);M.push(k.claimPolyface(!0))}return M}static cloneFiltered(y,k){if(y instanceof Ki)return this.cloneFiltered(y.createVisitor(0),k);y.setNumWrap(0);const M=Ie.createForFacets();M.needNormals=void 0!==y.normal,M.needParams=void 0!==y.param,M.needColors=void 0!==y.color,M.needTwoSided=y.twoSided;const b=ar.create(M);for(y.reset();y.moveToNextFacet();)k(y)&&b.addFacetFromVisitor(y);return b.claimPolyface(!0)}static cloneWithDanglingEdgesRemoved(y){if(y instanceof Ki)return this.cloneWithDanglingEdgesRemoved(y.createVisitor(0));const k=Ie.createForFacets();k.needNormals=void 0!==y.normal,k.needParams=void 0!==y.param,k.needColors=void 0!==y.color,k.needTwoSided=y.twoSided;const M=ar.create(k),s=(y,k)=>{const M=y.length;for(let b=0;b<M;++b){let E=1,D=b,R=b;for(;E+2<=M;){const b=0===D?M-1:D-1,X=R===M-1?0:R+1;if(k[y[b]]!==k[y[X]])break;D=b,R=X,E+=2}if(E>1)return D<R?y.splice(D,E-1):D>R&&(y.splice(D),y.splice(0,R)),!0}return!1};for(y.setNumWrap(0),y.reset();y.moveToNextFacet();){const k=[...Array(y.pointIndex.length).keys()];for(;s(k,y.pointIndex););M.addFacetFromIndexedVisitor(y,k)}return M.claimPolyface(!0)}static visitorClientPointCount(y){if(y instanceof Ki)return y.data.point.length;const k=y.clientPolyface();if(void 0!==k)return k.data.point.length;const M=y.currentReadIndex();y.reset();let b=-1;for(;y.moveToNextFacet();)for(const k of y.pointIndex)k>b&&(b=k);return y.moveToReadIndex(M),b+1}static visitorClientFacetCount(y){if(y instanceof Ki){if(void 0!==y.facetCount)return y.facetCount;y=y.createVisitor(0)}if(y.getVisitableFacetCount)return y.getVisitableFacetCount();const k=y.clientPolyface();if(void 0!==k&&void 0!==k.facetCount)return k.facetCount;const M=y.currentReadIndex();let b=0;for(y.reset();y.moveToNextFacet();)++b;return y.moveToReadIndex(M),b}static partitionFacetIndicesBySortableEdgeClusters(y,k){const M=new hs(k);for(const R of y)if(R instanceof on);else{const y=R[0];for(let k=1;k<R.length;k++)M.mergeSubsets(y.facetIndex,R[k].facetIndex)}const b=M.collectRootIndices(),E=[],D=b.length;for(let R=0;R<D;R++)E.push([]);for(let R=0;R<k;R++){const y=M.findRoot(R);for(let k=0;k<D;k++)if(b[k]===y){E[k].push(R);break}}return E}static partitionFacetIndicesByEdgeConnectedComponent(y,k=!1){if(y instanceof Ki)return this.partitionFacetIndicesByEdgeConnectedComponent(y.createVisitor(0),k);y.setNumWrap(1);const M=new an;y.reset();let b=0;for(;y.moveToNextFacet();){const E=y.pointCount-1;b++;for(let b=0;b<E;b++)k&&y.edgeVisible[b]||M.addEdge(y.clientPointIndex(b),y.clientPointIndex(b+1),y.currentReadIndex())}const E=[];return M.sortAndCollectClusters(E,E,E,E),this.partitionFacetIndicesBySortableEdgeClusters(E,b)}static sweepLineStringToFacetsXYReturnSweptFacets(y,k){const M=ar.create();return this.announceSweepLinestringToConvexPolyfaceXY(y,k,((y,k,b,E,D)=>{4===D.length?M.addQuadFacet(D):3===D.length&&M.addTriangleFacet(D)})),M.claimPolyface(!0)}static sweepLinestringToFacetsXYreturnSweptFacets(y,k){return this.sweepLineStringToFacetsXYReturnSweptFacets(y,k)}static sweepLineStringToFacets(y,k,M){let b,E=[];void 0===M&&(M=Cn.create($.unitZ(),W.createRadians(Q.smallAngleRadians),!0,!0,!0,!0)),M.assembleChains&&(b=Qs.create());const D=Pn.create(y,M.vectorToEye);if(D){let y;y=k instanceof Ki?k.createVisitor(0):k;const R=$.createZero();for(y.reset();y.moveToNextFacet();)M.collectFromThisFacetNormal(Ur.areaNormalGo(y.point,R))&&D.processPolygon(y.point.getArray(),((y,k)=>{void 0!==b?b.addSegment(y,k):E.push(Ce.create(y,k))}));void 0!==b&&(b.clusterAndMergeVerticesXYZ(),E=b.collectMaximalChains())}return E}static sweepLineStringToFacetsXY(y,k,M){const b=Qs.create(),E=$.create(0,0,1),D=ut.create();let R,X;R=k instanceof Ki?k.createVisitor(0):k,X=Array.isArray(y)?new ce(y):y;for(let z=1;z<X.length;z++){const y=X.getPoint3dAtUncheckedPointIndex(z-1),k=X.getPoint3dAtUncheckedPointIndex(z),N=vn.createPointPointSweep(y,k,E);void 0!==N&&(ut.createNull(D),D.extendPoint(y),D.extendPoint(k),M.searchRange2d(D,((y,k)=>(R.moveToReadIndex(k)&&N.processPolygon(R.point,((y,k)=>b.addSegment(y,k))),!0))))}return b.clusterAndMergeVerticesXYZ(),b.collectMaximalChains()}static sweepLinestringToFacetsXYReturnLines(y,k){const M=Cn.create($.unitZ(),W.createSmallAngle(),!1,!0,!0,!0);return Fn.sweepLineStringToFacets(y,k,M)}static sweepLinestringToFacetsXYReturnChains(y,k){const M=Cn.create($.unitZ(),W.createSmallAngle(),!0,!0,!0,!0);return Fn.sweepLineStringToFacets(y,k,M)}static async asyncSweepLinestringToFacetsXYReturnChains(y,k){const M=Qs.create();return await Promise.resolve(this.asyncAnnounceSweepLinestringToConvexPolyfaceXY(y,k,((y,k,b,E,D,R,X)=>{M.addSegment(D[R],D[X])}))),M.clusterAndMergeVerticesXYZ(),M.collectMaximalChains()}static collectRangeLengthData(y){if(y instanceof Ki)return this.collectRangeLengthData(y.createVisitor(0));const k=new wn;for(y.reset();y.moveToNextFacet();)k.accumulateGrowableXYZArrayRange(y.point);return k}static cloneWithTVertexFixup(y){const k=y.createVisitor(1),M=y.createVisitor(0),b=In.create(y.data.point,30),E=ar.create(),D=ut.createNull(),R=j.create(),X=j.create(),z=j.create(),N=Ce.create(R,X);for(k.reset();k.moveToNextFacet();){M.clearArrays();for(let E=0;E+1<k.point.length;E++){let Y;if(k.point.getPoint3dAtUncheckedPointIndex(E,R),k.point.getPoint3dAtUncheckedPointIndex(E+1,X),M.pushDataFrom(k,E),D.setNull(),Ce.create(R,X,N),D.extend(R),D.extend(X),D.ensureMinLengths(Q.smallMetricDistance),b.announcePointsInRange(D,((k,M,b,E)=>{y.data.point.getPoint3dAtUncheckedPointIndex(k,z);const D=N.closestPoint(z,!1);return void 0!==D&&D.fraction>0&&D.fraction<1&&!D.point.isAlmostEqual(R)&&!D.point.isAlmostEqual(X)&&z.isAlmostEqual(D.point)&&(void 0===Y&&(Y=[]),D.a=k,Y.push(D)),!0})),void 0!==Y){Y.sort(((y,k)=>y.fraction-k.fraction));for(const y of Y)M.pushInterpolatedDataFrom(k,E,y.fraction,E+1)}}E.addFacetFromGrowableArrays(M.point,M.normal,M.param,M.color,M.edgeVisible)}return E.claimPolyface()}static compareFacetIndexAndVertexIndices(y,k){if(y.length!==k.length)return y.length-k.length;for(let M=1;M<y.length;M++)if(y[M]!==k[M])return y[M]-k[M];return 0}static announceDuplicateFacetIndices(y,k){const M=y.createVisitor(0),b=[];for(M.reset();M.moveToNextFacet();){const y=[M.currentReadIndex()],k=M.pointIndex,E=k.length;let D=0;for(let b=1;b<M.pointIndex.length;b++)k[b]<k[D]&&(D=b);if(k[(D+1)%E]<k[(D+E-1)%E])for(let M=0;M<E;M++)y.push(k[(D+M)%E]);else for(let M=0;M<E;M++)y.push(k[(D+E-M)%E]);b.push(y)}let E,D;b.sort(((y,k)=>this.compareFacetIndexAndVertexIndices(y,k)));const R=b.length,X=[];for(E=0;E<R;E=D){for(D=E+1,X.length=0,X.push(b[E][0]);D<R&&0===this.compareFacetIndexAndVertexIndices(b[E],b[D]);)X.push(b[D][0]),D++;k(X)}}static collectDuplicateFacetIndices(y,k=!1){const M=[];return this.announceDuplicateFacetIndices(y,(y=>{(k||y.length>1)&&M.push(y.slice())})),M}static cloneByFacetDuplication(y,k,M){const b=ar.create(),E=y.createVisitor(0);return this.announceDuplicateFacetIndices(y,(y=>{let D=0;1===y.length?k&&(D=1):y.length>1&&(M===Io.SelectAny?D=1:M===Io.SelectAll?D=y.length:M===Io.SelectOneByParity&&(D=1&~y.length?0:1));for(let k=0;k<D;k++)E.moveToReadIndex(y[k]),b.addFacetFromVisitor(E)})),b.claimPolyface()}static cloneWithColinearEdgeFixup(y){const k=y.createVisitor(2),M=y.createVisitor(0),b=ar.create(),E=$.create(),D=$.create(),R=y.data.point.length,X=new Int32Array(R);for(k.reset();k.moveToNextFacet();)for(let y=0;y+2<k.point.length;y++){k.point.vectorIndexIndex(y,y+1,E),k.point.vectorIndexIndex(y+1,y+2,D);const M=k.clientPointIndex(y+1);X[M]>=0&&(E.angleTo(D).isAlmostZero?X[M]++:X[M]=-1)}for(k.reset();k.moveToNextFacet();){M.clearArrays();for(let y=0;y+2<k.point.length;y++)X[k.clientPointIndex(y)]<0&&M.pushDataFrom(k,y);M.point.length>2&&b.addFacetFromGrowableArrays(M.point,M.normal,M.param,M.color,M.edgeVisible)}return b.claimPolyface()}static setEdgeVisibility(y,k,M){for(const b of k)if(b instanceof on)this.setSingleEdgeVisibility(y,b.facetIndex,b.vertexIndexA,M);else if(Array.isArray(b))for(const k of b)this.setSingleEdgeVisibility(y,k.facetIndex,k.vertexIndexA,M)}static setSingleEdgeVisibility(y,k,M,b){const E=y.data,D=y.facetIndex0(k),R=y.facetIndex1(k);for(let X=D;X<R;X++)E.pointIndex[X]===M&&(E.edgeVisible[X]=b)}static getSingleEdgeVisibility(y,k,M){const b=y.data,E=y.facetIndex0(k),D=y.facetIndex1(k);for(let R=E;R<D;R++)if(b.pointIndex[R]===M)return b.edgeVisible[R]}static collectEdgesByDihedralAngle(y,k,M=!1){if(y instanceof Ki)return this.collectEdgesByDihedralAngle(y.createVisitor(1),k,M);y.setNumWrap(1);const b=[];this.createIndexedEdges(y).sortAndCollectClusters(b),(void 0===k||k.radians<0)&&(k=W.createRadians(Q.smallAngleRadians));const E=[],D=$.create(),R=$.create();for(const X of b)if(Array.isArray(X)&&2===X.length){const b=X[0],z=X[1];if(void 0!==Fn.computeFacetUnitNormal(y,b.facetIndex,D)&&void 0!==Fn.computeFacetUnitNormal(y,z.facetIndex,R)){const y=D.smallerUnorientedAngleTo(R);M?y.radians>k.radians&&E.push(X):y.radians<=k.radians&&E.push(X)}}return E}static markPairedEdgesInvisible(y,k){const M=y.createVisitor(1),b=[],E=[];if(this.createIndexedEdges(M).sortAndCollectClusters(b,E,E,E),this.markAllEdgeVisibility(y,!1),this.setEdgeVisibility(y,E,!0),void 0!==k){const E=$.create(),D=$.create();for(const R of b)if(Array.isArray(R)&&2===R.length){const b=R[0],X=R[1];void 0!==Fn.computeFacetUnitNormal(M,b.facetIndex,E)&&void 0!==Fn.computeFacetUnitNormal(M,X.facetIndex,D)&&E.smallerUnorientedAngleTo(D).radians>k.radians&&(this.setSingleEdgeVisibility(y,b.facetIndex,b.vertexIndexA,!0),this.setSingleEdgeVisibility(y,X.facetIndex,X.vertexIndexA,!0))}}}static computeFacetUnitNormal(y,k,M){if(M||(M=$.create()),y.moveToReadIndex(k)&&Ur.unitNormal(y.point,M))return M}static markAllEdgeVisibility(y,k){const M=y.data;for(let b=0;b<M.edgeVisible.length;b++)M.edgeVisible[b]=k}static convertToHalfEdgeGraph(y){const k=new Ks,M=y.createVisitor(0);for(M.reset();M.moveToNextFacet();)k.insertLoop(M.pointIndex);const b=k.graph,E=j.create();return b.announceNodes(((k,M)=>{const b=M.i;return y.data.getPoint(b,E),M.setXYZ(E),!0})),b}static reorientVertexOrderAroundFacetsForConsistentOrientation(y){return ln.doFixup(y)}static buildPerFaceNormals(y){un.buildPerFaceNormals(y)}static buildAverageNormals(y,k=W.createDegrees(31)){un.buildFastAverageNormals(y,k)}static cloneOffset(y,k,M=Tn.create()){const b=Ie.createForFacets(),E=ar.create(b);return _n.buildOffsetMeshWithEdgeChamfers(y,E,k,M),E.claimPolyface()}static intersectRay3d(y,k,M){if(y instanceof Ki)return Fn.intersectRay3d(y.createVisitor(0),k,M);let b;for(y.setNumWrap(0);y.moveToNextFacet();){const E=y.pointCount,D=y.point;if(3===E){const E=this._workTriangle=ls.create(D.getPoint3dAtUncheckedPointIndex(0),D.getPoint3dAtUncheckedPointIndex(1),D.getPoint3dAtUncheckedPointIndex(2),this._workTriangle),R=this._workTriDetail=E.intersectRay3d(k,this._workTriDetail);E.snapLocationToEdge(R,M?.distanceTolerance,M?.parameterTolerance),b=this._workFacetDetail3=sn.create(y.currentReadIndex(),R,this._workFacetDetail3)}else{const R=this._workPolyDetail=Ur.intersectRay3d(D,k,M?.distanceTolerance,this._workPolyDetail);b=Ur.isConvex(D)?this._workFacetDetailC=rn.create(y.currentReadIndex(),E,R,this._workFacetDetailC):this._workFacetDetailNC=nn.create(y.currentReadIndex(),E,R,this._workFacetDetailNC)}if(b.isInsideOrOn){if(M?.needNormal&&y.normal&&b.getNormal(y.normal,D,M?.distanceTolerance),M?.needParam&&y.param&&b.getParam(y.param,D,M?.distanceTolerance),M?.needColor&&y.color&&b.getColor(y.color,D,M?.distanceTolerance),M?.needBarycentricCoordinates&&b.getBarycentricCoordinates(D,M?.distanceTolerance),M?.acceptIntersection&&!M.acceptIntersection(b,y))continue;return b}}}}Fn._asyncWorkLimit=1e6,Fn.awaitBlockCount=0;class kn{constructor(y){this._planes=y||[]}toJSON(){const y=[];for(const k of this._planes)y.push(k.toJSON());return y}static fromJSON(y,k){if((k=k||new kn)._planes.length=0,!Array.isArray(y))return k;for(const M of y){const y=Wr.fromJSON(M);y&&k._planes.push(y)}return k}isAlmostEqual(y){if(this._planes.length!==y._planes.length)return!1;for(let k=0;k<this._planes.length;k++)if(!this._planes[k].isAlmostEqual(y._planes[k]))return!1;return!0}static createPlanes(y,k){k=k||new kn;for(const M of y)if(M instanceof Wr)k._planes.push(M);else if(M instanceof _t){const y=Wr.createPlane(M);k._planes.push(y)}return k}static createRange3dPlanes(y,k=!0,M=!0,b=!0,E=!0,D=!0,R=!0){const X=kn.createEmpty();return k&&X.planes.push(Wr.createNormalAndPointXYZXYZ(1,0,0,y.low.x,0,0)),M&&X.planes.push(Wr.createNormalAndPointXYZXYZ(-1,0,0,y.high.x,0,0)),b&&X.planes.push(Wr.createNormalAndPointXYZXYZ(0,1,0,0,y.low.y,0)),E&&X.planes.push(Wr.createNormalAndPointXYZXYZ(0,-1,0,0,y.high.y,0)),D&&X.planes.push(Wr.createNormalAndPointXYZXYZ(0,0,1,0,0,y.low.z)),R&&X.planes.push(Wr.createNormalAndPointXYZXYZ(0,0,-1,0,0,y.high.z)),X}static createEmpty(y){return y?(y._planes.length=0,y):new kn}negateAllPlanes(){for(const y of this._planes)y.negateInPlace()}static createXYBox(y,k,M,b,E){(E=E||new kn)._planes.length=0;const D=Wr.createNormalAndDistance($.create(-1,0,0),-M,!1,!0),R=Wr.createNormalAndDistance($.create(1,0,0),y,!1,!0),X=Wr.createNormalAndDistance($.create(0,-1,0),-b,!1,!0),z=Wr.createNormalAndDistance($.create(0,1,0),k,!1,!0);return D&&R&&X&&z&&E._planes.push(D,R,X,z),E}static createXYPolyLine(y,k,M,b){(b=b||new kn)._planes.length=0;for(let E=0;E+1<y.length;E++){const D=$.createStartEnd(y[E],y[E+1]).unitPerpendicularXY();if(D.z=0,M||D.scaleInPlace(-1),D.normalize()){const M=void 0!==k&&k[E],R=Wr.createNormalAndPoint(D,y[E],M,M);R&&b._planes.push(R)}}return b}static createXYPolyLineInsideLeft(y,k){(k=k||new kn)._planes.length=0;for(let M=0;M+1<y.length;M++){const b=$.createStartEnd(y[M],y[M+1]).unitPerpendicularXY();if(b.z=0,b.normalize()){const E=Wr.createNormalAndPoint(b,y[M],!1,!1);E&&k._planes.push(E)}}return k}static setPlaneAndXYLoopCCW(y,k,M){const b=y.length-1,E=y.length;let D,R,X,z,N=y.getXAtUncheckedPointIndex(b),Y=y.getYAtUncheckedPointIndex(b);M._planes.length=0;const O=y.getZAtUncheckedPointIndex(b),B=y.crossProductIndexIndexIndex(0,2,1);if(Wr.createNormalAndPointXYZXYZ(B.x,B.y,B.z,N,Y,O,!1,!1,k),B.normalizeInPlace())for(let V=0;V<E;V++,N=D,Y=R){D=y.getXAtUncheckedPointIndex(V),R=y.getYAtUncheckedPointIndex(V),X=-(R-Y),z=D-N;const k=Wr.createNormalAndPointXYZXYZ(X,z,0,D,R,O);k&&M._planes.push(k)}}clone(y){(y=y||new kn)._planes.length=0;for(const k of this._planes)y._planes.push(k.clone());return y}get planes(){return this._planes}hasIntersectionWithRay(y,k,M=Q.smallMetricDistance){let b=-Q.largeCoordinateResult,E=Q.largeCoordinateResult;k&&k.setNull();for(const D of this._planes){const k=D.velocity(y.direction),R=D.altitude(y.origin);if(Math.abs(k)<=1e-13){if(R<-M)return!1}else{const y=-R/k;k<0?y<E&&(E=y):y>b&&(b=y)}}return!(E<b||(k&&(k.extendX(b),k.extendX(E)),0))}multiplyPlanesByMatrix4d(y,k=!0,M=!0){if(k){const k=y.createInverse();return!!k&&this.multiplyPlanesByMatrix4d(k,!1,M)}for(const b of this._planes)b.multiplyPlaneByMatrix4d(y,!1,M);return!0}isPointInside(y){for(const k of this._planes)if(!k.isPointInside(y))return!1;return!0}isPointOnOrInside(y,k=Q.smallMetricDistance){const M=Math.abs(k);for(const b of this._planes)if(!b.isPointOnOrInside(y,b.interior?M:k))return!1;return!0}isSphereInside(y,k){const M=Math.abs(k)+Q.smallMetricDistance;for(const b of this._planes)if(!b.isPointOnOrInside(y,M))return!1;return!0}announceClippedSegmentIntervals(y,k,M,b,E){let D;if(k<y)return!1;for(const R of this._planes){const E=-R.altitude(M),X=-R.altitude(b);if(D=Q.conditionalDivideFraction(-E,X-E),void 0===D){if(E>0)return!1}else if(X>E){if(D<y)return!1;D<k&&(k=D)}else if(E>X){if(D>k)return!1;D>y&&(y=D)}else if(E>0)return!1}return k>=y&&(E&&E(y,k),!0)}announceClippedArcIntervals(y,k){const M=kn._clipArcFractionArray;M.clear();for(const b of this.planes)b.appendIntersectionRadians(y,M);return y.sweep.radiansArrayToPositivePeriodicFractions(M),Rs.selectIntervals01(y,M,this,k)}clipUnboundedSegment(y,k,M){return this.announceClippedSegmentIntervals(-Number.MAX_VALUE,Number.MAX_VALUE,y,k,M)}transformInPlace(y){for(const k of this._planes)k.transformInPlace(y)}clipConvexPolygonInPlace(y,k,M=Q.smallMetricDistance){for(const b of this._planes)if(b.clipConvexPolygonInPlace(y,k,!0,M),y.length<3)return}clipInsidePushOutside(y,k,M){const b=ft.createNull();let E=M.grabFromCache(),D=M.grabFromCache(),R=M.grabFromCache();R.pushFrom(y);for(const X of this._planes)if(Zr.splitConvexPolygonInsideOutsidePlane(X,R,E,D,b),D.length>0){if(k&&Rs.captureOrDrop(D,3,k,M),D=M.grabFromCache(),0===E.length){R.length=0;break}M.dropToCache(R),R=E,E=M.grabFromCache()}if(M.dropToCache(E),M.dropToCache(D),R.length>0)return R;M.dropToCache(R)}classifyPointContainment(y,k){let M=!0;const b=k?1e-8:-1e-8;for(const E of this._planes){let k=0;for(const D of y)E.altitude(D)<(E.interior?1e-8:b)&&(k++,M=!1);if(k===y.length)return ro.StronglyOutside}return M?ro.StronglyInside:ro.Ambiguous}static createSweptPolyline(y,k,M){const b=kn.createEmpty();let E=!1;y.length>3&&y[0].isAlmostEqual(y[y.length-1])&&Ur.areaNormal(y).dotProduct(k)>0&&(E=!0);for(let D=0;D+1<y.length;D++)if(E){const E=Wr.createEdgeAndUpVector(y[D+1],y[D],k,M);if(!E)return;b.addPlaneToConvexSet(E)}else{const E=Wr.createEdgeAndUpVector(y[D],y[D+1],k,M);if(!E)return;b.addPlaneToConvexSet(E)}return b}addPlaneToConvexSet(y){y instanceof Wr?this._planes.push(y):y instanceof _t&&this._planes.push(Wr.createPlane(y))}clipPointsOnOrInside(y,k,M){k.length=0,M.length=0;for(const b of y)this.isPointOnOrInside(b,0)?k.push(b):M.push(b)}polygonClip(y,k,M,b){y instanceof nt?y.clone(k):nt.create(y,k);for(const E of this._planes)if(b!==E){if(0===k.length)break;E.clipConvexPolygonInPlace(k,M)}}reloadSweptPolygon(y,k,M){this._planes.length=0;const b=y.length;if(b<=2)return 0;const E=Ur.areaNormal(y),D=k.dotProduct(E)>0,R=D?1:b-1;for(let X=0;X<b;X++){const M=(X+R)%b,E=y[X],D=y[M];if(E.isAlmostEqual(D))continue;const z=$.createStartEnd(E,D),N=$.createCrossProduct(k.x,k.y,k.z,z.x,z.y,z.z).normalize();let Y;if(N){Y=N.dotProduct(E);const y=Wr.createNormalAndDistance(N,Y,!1,!1);y&&this._planes.push(y)}}if(0!==M){let b=E.normalize();if(b){k.dotProduct(b)*M<0&&(b=b.negate());const E=y[0],D=b.dotProduct(E),R=Wr.createNormalAndDistance(b,D,!1,!1);R&&this._planes.push(R)}}return D?1:-1}computePlanePlanePlaneIntersections(y,k,M,b=!0){const E=xt.createIdentity(),D=this._planes,R=D.length;let X=0;for(let z=0;z<R;z++)for(let N=z+1;N<R;N++)for(let Y=N+1;Y<R;Y++)if(xt.createRowValues(D[z].inwardNormalRef.x,D[z].inwardNormalRef.y,D[z].inwardNormalRef.z,D[N].inwardNormalRef.x,D[N].inwardNormalRef.y,D[N].inwardNormalRef.z,D[Y].inwardNormalRef.x,D[Y].inwardNormalRef.y,D[Y].inwardNormalRef.z,E),E.computeCachedInverse(!1)){const R=E.multiplyInverseXYZAsPoint3d(D[z].distance,D[N].distance,D[Y].distance);b&&!this.isPointOnOrInside(R,Q.smallMetricDistance)||(X++,M&&M.multiplyPoint3d(R,R),y&&y.push(R),k&&k.extendPoint(R))}return X}setInvisible(y){for(const k of this._planes)k.setInvisible(y)}addZClipPlanes(y,k,M){void 0!==k&&this._planes.push(Wr.createNormalAndDistance($.create(0,0,1),k,y)),void 0!==M&&this._planes.push(Wr.createNormalAndDistance($.create(0,0,-1),-M,y))}appendPolygonClip(y,k,M,b){const E=this.clipInsidePushOutside(y,M,b);E&&k.push(E)}static createConvexPolyface(y,k){k=this.createEmpty(k);let M,b,E=0;if(y instanceof Ki?(M=y,b=y.createVisitor(0)):(M=y.clientPolyface(),b=y),M&&b){Fn.isPolyfaceClosedByEdgePairing(M)&&(E=Fn.sumTetrahedralVolumes(b));const y=E>0?-1:1,D=$.create(),R=_t.createXYPlane();for(b.reset();b.moveToNextFacet();)void 0!==Ur.areaNormalGo(b.point,D)&&(D.scaleInPlace(y),void 0!==_t.create(b.point.front(),D,R)&&k.addPlaneToConvexSet(R))}return{clipper:k,volume:E}}}kn.hugeVal=1e37,kn._clipArcFractionArray=new It;class Mn{constructor(y,k,M){if(y instanceof ae){const k=y;(y=y.startPoint().isAlmostEqual(y.endPoint())?new hi:new oi).tryAddChild(k)}this.curves=y,this.localToWorld=k,this.axis=M}static createForLinearSweep(y,k){const M=Fi.createRightHandedFrame(k,y);if(M)return new Mn(y,M,void 0)}static createForPolygon(y,k){const M=Fi.createRightHandedFrame(k,y);if(M){const k=Me.createArrayOfLineString3d(y),b=[];for(const y of k)y.addClosurePoint(),b.push(hi.create(y));if(1===b.length)return new Mn(b[0],M,void 0);if(b.length>1)return new Mn(bi.createLoops(b),M,void 0)}}static createForRotation(y,k){const M=Fi.createRightHandedFrame(void 0,y,k);if(M)return new Mn(y,M,k.clone())}getCurves(){return this.curves}tryTransformInPlace(y){if(this.curves.tryTransformInPlace(y)){this.axis&&this.axis.transformInPlace(y);const k=void 0!==this.axis?Fi.createRightHandedFrame(void 0,this.curves,this.axis):Fi.createRightHandedFrame(void 0,this.curves);if(k)return this.localToWorld.setFrom(k),this._xyStrokes=void 0,!0}return!1}clone(){return new Mn(this.curves.clone(),this.localToWorld.clone(),this.axis)}cloneTransformed(y){const k=this.clone();if(k.tryTransformInPlace(y))return k}isAlmostEqual(y){if(!(y instanceof Mn))return!1;if(!this.curves.isAlmostEqual(y.curves))return!1;if(!this.localToWorld.isAlmostEqual(y.localToWorld))return!1;if(this.axis&&y.axis){if(!this.axis.isAlmostEqual(y.axis))return!1}else if(this.axis||y.axis)return!1;return!0}computeXYStrokes(y){this._xyStrokes=void 0;const k=this.localToWorld.inverse();if(k){const M=this.curves.cloneStroked(y);M.tryTransformInPlace(k)&&(this._xyStrokes=M)}}get xyStrokes(){return this._xyStrokes}buildFacets(y){if(this._facets)return;if(!this.curves.isAnyRegion())return;const k=this.localToWorld.inverse();if(!k)return;const M=this.curves.cloneTransformed(k);M&&(this._facets=Er.facetRegionXY(M,y))&&this._facets.tryTransformInPlace(this.localToWorld)}purgeFacets(){this._facets=void 0}emitFacets(y,k,M){this.buildFacets(y.options),this._facets&&y.addIndexedPolyface(this._facets,k,M)}announceFacets(y,k){this.buildFacets(k),this._facets&&y(this._facets)}sweepToUnionOfConvexClipPlaneSets(y,k=!1,M=!1,b){b||(b=Ie.createForFacets()),y||(k=M=!1,y=this.localToWorld.matrix.columnZ()),b.maximizeConvexFacets=!0,this.buildFacets(b);const E=this._facets;if(E){const b=j.create(),D=j.create(),R=vs.createEmpty(),X=E.createVisitor(1);for(X.reset();X.moveToNextFacet();){const k=X.point.length-1,M=kn.createEmpty();for(let E=0;E<k;E++){X.point.getPoint3dAtUncheckedPointIndex(E,b),X.point.getPoint3dAtUncheckedPointIndex(E+1,D);const k=Wr.createEdgeAndUpVector(D,b,y),R=X.edgeVisible[E];k?.setFlags(!R,!R),M.addPlaneToConvexSet(k)}R.addConvexSet(M)}if(k||M){const b=this.localToWorld.matrix.columnZ(),E=this.localToWorld.getOrigin(),D=E.plus(y),X=b.clone(),z=b.negate(),N=kn.createEmpty();k&&N.addPlaneToConvexSet(Wr.createNormalAndPoint(X,E)),M&&N.addPlaneToConvexSet(Wr.createNormalAndPoint(z,D)),R.addConvexSet(N)}return R}}}class bn extends Di{constructor(y,k){super(k),this.solidPrimitiveType="ruledSweep",this._contours=y}static create(y,k){const M=[];for(const b of y){const y=Mn.createForLinearSweep(b);if(void 0===y)return;M.push(y)}return new bn(M,k)}sweepContoursRef(){return this._contours}cloneSweepContours(){const y=[];for(const k of this._contours)y.push(k.clone());return y}cloneContours(){const y=[];for(const k of this._contours)y.push(k.curves.clone());return y}clone(){return new bn(this.cloneSweepContours(),this.capped)}tryTransformInPlace(y){if(y.matrix.isSingular())return!1;for(const k of this._contours)k.tryTransformInPlace(y);return!0}cloneTransformed(y){const k=this.clone();return k.tryTransformInPlace(y),k}getConstructiveFrame(){if(0!==this._contours.length)return this._contours[0].localToWorld.cloneRigid()}isSameGeometryClass(y){return y instanceof bn}isAlmostEqual(y){if(y instanceof bn){if(this.capped!==y.capped)return!1;if(this._contours.length!==y._contours.length)return!1;for(let k=0;k<this._contours.length;k++)if(!this._contours[k].isAlmostEqual(y._contours[k]))return!1;return!0}return!1}dispatchToGeometryHandler(y){return y.handleRuledSweep(this)}constantVSection(y){const k=this._contours.length;if(k<2)return;const M=y*k;let b=0;b=y>=1?k-1:Math.floor(M),b+1>=k&&(b=k-2);const E=b+1,D=Q.clampToStartEnd(M-b,0,1);return bn.mutatePartners(this._contours[b].curves,this._contours[E].curves,((y,k)=>{const M=Ri.interpolateBetween(y,D,k);if(M instanceof ae)return M}))}extendRange(y,k){for(const M of this._contours)M.curves.extendRange(y,k)}static mutatePartners(y,k,M){if(y.isSameGeometryClass(k)){if(y instanceof ni&&k instanceof ni){const b=y,E=k,D=b.cloneEmptyPeer(),R=b.children,X=E.children;if(R.length!==X.length)return;for(let y=0;y<R.length;y++){const k=M(R[y],X[y]);if(!k)return;D.children.push(k)}return D}if(y instanceof si&&k instanceof si){const b=y.cloneEmptyPeer(),E=y.children,D=k.children,R=b.children;if(void 0===E||void 0===D||void 0===R||E.length!==D.length)return;for(let y=0;y<E.length;y++){const k=E[y],b=D[y];if(k instanceof ae&&b instanceof ae){const y=M(k,b);if(!y)return;R.push(y)}else if(k instanceof si&&b instanceof si){const y=this.mutatePartners(k,b,M);if(!y)return;y instanceof si&&R.push(y)}}return b}}}get isClosedVolume(){const y=this._contours.length;return y>1&&(this.capped||this._contours[0].isAlmostEqual(this._contours[y-1]))}}class En extends Di{constructor(y,k,M,b,E){super(E),this.solidPrimitiveType="torusPipe",this._localToWorld=y,this._radiusA=k,this._radiusB=M,this._sweep=b,this._isReversed=!1}clone(){const y=new En(this._localToWorld.clone(),this._radiusA,this._radiusB,this._sweep.clone(),this.capped);return y._isReversed=this._isReversed,y}tryTransformInPlace(y){return!y.matrix.isSingular()&&(y.multiplyTransformTransform(this._localToWorld,this._localToWorld),!0)}cloneTransformed(y){const k=this.clone();if(k.tryTransformInPlace(y))return k}static createInFrame(y,k,M,b,E){if((k=Math.abs(Q.correctSmallMetricDistance(k)))<(M=Math.abs(Q.correctSmallMetricDistance(M))))return;if(0===k)return;if(0===M)return;if(b.isAlmostZero)return;let D=1,R=1,X=!1;y.matrix.determinant()<0&&(R*=-1);const z=b.clone();b.radians<0&&(z.setRadians(-b.radians),R*=-1,D*=-1,X=!0);const N=y.clone();N.matrix.scaleColumnsInPlace(1,D,R);const Y=new En(N,k,M,z,E);return Y._isReversed=X,Y}static createDgnTorusPipe(y,k,M,b,E,D,R){const X=k.unitCrossProductWithDefault(M,0,0,1),z=pt.createOriginAndMatrixColumns(y,k,M,X);return En.createInFrame(z,b,E,D,R)}static createAlongArc(y,k,M){if(W.isAlmostEqualRadiansAllowPeriodShift(0,y.sweep.startRadians)||(y=y.cloneInRotatedBasis(y.sweep.startAngle)),!y.isCircular){const k=y.perpendicularVector.sizedCrossProduct(y.vector0,y.matrixRef.columnXMagnitude());if(!k)return;y=Ti.create(y.center,y.vector0,k,y.sweep)}const b=y.toScaledMatrix3d(),E=pt.createOriginAndMatrix(y.center,b.axes);return En.createInFrame(E,b.r0,k,W.createRadians(y.sweep.sweepRadians),M)}getConstructiveFrame(){return this._localToWorld.cloneRigid()}cloneCenter(){return this._localToWorld.getOrigin()}cloneVectorX(){const y=this._localToWorld.matrix.columnX();return y.normalizeWithDefault(1,0,0,y)}cloneVectorY(){const y=this._localToWorld.matrix.columnY();return y.normalizeWithDefault(0,1,0,y)}cloneVectorZ(){const y=this._localToWorld.matrix.columnZ();return y.normalizeWithDefault(0,0,1,y)}getMajorRadius(){return this._radiusA*this._localToWorld.matrix.columnXMagnitude()}getMinorRadius(){return this._radiusB*this._localToWorld.matrix.columnZMagnitude()}getSweepAngle(){return this._sweep.clone()}getIsReversed(){return this._isReversed}getThetaFraction(){return this._sweep.radians/(2*Math.PI)}cloneLocalToWorld(){return this._localToWorld.clone()}isSameGeometryClass(y){return y instanceof En}isAlmostEqual(y){return!!(y instanceof En&&(this._sweep.isFullCircle||this.capped===y.capped)&&this.cloneCenter().isAlmostEqual(y.cloneCenter())&&this.cloneVectorX().isAlmostEqual(y.cloneVectorX())&&this.cloneVectorY().isAlmostEqual(y.cloneVectorY())&&this.cloneVectorZ().isAlmostEqual(y.cloneVectorZ())&&Q.isSameCoordinate(this.getMinorRadius(),y.getMinorRadius())&&Q.isSameCoordinate(this.getMajorRadius(),y.getMajorRadius())&&this.getSweepAngle().isAlmostEqualNoPeriodShift(y.getSweepAngle()))}vFractionToRadians(y){return this._sweep.radians*y}dispatchToGeometryHandler(y){return y.handleTorusPipe(this)}constantVSection(y){const k=this.vFractionToRadians(y),M=Math.cos(k),b=Math.sin(k),E=this._radiusA,D=this._radiusB,R=this._localToWorld.multiplyXYZ(E*M,E*b,0),X=this._localToWorld.multiplyVectorXYZ(D*M,D*b,0),z=this._localToWorld.multiplyVectorXYZ(0,0,D);return hi.create(Ti.create(R,X,z))}constantUSection(y){const k=this._sweep.radians,M=2*y*Math.PI,b=this._radiusA,E=this._radiusB,D=this._localToWorld.matrix,R=this._localToWorld.multiplyXYZ(0,0,E*Math.sin(M)),X=b+E*Math.cos(M),z=D.multiplyXYZ(X,0,0),N=D.multiplyXYZ(0,X,0);return oi.create(Ti.create(R,z,N,At.createStartEndRadians(0,k)))}extendRange(y,k){const M=this._sweep.radians,b=this._radiusA,E=this._radiusB,D=this._localToWorld,R=Math.ceil(M/(Math.PI/16));let X=0,z=0,N=0,Y=0,O=0,B=0,V=0,U=0,L=0;const Z=M/R;for(let q=0;q<=R;q++)if(Y=q*Z,O=Math.cos(Y),B=Math.sin(Y),0===q||q===R?(X=-Math.PI,z=2*Math.PI/16,N=16):(X=-.5*Math.PI,z=Math.PI/16,N=31),k)for(L=0;L<=N;L++)U=X+L*z,V=b+E*Math.cos(U),y.extendTransformTransformedXYZ(k,D,O*V,B*V,Math.sin(U)*E);else for(L=0;L<=N;L++)U=X+L*z,V=b+E*Math.cos(U),y.extendTransformedXYZ(D,O*V,B*V,Math.sin(U)*E)}uvFractionToPoint(y,k,M){const b=k*this._sweep.radians,E=y*Math.PI*2,D=Math.cos(b),R=Math.sin(b),X=this._radiusA,z=this._radiusB,N=X+Math.cos(E)*z;return this._localToWorld.multiplyXYZ(N*D,N*R,z*Math.sin(E),M)}uvFractionToPointAndTangents(y,k,M){const b=k*this._sweep.radians,E=y*Math.PI*2,D=this._sweep.radians,R=2*Math.PI,X=Math.cos(b),z=Math.sin(b),N=Math.sin(E),Y=Math.cos(E),O=this._radiusA,B=this._radiusB,V=O+Math.cos(E)*B,U=B*N,L=B*Y;return Et.createOriginAndVectors(this._localToWorld.multiplyXYZ(X*V,z*V,U),this._localToWorld.multiplyVectorXYZ(-X*U*R,-z*U*R,L*R),this._localToWorld.multiplyVectorXYZ(-V*z*D,V*X*D,0),M)}maxIsoParametricDistance(){const y=Math.abs(this.getMajorRadius()),k=Math.abs(this.getMinorRadius());return J.create(k*Math.PI*2,(y+k)*this._sweep.radians)}get isClosedVolume(){return this.capped||this._sweep.isFullCircle}}class Rn extends ae{get activeFractionInterval(){return this._activeFractionInterval}get localToWorld(){return this._localToWorld}constructor(y,k,M,b){super(),this._spiralType=y||"unknownSpiralType",this._designProperties=b,this._localToWorld=k,this._activeFractionInterval=M||Re.create(0,1)}get spiralType(){return this._spiralType}static radiusToCurvature(y){return 0===y?0:1/y}static curvatureToRadius(y){return Math.abs(y)<Q.smallAngleRadians?0:1/y}clonePartialCurve(y,k){const M=this.clone(),b=this._activeFractionInterval.fractionToPoint(y),E=this._activeFractionInterval.fractionToPoint(k);return M._activeFractionInterval.set(b,E),M.refreshComputedProperties(),M}cloneTransformed(y){const k=this.clone();return k.tryTransformInPlace(y),k}static averageCurvature(y){return.5*(Rn.radiusToCurvature(y.x0)+Rn.radiusToCurvature(y.x1))}static averageCurvatureR0R1(y,k){return.5*(Rn.radiusToCurvature(y)+Rn.radiusToCurvature(k))}static interpolateCurvatureR0R1(y,k,M){return Q.interpolate(Rn.radiusToCurvature(y),k,Rn.radiusToCurvature(M))}static radiusRadiusSweepRadiansToArcLength(y,k,M){return Math.abs(M/Rn.averageCurvatureR0R1(y,k))}static radiusRadiusLengthToSweepRadians(y,k,M){return Rn.averageCurvatureR0R1(y,k)*M}static radius0LengthSweepRadiansToRadius1(y,k,M){return Rn.curvatureToRadius(2*M/k-Rn.radiusToCurvature(y))}static radius1LengthSweepRadiansToRadius0(y,k,M){return Rn.curvatureToRadius(2*M/k-Rn.radiusToCurvature(y))}get designProperties(){return this._designProperties}applyRigidPartOfTransform(y){const k=y.matrix.factorRigidWithSignedScale();if(void 0!==k){const M=y.multiplyTransformTransform(this.localToWorld),b=k.rigidAxes.multiplyMatrixMatrix(this.localToWorld.matrix);return this._localToWorld=pt.createOriginAndMatrix(M.origin,b),this.designProperties&&this.designProperties.applyScaleFactor(k.scale),k}}constructOffsetXY(y){const k=we.create(y),M=new ye(this,k.leftOffsetDistance);return this.emitStrokableParts(M,k.strokeOptions),M.claimResult()}extendRange(y,k){const M=this.rangeBetweenFractions(0,1,k);y.extendRange(M)}rangeBetweenFractions(y,k,M){const b=this.activeStrokes;if(void 0===b)return ut.createNull();let E=Math.ceil(b.numPoints()*Math.abs(k-y));return E=Q.clamp(5,E,30),this.rangeBetweenFractionsByCount(y,k,E,M,.5)}projectedParameterRange(y,k){return Ee.findExtremeFractionsAlongDirection(this,y,k)}}class Dn{constructor(){}static findEvaluator(y){return"clothoid"===y?this._clothoidEvaluator?this._clothoidEvaluator:this._clothoidEvaluator=new Xn:"bloss"===y?this._blossEvaluator?this._blossEvaluator:this._blossEvaluator=new zn:"biquadratic"===y?this._biquadraticEvaluator?this._biquadraticEvaluator:this._biquadraticEvaluator=new Nn:"sine"===y?this._sineEvaluator?this._sineEvaluator:this._sineEvaluator=new On:"cosine"===y?this._cosineEvaluator?this._cosineEvaluator:this._cosineEvaluator=new Yn:void 0}}class Xn extends Dn{constructor(){super()}fractionToCurvatureFraction(y){return y}fractionToCurvatureFractionDerivative(y){return 1}fractionToArea(y){return y*y*.5}}class zn extends Dn{constructor(){super()}fractionToCurvatureFraction(y){return y*y*(3-2*y)}fractionToCurvatureFractionDerivative(y){return 6*y*(1-y)}fractionToArea(y){return y*y*y*(1-.5*y)}}class Nn extends Dn{constructor(){super()}integratedBasis(y){return y*y*y*(2/3)}basis(y){return 2*y*y}basisDerivative(y){return 4*y}fractionToCurvatureFraction(y){return y<=.5?this.basis(y):1-this.basis(1-y)}fractionToCurvatureFractionDerivative(y){return y<.5?this.basisDerivative(y):this.basisDerivative(1-y)}fractionToArea(y){if(y<=.5)return this.integratedBasis(y);const k=1-y;return.5-k+this.integratedBasis(k)}}class On extends Dn{constructor(){super()}fractionToCurvatureFraction(y){const k=2*Math.PI;return y-Math.sin(y*k)/k}fractionToCurvatureFractionDerivative(y){const k=2*Math.PI;return 1-Math.cos(y*k)}fractionToArea(y){const k=2*Math.PI;return.5*y*y+(Math.cos(y*k)-1)/(k*k)}}class Yn extends Dn{constructor(){super()}fractionToCurvatureFraction(y){const k=Math.PI;return.5*(1-Math.cos(y*k))}fractionToCurvatureFractionDerivative(y){const k=Math.PI;return.5*k*Math.sin(y*k)}fractionToArea(y){const k=Math.PI;return.5*y-.5*Math.sin(y*k)/k}}class Bn{constructor(y,k,M,b,E){this.radius0=y,this.radius1=k,this.bearing0=M,this.bearing1=b,this.curveLength=E}numDefinedProperties(){return Q.defined01(this.radius0)+Q.defined01(this.radius1)+Q.defined01(this.bearing0)+Q.defined01(this.bearing1)+Q.defined01(this.curveLength)}clone(){return new Bn(this.radius0,this.radius1,void 0===this.bearing0?void 0:this.bearing0.clone(),void 0===this.bearing1?void 0:this.bearing1.clone(),this.curveLength)}getIsValidCompleteSet(){if(void 0!==this.curveLength&&void 0!==this.bearing0&&void 0!==this.bearing1&&void 0!==this.radius0&&void 0!==this.radius1){const y=Rn.radiusRadiusSweepRadiansToArcLength(this.radius0,this.radius1,this.bearing1.radians-this.bearing0.radians);return Q.isSameCoordinate(this.curveLength,y)}return!1}tryResolveAnySingleUnknown(){if(this.getIsValidCompleteSet())return!0;if(this.bearing0&&this.bearing1){const y=this.bearing1.radians-this.bearing0.radians;return void 0===this.curveLength&&void 0!==this.radius0&&void 0!==this.radius1?(this.curveLength=Rn.radiusRadiusSweepRadiansToArcLength(this.radius0,this.radius1,y),!0):void 0!==this.curveLength&&void 0===this.radius0&&void 0!==this.radius1?(this.radius0=Rn.radius1LengthSweepRadiansToRadius0(this.radius1,this.curveLength,y),!0):void 0!==this.curveLength&&void 0!==this.radius0&&void 0===this.radius1&&(this.radius1=Rn.radius0LengthSweepRadiansToRadius1(this.radius0,this.curveLength,y),!0)}return void 0!==this.curveLength&&void 0!==this.radius0&&void 0!==this.radius1&&(this.bearing0?(this.bearing1=W.createRadians(this.bearing0.radians+Rn.radiusRadiusLengthToSweepRadians(this.radius0,this.radius1,this.curveLength)),!0):!!this.bearing1&&(this.bearing0=W.createRadians(this.bearing1.radians-Rn.radiusRadiusLengthToSweepRadians(this.radius0,this.radius1,this.curveLength)),!0))}almostEqualCoordinate(y,k){return void 0===y&&void 0===k||void 0!==y&&void 0!==k&&Q.isSameCoordinate(y,k)}almostEqualBearing(y,k){return void 0===y&&void 0===k||void 0!==y&&void 0!==k&&y.isAlmostEqualNoPeriodShift(k)}isAlmostEqual(y){return!!(y&&this.almostEqualCoordinate(this.radius0,y.radius0)&&this.almostEqualCoordinate(this.radius1,y.radius1)&&this.almostEqualBearing(this.bearing0,y.bearing0)&&this.almostEqualBearing(this.bearing1,y.bearing1)&&this.almostEqualCoordinate(this.curveLength,y.curveLength))}applyScaleFactor(y){void 0!==this.radius0&&(this.radius0*=y),void 0!==this.radius1&&(this.radius1*=y),void 0!==this.curveLength&&(this.curveLength*=y)}static areAlmostEqual(y,k){return void 0===y?void 0===k:y.isAlmostEqual(k)}}class Vn extends Rn{get activeStrokes(){return void 0!==this._activeStrokes?this._activeStrokes:this._globalStrokes}constructor(y,k,M,b,E,D,R,X){super(y,D,E,X),this.curvePrimitiveType="transitionSpiral",this._evaluator=k,this.radius01=M,this.bearing01=b,this._arcLength01=R,this._globalStrokes=Me.create(),this._curvature01=Re.create(0,1),this.refreshComputedProperties()}globalFractionToBearingRadians(y){const k=this._evaluator.fractionToArea(y),M=this._arcLength01;return this.bearing01.startRadians+k*M*this._curvature01.signedDelta()+y*this._curvature01.x0*M}globalFractionToCurvature(y){const k=this._evaluator.fractionToCurvatureFraction(y);return this._curvature01.fractionToPoint(k)}fractionToBearingRadians(y){const k=this.activeFractionInterval.fractionToPoint(y);return this.bearing01.startRadians+k*this._arcLength01*(this._curvature01.x0+.5*k*(this._curvature01.x1-this._curvature01.x0))}fractionToCurvature(y){return this._curvature01.fractionToPoint(this.activeFractionInterval.fractionToPoint(y))}static initWorkSpace(){Vn._gaussFraction=new Float64Array(5),Vn._gaussWeight=new Float64Array(5),Vn._gaussMapper=(y,k,M,b)=>ne.setupGauss5(y,k,M,b)}fullSpiralIncrementalIntegral(y,k,M,b){const E=Vn._gaussFraction,D=Vn._gaussWeight,R=Vn._gaussMapper(k,M,E,D),X=this._arcLength01;let z=0,N=0,Y=0;for(let O=0;O<R;O++){const y=this.globalFractionToBearingRadians(E[O]);z=D[O]*X,N+=z*Math.cos(y),Y+=z*Math.sin(y)}b?xt.xyzPlusMatrixTimesXYZ(y,this.localToWorld.matrix,{x:N,y:Y,z:0},y):y.addXYZInPlace(N,Y,0)}refreshComputedProperties(){this._curvature01=Re.create(Rn.radiusToCurvature(this.radius01.x0),Rn.radiusToCurvature(this.radius01.x1)),this._globalStrokes.clear();const y=j.create();this._globalStrokes.appendStrokePoint(y);const k=1/16;for(let M=1;M<=16;M++){const b=(M-1)*k,E=M*k;this.fullSpiralIncrementalIntegral(y,b,E,!1),this._globalStrokes.appendStrokePoint(y)}if(this._globalStrokes.tryTransformInPlace(this.localToWorld),!this.activeFractionInterval.isExact01){void 0===this._activeStrokes&&(this._activeStrokes=Me.create()),this._activeStrokes.clear();for(let y=0;y<=16;y++){const M=y*k;this._activeStrokes.addPoint(this.fractionToPoint(M))}}}static createRadiusRadiusBearingBearing(y,k,M,b,E){const D=Rn.radiusRadiusSweepRadiansToArcLength(y.x0,y.x1,k.sweepRadians);void 0===E&&(E="clothoid");const R=Dn.findEvaluator(E);if(R)return new Vn(E,R,y.clone(),k.clone(),M.clone(),b.clone(),D,new Bn(y.x0,y.x1,k.startAngle.clone(),k.endAngle.clone(),void 0))}static createFrom4OutOf5(y,k,M,b,E,D,R,X){void 0===y&&(y="clothoid");const z=Dn.findEvaluator(y);if(!z)return;const N=new Bn(k,M,b,E,D),Y=N.clone();return N.tryResolveAnySingleUnknown()?(void 0===R&&(R=Re.create(0,1)),new Vn(y,z,Re.create(N.radius0,N.radius1),At.createStartEnd(N.bearing0,N.bearing1),R?R.clone():Re.create(0,1),X,N.curveLength,Y)):void 0}setFrom(y){return this.localToWorld.setFrom(y.localToWorld),this.radius01.setFrom(y.radius01),this._curvature01.setFrom(y._curvature01),this.bearing01.setFrom(y.bearing01),this.localToWorld.setFrom(y.localToWorld),this.activeFractionInterval.setFrom(y.activeFractionInterval),this._arcLength01=y._arcLength01,this}clone(){return new Vn(this._spiralType,this._evaluator,this.radius01.clone(),this.bearing01.clone(),this.activeFractionInterval.clone(),this.localToWorld.clone(),this._arcLength01,this._designProperties?.clone())}tryTransformInPlace(y){const k=this.applyRigidPartOfTransform(y);return void 0!==k&&(this._curvature01.x0/=k.scale,this._curvature01.x1/=k.scale,this.radius01.x0*=k.scale,this.radius01.x1*=k.scale,this._arcLength01*=k.scale),this.refreshComputedProperties(),!0}startPoint(){return this.activeStrokes.startPoint()}endPoint(){return this.activeStrokes.endPoint()}isInPlane(y){return y.isPointInPlane(this.localToWorld.origin)&&Q.isSameCoordinate(0,this.localToWorld.matrix.dotColumnX(y.getNormalRef()))&&Q.isSameCoordinate(0,this.localToWorld.matrix.dotColumnY(y.getNormalRef()))}quickLength(){return this.curveLength()}curveLength(){return this._arcLength01*this._activeFractionInterval.absoluteDelta()}curveLengthBetweenFractions(y,k){return this._arcLength01*(this._activeFractionInterval.absoluteDelta()*Math.abs(k-y))}isSameGeometryClass(y){return y instanceof Rn}emitStrokes(y,k){this.activeStrokes.emitStrokes(y,k)}emitStrokableParts(y,k){const M=this.computeStrokeCountForOptions(k);y.startParentCurvePrimitive(this);const b=this.activeStrokes;(void 0===y.needPrimaryGeometryForStrokes||!y.needPrimaryGeometryForStrokes())&&M<=b.numPoints()?this.activeStrokes.emitStrokableParts(y,k):y.announceIntervalForUniformStepStrokes(this,M,0,1),y.endParentCurvePrimitive(this)}computeStrokeCountForOptions(y){let k;if(y){const M=Math.min(Math.abs(this.radius01.x0),Math.abs(this.radius01.x1));k=y.applyTolerancesToArc(M,this.bearing01.sweepRadians),k=y.applyMaxEdgeLength(k,this.curveLength()),k=y.applyMinStrokesPerPrimitive(k)}else k=Ie.applyAngleTol(void 0,4,this.bearing01.sweepRadians);return k}reverseInPlace(){this.activeFractionInterval.reverseInPlace(),void 0===this._activeStrokes&&(this._activeStrokes=this._globalStrokes.clone()),this._activeStrokes.reverseInPlace()}fractionToPoint(y,k){const M=this.activeFractionInterval.fractionToPoint(y),b=this._globalStrokes.packedPoints.length-1;if(y>1){k=this._globalStrokes.packedPoints.back(k);const y=1/b;let E=1,D=E+y;for(;D<M;)this.fullSpiralIncrementalIntegral(k,E,D,!0),E=D,D+=y;this.fullSpiralIncrementalIntegral(k,E,M,!0)}else if(y<0){k=this._globalStrokes.packedPoints.front(k);const y=1/b;let E=0,D=E-y;for(;D>M;)this.fullSpiralIncrementalIntegral(k,E,D,!0),E=D,D-=y;this.fullSpiralIncrementalIntegral(k,E,M,!0)}else{const y=Q.clampToStartEnd(M,0,1),E=Math.trunc(y*b),D=E/b;k=this._globalStrokes.packedPoints.getPoint3dAtUncheckedPointIndex(E,k),this.fullSpiralIncrementalIntegral(k,D,M,!0)}return k}fractionToPointAndDerivative(y,k){const M=this.activeFractionInterval.fractionToPoint(y);k=k||bt.createZero(),this.fractionToPoint(y,k.origin);const b=this.globalFractionToBearingRadians(M),E=this._arcLength01*this.activeFractionInterval.signedDelta();return this.localToWorld.matrix.multiplyXY(E*Math.cos(b),E*Math.sin(b),k.direction),k}fractionToFrenetFrame(y,k){const M=this.activeFractionInterval.fractionToPoint(y);(k=k||pt.createIdentity()).origin.setFrom(this.fractionToPoint(y)),xt.createRigidFromMatrix3d(this.localToWorld.matrix,E.XYZ,k.matrix);const b=this.globalFractionToBearingRadians(M),D=Math.cos(b),R=Math.sin(b);return k.matrix.applyGivensColumnOp(0,1,D,R),k}fractionToPointAnd2Derivatives(y,k){const M=this.activeFractionInterval.fractionToPoint(y),b=this.fractionToPoint(y),E=this.globalFractionToBearingRadians(M),D=Math.cos(E),R=Math.sin(E),X=this.activeFractionInterval.signedDelta(),z=X,N=z*X,Y=this.localToWorld.matrix.multiplyXY(z*D,z*R),O=this.localToWorld.matrix.multiplyXY(-N*R,N*D);return O.scaleInPlace(this.globalFractionToCurvature(M)),Et.createCapture(b,Y,O,k)}dispatchToGeometryHandler(y){return y.handleTransitionSpiral(this)}isAlmostEqual(y){return y instanceof Vn&&this.radius01.isAlmostEqual(y.radius01)&&this.bearing01.isAlmostEqualAllowPeriodShift(y.bearing01)&&this.localToWorld.isAlmostEqual(y.localToWorld)&&Q.isSameCoordinate(this._arcLength01,y._arcLength01)&&this.activeFractionInterval.isAlmostEqual(y.activeFractionInterval)&&this._curvature01.isAlmostEqual(y._curvature01)}}Vn.defaultSpiralType="clothoid",Vn.initWorkSpace(),function(y){y[y.Sections=0]="Sections",y[y.AlsoRuledSweep=1]="AlsoRuledSweep",y[y.AlsoMesh=2]="AlsoMesh"}(wo||(wo={}));class Ln{static addPartialSegment(y,k,M,b,E,D){(k||D>E)&&(void 0===M||void 0===b||Q.isAlmostEqualNumber(E,D)||y.tryAddChild(Ce.create(M.interpolate(E,b),M.interpolate(D,b))))}static createArcPointTangentPoint(y,k,M){const b=Ti.createCircularStartTangentEnd(y,k,M);return b instanceof Ti?b:void 0}static createFilletsInLineString(y,k,M=!0){if(Array.isArray(y))return this.createFilletsInLineString(new ce(y),k,M);if(y instanceof Me)return this.createFilletsInLineString(y.packedPoints,k,M);const b=y.length;if(b<=1)return;const E=y.getPoint3dAtCheckedPointIndex(0),D=y.getPoint3dAtCheckedPointIndex(1),R=[];R.push({fraction10:0,fraction12:0,point:E.clone()});for(let z=1;z+1<b;z++){const M=y.getPoint3dAtCheckedPointIndex(z+1);let b=0;Array.isArray(k)?z<k.length&&(b=k[z]):Number.isFinite(k)&&(b=k),0!==b?R.push(Ti.createFilletArc(E,D,M,b)):R.push({fraction10:0,fraction12:0,point:D.clone()}),E.setFromPoint3d(D),D.setFromPoint3d(M)}if(R.push({fraction10:0,fraction12:0,point:D.clone()}),!M)for(let z=1;z+1<b;z++){const y=R[z];(y.fraction10>1||y.fraction12>1||1-y.fraction10<R[z-1].fraction12||y.fraction12>1-R[z+1].fraction10)&&(y.fraction10=0,y.fraction12=0,R[z].arc=void 0)}const X=oi.create();this.addPartialSegment(X,M,R[0].point,R[1].point,R[0].fraction12,1-R[1].fraction10);for(let z=1;z+1<y.length;z++){const y=R[z],k=R[z+1];X.tryAddChild(y.arc),this.addPartialSegment(X,M,y.point,k.point,y.fraction12,1-k.fraction10)}return X}static createRectangleXY(y,k,M,b,E=0,D){let R=Q.correctSmallMetricDistance(D);const X=Math.min(y,M),z=Math.max(y,M),N=Math.min(k,b),Y=Math.max(k,b);if(R=Math.min(Math.abs(R),.5*(z-X),.5*(Y-N)),0===R)return hi.createPolygon([j.create(X,N,E),j.create(z,N,E),j.create(z,Y,E),j.create(X,Y,E),j.create(X,N,E)]);{const y=$.create(R,0,0),k=$.create(0,R,0),M=X+R,b=N+R,D=z-R,O=Y-R,B=[j.create(D,O,E),j.create(M,O,E),j.create(M,b,E),j.create(D,b,E)],V=hi.create();for(let E=0;E<4;E++){const M=B[E],b=B[(E+1)%4],D=$.createStartEnd(M,b),R=Ti.create(M,y,k,At.createStartEndDegrees(0,90));V.tryAddChild(R);const X=R.endPoint();D.isAlmostZero||V.tryAddChild(Ce.create(X,X.plus(D))),y.rotate90CCWXY(y),k.rotate90CCWXY(k)}return V}}static appendToArcInPlace(y,k,M=!1){if(y.center.isAlmostEqual(k.center)){const b=Q.split3WaySign(y.sweep.sweepRadians*k.sweep.sweepRadians,-1,0,1),E=y.angleToPointAndDerivative(y.sweep.fractionToAngle(1));y.sweep.sweepRadians<0&&E.direction.scaleInPlace(-1);const D=k.angleToPointAndDerivative(k.sweep.fractionToAngle(0));if(k.sweep.sweepRadians<0&&D.direction.scaleInPlace(-1),E.isAlmostEqual(D))return y.sweep.setStartEndRadians(y.sweep.startRadians,y.sweep.startRadians+y.sweep.sweepRadians+b*k.sweep.sweepRadians),!0;if(M&&(D.direction.scaleInPlace(-1),E.isAlmostEqual(D)))return y.sweep.setStartEndRadians(y.sweep.startRadians,y.sweep.startRadians+y.sweep.sweepRadians-b*k.sweep.sweepRadians),!0}return!1}static assembleArcChainOnEllipsoid(y,k,M=.5){const b=oi.create();for(let E=0;E+1<k.length;E++){const D=y.sectionArcWithIntermediateNormal(k[E].toAngles(),M,k[E+1].toAngles());b.tryAddChild(D)}return b}static appendGeometryQueryArray(y,k){if(y instanceof Ot)k.push(y);else if(Array.isArray(y))for(const M of y)this.appendGeometryQueryArray(M,k)}static createPipeSegments(y,k){if(y instanceof Ce)return Xi.createAxisPoints(y.startPoint(),y.endPoint(),k,k,!1);if(y instanceof Ti)return En.createAlongArc(y,k,!1);if(y instanceof ae){const M=ar.create();return M.addMiteredPipes(y,k),M.claimPolyface()}if(y instanceof ni){const M=[];for(const b of y.children){const y=this.createPipeSegments(b,k);this.appendGeometryQueryArray(y,M)}return M}}static createMiteredPipeSections(y,k){const M=[];if(y.length<2)return[];const b=$.create(),D=$.create(),R=$.create(),X=j.create();let z;if(y.vectorIndexIndex(0,1,R),y.getPoint3dAtUncheckedPointIndex(0,X),k instanceof Ti)z=k.clone(),z.center.setFrom(X),b.setFrom(k.vector0),D.setFrom(k.vector90);else{if("number"!=typeof k&&!j.isXAndY(k))return[];{const y="number"==typeof k?k:k.x,M="number"==typeof k?k:k.y,N=xt.createRigidHeadsUp(R,E.ZXY);N.columnX(b).scaleInPlace(y),N.columnY(D).scaleInPlace(M),z=Ti.create(X,b,D,At.create360())}}M.push(z);const N=$.create(),Y=$.create();for(let E=1;E<y.length;E++)N.setFromVector3d(R),y.getPoint3dAtUncheckedPointIndex(E,X),E+1<y.length?y.vectorIndexIndex(E,E+1,R):R.setFromVector3d(N),N.normalizeInPlace()&&R.normalizeInPlace()&&(N.interpolate(.5,R,Y),Un(b,N,Y,b),Un(D,N,Y,D),M.push(Ti.create(X,b,D,At.create360())));return M}static createMiteredSweepSections(y,k,M){const b={sections:[],planes:[]},E=Mi.createBisectorPlanesForDistinctPoints(y,M.wrapIfPhysicallyClosed);if(void 0!==E&&E.length>1){const t=function(y,k,M,E){const D=$.createStartEnd(y.getOriginRef(),k.getOriginRef()),R=pt.createFlattenAlongVectorToPlane(D,M.getOriginRef(),M.getNormalRef());if(void 0===R)return E;const X=E.cloneTransformed(R);return void 0===X?E:(b.planes.push(M),b.sections.push(X),X)};let y=t(E[0],E[1],E[0],k);for(let k=1;k<E.length;k++)y=t(E[k-1],E[k],E[k],y);if(M.outputSelect){const y=bn.create(b.sections,M.capped??!1);if(y&&(b.ruledSweep=y,wo.AlsoMesh===M.outputSelect)){const k=ar.create(M.strokeOptions);k.addRuledSweep(y),b.mesh=k.claimPolyface()}}return b}}static createArcPointTangentRadius(y,k,M,b,E){return Ti.createCircularStartTangentRadius(y,k,M,b,E)}static createLineSpiralSpiralLine(y,k,M,b){const E=$.createStartEnd(k,M),R=$.createStartEnd(M,b),X=E.magnitude(),z=Math.atan2(E.y,E.x),N=E.angleToXY(R),Y=.5*N.radians,O=z+N.radians,B=xt.createRotationAroundAxisIndex(D.Z,W.createRadians(z)),V=pt.createRefs(k.clone(),B),U=Vn.createFrom4OutOf5(y,0,void 0,W.createRadians(0),W.createRadians(Y),X,void 0,V);if(U){const R=z+Y,N=$.createPolar(1,W.createRadians(R)),B=N.dotProductStartEnd(k,M)/N.dotProductStartEnd(k,U.endPoint()),L=Vn.createFrom4OutOf5(y,0,void 0,W.createRadians(0),W.createRadians(Y),X*B,void 0,V),Z=E.magnitude(),q=$.createStartEnd(M,b);q.scaleToLength(Z,q);const jr=M.plus(q),Gr=xt.createRotationAroundAxisIndex(D.Z,W.createRadians(O+Math.PI)),Jr=pt.createRefs(jr,Gr),Kr=Vn.createFrom4OutOf5(y,0,-L.radius01.x1,W.zero(),void 0,L.curveLength(),Re.create(1,0),Jr);return[L,Kr]}}static createLineSpiralSpiralLineWithSpiralLength(y,k,M,b,E){const R=$.createStartEnd(k,M),X=$.createStartEnd(M,b),z=Math.atan2(R.y,R.x),N=R.angleToXY(X),Y=.5*N.radians,O=.5*(Math.PI-N.radians),B=Math.atan2(-X.y,-X.x),V=Vn.createFrom4OutOf5(y,0,void 0,W.zero(),W.createRadians(Y),E,void 0,pt.createIdentity());if(V){const R=V.fractionToPoint(1),X=k.distance(M),N=b.distance(M),U=R.y/Math.tan(O),L=Q.conditionalDivideFraction(X-U-R.x,X),Z=Q.conditionalDivideFraction(N-U-R.x,N);if(void 0!==L&&void 0!==Z){const R=xt.createRotationAroundAxisIndex(D.Z,W.createRadians(z)),X=k.interpolate(L,M),N=pt.createRefs(X,R),O=Vn.createFrom4OutOf5(y,0,void 0,W.zero(),W.createRadians(Y),E,void 0,N),V=xt.createRotationAroundAxisIndex(D.Z,W.createRadians(B)),U=b.interpolate(Z,M),q=pt.createRefs(U,V);return[O,Vn.createFrom4OutOf5(y,0,void 0,W.zero(),W.createRadians(-Y),E,void 0,q)]}}}static createLineSpiralArcSpiralLine(y,k,M,b,E,D,R){const X=$.createStartEnd(k,M);X.z=0;const z=$.createStartEnd(b,M);z.z=0;const N=X.normalize(),Y=z.normalize();if(void 0===N||void 0===Y)return;const O=N.unitPerpendicularXY(),B=Y.unitPerpendicularXY(),V=X.angleToXY(z),U=Q.split3WaySign(V.radians,1,-1,-1),L=-U,Z=U*Math.abs(R),q=L*Math.abs(R),jr=Vn.createFrom4OutOf5(y,0,Z,W.zero(),void 0,E,void 0,pt.createIdentity()),Gr=Vn.createFrom4OutOf5(y,0,q,W.zero(),void 0,D,void 0,pt.createIdentity()),Jr=jr.fractionToPointAndUnitTangent(1),Kr=Gr.fractionToPointAndUnitTangent(1),so=Jr.origin.x-Z*Jr.direction.y,no=Jr.origin.y+Z*Jr.direction.x,ro=Kr.origin.x-q*Kr.direction.y,oo=Kr.origin.y+q*Kr.direction.x,ao=$.createAdd2Scaled(N,so,O,no),co=$.createAdd2Scaled(Y,ro,B,oo),uo=J.create();if(Mt.linearSystem2d(N.x,-Y.x,N.y,-Y.y,co.x-ao.x,co.y-ao.y,uo)){const y=M.plusScaled(N,uo.x),k=M.plusScaled(Y,uo.y),b=pt.createOriginAndMatrixColumns(y,N,O,$.unitZ()),E=pt.createOriginAndMatrixColumns(k,Y,B,$.unitZ());jr.tryTransformInPlace(b),Gr.tryTransformInPlace(E);const D=jr.fractionToPointAndUnitTangent(1),R=Gr.fractionToPointAndUnitTangent(1);R.direction.scaleInPlace(-1);const X=D.direction.angleToXY(R.direction);return Z<0&&X.setRadians(-X.radians),[jr,Ln.createArcPointTangentRadius(D.origin,D.direction,Z,void 0,X),Gr]}}static planePlaneIntersectionRay(y,k){const M=y.altitudeXYZ(0,0,0),b=k.altitudeXYZ(0,0,0),E=y.normalX(),D=y.normalY(),R=y.normalZ(),X=k.normalX(),z=k.normalY(),N=k.normalZ(),Y=Q.crossProductXYXY(D,R,z,N),O=Q.crossProductXYXY(R,E,N,X),B=Q.crossProductXYXY(E,D,X,z),V=Mt.linearSystem3d(E,D,R,X,z,N,Y,O,B,-M,-b,0);if(void 0!==V)return bt.createXYZUVW(V.x,V.y,V.z,Y,O,B)}}function Un(y,k,M,b){const E=y.dotProduct(M),D=k.dotProduct(M),R=Q.safeDivideFraction(E,D,0);return y.plusScaled(k,-R,b)}class Zn extends Ae{constructor(y){super(),this._localPoint=j.create(),this._worldPoint=j.create(),this._perpVector=$.createZero(),this._maxDistance=0,this._localToWorld=y.toRigidZFrame()}announcePoint(y){this._localToWorld.multiplyInversePoint3d(y,this._localPoint);const k=this._localPoint.magnitudeXY();k>=this._maxDistance&&(this._maxDistance=k,this._perpVector.setFromPoint3d(this._localPoint),this._perpVector.z=0,this._localToWorld.matrix.multiplyXY(this._localPoint.x,this._localPoint.y,this._perpVector))}handleLineSegment3d(y){this.announcePoint(y.startPoint(this._worldPoint)),this.announcePoint(y.endPoint(this._worldPoint))}handleLineString3d(y){for(let k=0;k<y.numPoints();k++)y.pointAt(k,this._worldPoint),this.announcePoint(this._worldPoint)}handleArc3d(y){const k=Ie.applyAngleTol(void 0,3,y.sweep.sweepRadians,.1),M=1/k;for(let b=0;b<=k;b++)y.fractionToPoint(b*M,this._worldPoint),this.announcePoint(this._worldPoint)}static computeMaxVectorFromRay(y,k){const M=new Zn(y);return k.dispatchToGeometryHandler(M),M._perpVector.clone()}static buildRotationalNormalsInLineStrings(y,k,M){if(y instanceof Me){const b=y.packedPoints,E=y.packedDerivatives,D=y.ensureEmptySurfaceNormals();if(E&&D){const E=$.create(),R=$.create(),X=j.create(),z=b.length;for(let N=0;N<z;N++)b.getPoint3dAtUncheckedPointIndex(N,X),k.perpendicularPartOfVectorToTarget(X,E),E.isAlmostZero?k.direction.crossProduct(M,R):k.direction.crossProduct(E,R),y.packedDerivatives.getVector3dAtCheckedVectorIndex(N,E),E.crossProduct(R,R),R.normalizeInPlace(),D.push(R)}}else if(y.children){const b=y.children;for(const y of b)this.buildRotationalNormalsInLineStrings(y,k,M)}}}class qn{startSweeps(y,k,M){return!0}endSweeps(y,k,M){return!0}}class Wn extends qn{constructor(){super(),this.myMap=Nt.createWithComponentIndex()}startPass(y){return 0===y?(this.myMap.numStroke=0,!0):1===y}visit(y,k){return 0===y?(k.numStroke>this.myMap.numStroke&&(this.myMap.numStroke=k.numStroke),!0):1===y&&(k.numStroke=this.myMap.numStroke,!0)}endPass(y){return!0}}class Gn extends qn{constructor(){super(),this.maxCurveLength=0}startPass(y){return 0===y?(this.maxCurveLength=0,!0):1===y}visit(y,k){return 0===y?(this.maxCurveLength=Q.maxXY(k.curveLength,this.maxCurveLength),!0):1===y&&(k.a0=0,k.a1=this.maxCurveLength,!0)}endPass(y){return!0}}class Hn{constructor(y,k){this.parent=y,this.maps=[],this.options=k}static createForCurveChain(y,k){const M=new Hn(y,k);M.parent=y;for(const b of y.children)b.computeAndAttachRecursiveStrokeCounts(k),b.strokeData&&M.maps.push(b.strokeData);return M}getStrokes(){const y=Me.create();this.options&&(this.options.needNormals||this.options.needParams)&&(y.ensureEmptyFractions(),y.ensureEmptyDerivatives(),y.ensureEmptyUVParams());for(const k of this.maps)k.primitive&&k.primitive.addMappedStrokesToLineString3D(k,y);return y}static applySummed01LimitsWithinArray(y,k){let M=k;for(const b of y)b.a0+=M,b.componentData?b.a1=this.applySummed01LimitsWithinArray(b.componentData,b.a0):b.a1+=M,M=b.a1;return M}applySummed01Limits(y){return Hn.applySummed01LimitsWithinArray(this.maps,y)}}class Jn{constructor(y){this.parent=y,this.chains=[]}static createForParityRegionOrChain(y,k){const M=new Jn(y);if(y instanceof bi)for(const b of y.children){const y=Hn.createForCurveChain(b,k);M.chains.push(y)}else y instanceof ni&&M.chains.push(Hn.createForCurveChain(y,k));return M}static areSectionsCompatible(y,k){if(y.length<2)return!0;const M=y[0].chains.length;for(let b=1;b<y.length;b++){if(y[b].chains.length!==M)return!1;for(let M=0;M<y[0].chains.length;M++){const E=y[0].chains[M].maps.length;if(y[b].chains[M].maps.length!==E)return!1;for(let D=0;D<E;D++)if(!y[0].chains[M].maps[D].isCompatibleComponentStructure(y[b].chains[M].maps[D],k))return!1}}return!0}static remapa0a1WithinEachChain(y){for(const k of y)for(const y of k.chains)y.applySummed01Limits(0)}static applyMultipassVisitorCallbackNoComponents(y,k,M,b,E){const D=y.length;if(!E.startSweeps(k,M,b))return!1;if(void 0===b)for(let R=0;E.startPass(R);R++){for(let b=0;b<D;b++)if(!E.visit(R,y[b].chains[k].maps[M]))return!1;if(!E.endPass(R))return!1}else for(let R=0;E.startPass(R);R++){for(let X=0;X<D;X++)if(!E.visit(R,y[X].chains[k].maps[M].componentData[b]))return!1;if(!E.endPass(R))return!1}return!!E.endSweeps(k,M,b)}static runMultiPassVisitorAtCorrespondingPrimitives(y,k){const M=y[0].chains.length;for(let b=0;b<M;b++){const M=y[0].chains[b].maps.length;for(let E=0;E<M;E++)if(y[0].chains[b].maps[E].componentData){const M=y[0].chains[b].maps[E].componentData.length;for(let D=0;D<M;D++)if(!this.applyMultipassVisitorCallbackNoComponents(y,b,E,D,k))return!1}else if(!this.applyMultipassVisitorCallbackNoComponents(y,b,E,void 0,k))return!1}return!0}static enforceStrokeCountCompatibility(y){if(y.length<2)return!0;if(!Jn.areSectionsCompatible(y,!1))return!1;const k=new Wn;return this.runMultiPassVisitorAtCorrespondingPrimitives(y,k),!0}static enforceCompatibleDistanceSums(y){if(y.length<2)return!0;if(!Jn.areSectionsCompatible(y,!1))return!1;const k=new Gn;return this.runMultiPassVisitorAtCorrespondingPrimitives(y,k),this.remapa0a1WithinEachChain(y),!0}getStrokes(){if(1===this.chains.length)return this.chains[0].getStrokes();{const y=bi.create();for(const k of this.chains){const M=k.getStrokes();M instanceof Me&&y.tryAddChild(hi.create(M))}return y}}static extendDistanceRangeBetweenStrokes(y,k,M){if(y instanceof Me){if(k instanceof Me&&y.numPoints()===k.numPoints()){const b=y.numPoints(),E=j.create(),D=j.create(),R=y.packedPoints,X=k.packedPoints;for(let y=0;y<b;y++)R.getPoint3dAtCheckedPointIndex(y,E),X.getPoint3dAtCheckedPointIndex(y,D),M.extendX(E.distance(D));return!0}}else if(y instanceof bi){if(k instanceof bi){const b=y.children,E=k.children,D=b.length;if(D===E.length){for(let y=0;y<D;y++)if(!this.extendDistanceRangeBetweenStrokes(b[y],E[y],M))return!1;return!0}}}else if(y instanceof ni&&k instanceof ni){const b=y.children,E=k.children,D=b.length;if(D===E.length){for(let y=0;y<D;y++)if(!this.extendDistanceRangeBetweenStrokes(b[y],E[y],M))return!1;return!0}}return!1}}class Qn{constructor(y,k,M){this.surface=y,this.point=M||j.createZero(),this.uv=k||H.createZero(),this.a=0}static createSurfaceUVPoint(y,k,M){const b=new Qn(y);return k&&b.uv.setFrom(k),b.point.setFromPoint3d(M),b}static createSurfaceUVNumbersPoint(y,k,M,b){const E=new Qn(y);return E.uv.x=k,E.uv.y=M,E.point.setFromPoint3d(b),E}}class Kn{constructor(y,k){this.curveDetail=y,this.surfaceDetail=k}}class jn{constructor(y,k,M,b){this.point00=y,this.point10=k,this.point01=M,this.point11=b}static create(y,k,M,b){return new jn(y.clone(),k.clone(),M.clone(),b.clone())}static createXYZ(y,k,M,b,E,D,R,X,z,N,Y,O){return new jn(j.create(y,k,M),j.create(b,E,D),j.create(R,X,z),j.create(N,Y,O))}clone(){return new jn(this.point00.clone(),this.point10.clone(),this.point01.clone(),this.point11.clone())}isAlmostEqual(y){return this.point00.isAlmostEqual(y.point00)&&this.point10.isAlmostEqual(y.point10)&&this.point01.isAlmostEqual(y.point01)&&this.point11.isAlmostEqual(y.point11)}tryTransformInPlace(y){return y.multiplyPoint3d(this.point00,this.point00),y.multiplyPoint3d(this.point10,this.point10),y.multiplyPoint3d(this.point01,this.point01),y.multiplyPoint3d(this.point11,this.point11),!0}cloneTransformed(y){const k=this.clone();return k.tryTransformInPlace(y),k}extendRange(y,k){k?(y.extendTransformedPoint(k,this.point00),y.extendTransformedPoint(k,this.point10),y.extendTransformedPoint(k,this.point01),y.extendTransformedPoint(k,this.point11)):(y.extendPoint(this.point00),y.extendPoint(this.point10),y.extendPoint(this.point01),y.extendPoint(this.point11))}uvFractionToPoint(y,k,M){const b=(1-y)*(1-k),E=y*(1-k),D=(1-y)*k,R=y*k;return j.create(b*this.point00.x+E*this.point10.x+D*this.point01.x+R*this.point11.x,b*this.point00.y+E*this.point10.y+D*this.point01.y+R*this.point11.y,b*this.point00.z+E*this.point10.z+D*this.point01.z+R*this.point11.z,M)}uvFractionToPointAndTangents(y,k,M){const b=1-y,E=1-k,D=b*E,R=y*E,X=b*k,z=y*k;return Et.createOriginAndVectorsXYZ(D*this.point00.x+R*this.point10.x+X*this.point01.x+z*this.point11.x,D*this.point00.y+R*this.point10.y+X*this.point01.y+z*this.point11.y,D*this.point00.z+R*this.point10.z+X*this.point01.z+z*this.point11.z,E*(this.point10.x-this.point00.x)+k*(this.point11.x-this.point01.x),E*(this.point10.y-this.point00.y)+k*(this.point11.y-this.point01.y),E*(this.point10.z-this.point00.z)+k*(this.point11.z-this.point01.z),b*(this.point01.x-this.point00.x)+y*(this.point11.x-this.point10.x),b*(this.point01.y-this.point00.y)+y*(this.point11.y-this.point10.y),b*(this.point01.z-this.point00.z)+y*(this.point11.z-this.point10.z),M)}static conditionalPivot(y,k,M,b){if(Math.abs(k[b][y])>Math.abs(k[M][y])){const y=k[M];k[M]=k[b],k[b]=y}}intersectRay(y){const k=this.point10.minus(this.point00),M=this.point01.minus(this.point00),b=this.point11.minus(this.point10);b.subtractInPlace(M);const E=[new Float64Array([-y.direction.x,this.point00.x-y.origin.x,k.x,M.x,b.x]),new Float64Array([-y.direction.y,this.point00.y-y.origin.y,k.y,M.y,b.y]),new Float64Array([-y.direction.z,this.point00.z-y.origin.z,k.z,M.z,b.z])];jn.conditionalPivot(0,E,0,1),jn.conditionalPivot(0,E,0,2),Mt.eliminateFromPivot(E[0],0,E[1],-1),Mt.eliminateFromPivot(E[0],0,E[2],-1);const D=Mt.solveBilinearPair(E[1][1],E[1][2],E[1][3],E[1][4],E[2][1],E[2][2],E[2][3],E[2][4]);if(D){const k=[];for(const M of D){const b=-(E[0][1]+E[0][2]*M.x+(E[0][3]+E[0][4]*M.x)*M.y)/E[0][0],D=y.fractionToPoint(b);k.push(new Kn(vt.createRayFractionPoint(y,b,D),Qn.createSurfaceUVPoint(this,M,D)))}return k}}maxUEdgeLength(){return Q.maxXY(this.point00.distance(this.point10),this.point01.distance(this.point11))}maxVEdgeLength(){return Q.maxXY(this.point00.distance(this.point01),this.point10.distance(this.point11))}}class $n{static sampledRangeOfOffsetPatch(y,k,M,b){const E=ut.createNull(),D=1/(M=Math.ceil(Q.clamp(M,2,500))),R=1/(b=Math.ceil(Q.clamp(b,2,500))),X=j.create(),z=Et.createXYPlane();let N,Y;for(let O=0;O<=b;O++){Y=O*R;for(let b=0;b<=M;b++)if(N=b*D,void 0!==k){y.uvFractionToPointAndTangents(N,Y,z);const M=z.unitNormal();void 0!==M&&(z.origin.addScaledInPlace(M,k),E.extend(z.origin))}else y.uvFractionToPoint(N,Y,X),E.extendXYZ(X.x,X.y,X.z)}return E}static sampledRangeOfOffsetEllipsoidPatch(y,k,M){const b=Ie.applyAngleTol(M,2,y.latitudeSweep.sweepRadians,W.degreesToRadians(5)),E=Ie.applyAngleTol(M,2,y.longitudeSweep.sweepRadians,W.degreesToRadians(5));return this.sampledRangeOfOffsetPatch(y,k,b,E)}constructor(){}static createLinestringOnUVLine(y,k,M,b,E,D,R=!1,X=!1){const z=Me.create(),N=j.create();let Y,O,B;const V=D+1;for(let U=0;U<V;U++)Y=U/D,O=Q.interpolate(k,Y,b),B=Q.interpolate(M,Y,E),y.uvFractionToPoint(O,B,N),z.addPoint(N),R&&z.addUVParamAsUV(O,B),X&&z.addFraction(Y);return z}}class tr{static pointsClone(){const y=[];for(const k of this.points)y.push(k.clone());return y}}tr.points=[j.create(0,0,0),j.create(1,0,0),j.create(0,1,0),j.create(1,1,0),j.create(0,0,1),j.create(1,0,1),j.create(0,1,1),j.create(1,1,1)],tr.primaryCapId=-1,tr.cornerIndexCCW=[[1,0,2,3],[4,5,7,6],[0,1,5,4],[1,3,7,5],[3,2,6,7],[2,0,4,6]],tr.partnerFace=[[5,4,3,2],[2,3,4,5],[0,3,1,5],[0,4,1,2],[0,5,1,3],[0,2,1,4]],tr.faceId=[[tr.primaryCapId,0],[tr.primaryCapId,1],[0,0],[0,1],[0,2],[0,3]],tr.faceDirections=[[[0,1,2],[-1,1,-1]],[[0,1,2],[1,1,1]],[[0,2,1],[1,-1,1]],[[1,2,0],[1,1,1]],[[0,2,1],[-1,1,1]],[[1,2,0],[-1,1,-1]]],tr.axisEdgeVertex=[[[0,1],[2,3],[4,5],[6,7]],[[0,2],[1,3],[4,6],[5,7]],[[0,4],[1,5],[2,6],[3,7]]];class er{constructor(y,k,M){this.points=y,this.begin=k,this.end=M}static createComplete(y){return new this(y,0,y.length)}static createBeginEnd(y,k,M){return new this(y,k,M)}static createBeginLength(y,k,M){return new this(y,k,k+M)}advanceBegin(){return this.begin++,this.begin<this.end}advanceEnd(){return this.end++,this.end>this.points.length&&(this.end=this.points.length),this.begin<this.end}localIndexToParentIndex(y){if(y>=0){const k=this.begin+y;if(k<this.points.length)return k}}get isValidSubset(){return 0===this.length||void 0!==this.localIndexToParentIndex(0)&&void 0!==this.localIndexToParentIndex(this.length-1)}restrictEnd(){this.end>this.points.length&&(this.end=this.points.length)}get isNonEmpty(){return this.begin<this.end}advanceToTail(y){return this.begin=y.end-1,this.isNonEmpty}advanceToHead(y){return this.begin=y.begin,this.isNonEmpty}setFrom(y,k,M){this.points=y.points,this.begin=void 0===k?y.begin:k,this.end=void 0===M?y.end:M,this.restrictEnd()}get length(){return this.end>this.begin?this.end-this.begin:0}get isSingleton(){return this.begin+1===this.end}}class ir extends er{}class sr extends ls{constructor(y,k,M,b,E,D){super(y,k,M),this._isValid=D,this._quality=E,this.id=b}setFrom(y){return super.setFrom(y),this._isValid=y._isValid,this._quality=y._quality,this.id=y.id,this}static createFromIndexedXYZ(y,k,M,b,E,D,R,X){X||(X=new sr(j.create(),j.create(),j.create(),R,0,!1)),X.id=R;let z=0;return void 0!==y.getPoint3dAtCheckedPointIndex(k,X.points[0])&&z++,void 0!==M.getPoint3dAtCheckedPointIndex(b,X.points[1])&&z++,void 0!==E.getPoint3dAtCheckedPointIndex(D,X.points[2])&&z++,3===z?X.updateAspectRatio():X.markInvalid(),X}get isValid(){return this._isValid}markInvalid(y){this._isValid=!1,void 0!==y&&(this._quality=y)}updateAspectRatio(){this._quality=super.aspectRatio,this._isValid=this._quality>0}clone(y){return y?y.setFrom(this):new sr(this.points[0].clone(),this.points[1].clone(),this.points[2].clone(),this.id,this._quality,this._isValid)}static copyWithLowerQuality(y,k,M){if(M=y.clone(M),k.isValid){const b=y.dotProductOfCrossProductsFromOrigin(k);M._quality=Q.minXY(y.aspectRatio,k.aspectRatio),b<0&&(M._quality-=1)}return M}static updateIfOtherHasHigherQuality(y,k){k.isValid&&k._quality>y._quality&&y.setFrom(k)}}class nr{constructor(y){this._turnRadians=y,this._xyzA=j.create(),this._xyzB=j.create(),this._forwardA=$.create(),this._forwardB=$.create(),this._vector1=$.create(),this._crossA=$.create(),this._crossB=$.create()}isForwardVector(y,k,M){if(y.dotProduct(k)<=0)return!1;const b=y.angleFromPerpendicular(M);return!(Math.abs(b.radians)>this._turnRadians)}isPlanarBase(y,k,M,b,E,D,R,X,z,N){return k+1<y.length&&b+1<M.length&&(y.getPoint3dAtUncheckedPointIndex(k,E),M.getPoint3dAtUncheckedPointIndex(b,X),y.vectorXYAndZIndex(E,k+1,R),M.vectorXYAndZIndex(X,b+1,N),$.createStartEnd(E,X,this._vector1),this._vector1.crossProduct(R,D),this._vector1.crossProduct(N,z),!E.isAlmostEqual(X)&&D.angleTo(z).radians<this._turnRadians)}advanceToPlanarLimit(y,k,M,b,E,D,R,X){for(k.setFrom(y,y.begin,M);k.end<y.end&&(k.points.vectorXYAndZIndex(b,k.end,this._vector1),this.isForwardVector(this._vector1,D,E))&&this.isForwardVector(this._vector1,X,R)&&(!(k.end>0)||(k.points.vectorIndexIndex(k.end-1,k.end,this._vector1),this.isForwardVector(this._vector1,D,E)));)k.end++}addGreedy(y,k,M,b=!1){for(y.restrictEnd(),k.restrictEnd();y.length>1&&k.length>1;)if(this._triangleA1=sr.createFromIndexedXYZ(y.points,y.begin,y.points,y.begin+1,k.points,k.begin,1,this._triangleA1),this._triangleA2=sr.createFromIndexedXYZ(y.points,y.begin+1,y.points,y.begin+2,k.points,k.begin,2,this._triangleA2),this._triangleA3=sr.createFromIndexedXYZ(y.points,y.begin,y.points,y.begin+1,k.points,k.begin+1,3,this._triangleA3),this._triangleB1=sr.createFromIndexedXYZ(k.points,k.begin+1,k.points,k.begin,y.points,y.begin,-1,this._triangleB1),this._triangleB2=sr.createFromIndexedXYZ(k.points,k.begin+2,k.points,k.begin+1,y.points,y.begin,-2,this._triangleB2),this._triangleB3=sr.createFromIndexedXYZ(k.points,k.begin+1,k.points,k.begin,y.points,y.begin+1,-3,this._triangleB3),this._bestTriangle=sr.copyWithLowerQuality(this._triangleA1,this._triangleB3,this._bestTriangle),this._workTriangle=sr.copyWithLowerQuality(this._triangleB1,this._triangleA3,this._workTriangle),sr.updateIfOtherHasHigherQuality(this._bestTriangle,this._workTriangle),this._bestTriangle.id>0){if(y.advanceBegin(),M(this._bestTriangle),b)return}else if(k.advanceBegin(),M(this._bestTriangle),b)return;if(y.isSingleton)for(;k.length>=2;)this._workTriangle=sr.createFromIndexedXYZ(k.points,k.begin+1,k.points,k.begin,y.points,y.begin,0,this._workTriangle),M(this._workTriangle),k.advanceBegin();if(k.isSingleton)for(;y.length>=2;)this._workTriangle=sr.createFromIndexedXYZ(y.points,y.begin,y.points,y.begin+1,k.points,k.begin,0,this._workTriangle),M(this._workTriangle),y.advanceBegin()}emitTriangles(y,k,M){this.emitTrianglesGo(rr(y),rr(k),M)}emitTrianglesGo(y,k,M){const b=ir.createComplete(y),E=ir.createComplete(k),D=ir.createComplete(y),R=ir.createComplete(k);for(;b.length>0&&E.length>0&&(b.length>1||E.length>1);)this.isPlanarBase(y,b.begin,k,E.begin,this._xyzA,this._crossA,this._forwardA,this._xyzB,this._crossB,this._forwardB)?(this.advanceToPlanarLimit(b,D,b.begin+1,this._xyzA,this._crossA,this._forwardA,this._crossB,this._forwardB),this.advanceToPlanarLimit(E,R,E.begin+1,this._xyzB,this._crossB,this._forwardB,this._crossA,this._forwardA),this.addGreedy(D,R,M),b.advanceToTail(D),E.advanceToTail(R)):this.isPlanarBase(y,b.begin+1,k,E.begin,this._xyzA,this._crossA,this._forwardA,this._xyzB,this._crossB,this._forwardB)?(D.setFrom(b,b.begin,b.begin+2),R.setFrom(E,E.begin,E.begin+1),this.addGreedy(D,R,M),b.advanceToTail(D),E.advanceToTail(R)):this.isPlanarBase(y,b.begin,k,E.begin+1,this._xyzA,this._crossA,this._forwardA,this._xyzB,this._crossB,this._forwardB)?(D.setFrom(b,b.begin,b.begin+1),R.setFrom(E,E.begin,E.begin+2),this.addGreedy(D,R,M),b.advanceToTail(D),E.advanceToTail(R)):b.length>1&&E.length>1?(D.setFrom(b,b.begin,b.begin+2),R.setFrom(E,E.begin,E.begin+2),this.addGreedy(D,R,M,!0),b.advanceToHead(D),E.advanceToHead(R)):b.length>1?(D.setFrom(b,b.begin,b.begin+2),R.setFrom(E),this.addGreedy(D,R,M),b.advanceToTail(D),E.advanceToTail(R)):E.length>1&&(D.setFrom(b),R.setFrom(E,E.begin,E.begin+2),this.addGreedy(D,R,M),b.advanceToTail(D),E.advanceToTail(R));this.addGreedy(b,E,M)}static createContext(y=this.defaultNearColinearAngle){return new nr(y.radians)}}function rr(y,k=Q.smallMetricDistance){let M=!1;const b=y.length;for(let R=0;R+1<b;R++)if(y.distanceIndexIndex(R,R+1)<=k){M=!0;break}if(!M)return y;const E=new nt(b);E.pushXYZ(y.getXAtUncheckedPointIndex(0),y.getYAtUncheckedPointIndex(0),y.getZAtUncheckedPointIndex(0));let D=0;for(let R=1;R<b;R++)y.distanceIndexIndex(D,R)>k&&(E.pushXYZ(y.getXAtUncheckedPointIndex(R),y.getYAtUncheckedPointIndex(R),y.getZAtUncheckedPointIndex(R)),D=R);return y.distanceIndexIndex(0,b-1)<=k&&(E.pop(),E.pushFromGrowableXYZArray(E,0)),E}nr.defaultNearColinearAngle=W.createDegrees(15);class or{constructor(y=!1,k=!1,M=!1){this.xyz=j.create(),this.normalIndex=-1,this.uvIndex=-1,this.xyzIndex=-1,y&&(this.normal=$.create()),k&&(this.uv=H.create(),this.uvIndex=-1),M&&(this.sectionDerivative=$.create())}copyContentsFrom(y){this.xyz.setFromPoint3d(y.xyz),this.xyzIndex=y.xyzIndex,this.normal&&this.normal.setFromVector3d(y.normal),this.normalIndex=y.normalIndex,this.uv&&this.uv.setFrom(y.uv),this.uvIndex=y.uvIndex,this.sectionDerivative&&this.sectionDerivative.setFrom(y.sectionDerivative)}loadIndexedPointAndDerivativeCoordinatesFromPackedArrays(y,k,M,b,E){k.getPoint3dAtCheckedPointIndex(y,this.xyz),this.uv&&b&&void 0!==E&&this.uv.set(b.atUncheckedIndex(y),E),this.xyzIndex=-1,this.normalIndex=-1,this.uvIndex=-1,void 0!==this.sectionDerivative&&void 0!==M&&M.getVector3dAtCheckedVectorIndex(y,this.sectionDerivative)}static suppressSmallUnitVectorComponents(y){const k=Q.smallFloatingPoint;Math.abs(y.x)<k&&(y.x=0),Math.abs(y.y)<k&&(y.y=0),Math.abs(y.z)<k&&(y.z=0)}static computeNormalsAlongRuleLine(y,k){if(y.sectionDerivative&&k.sectionDerivative){const M=or._edgeVector;$.createStartEnd(y.xyz,k.xyz,M),y.sectionDerivative.crossProduct(M,y.normal),k.sectionDerivative.crossProduct(M,k.normal),y.normal.normalizeInPlace(),k.normal.normalizeInPlace(),or.suppressSmallUnitVectorComponents(y.normal),or.suppressSmallUnitVectorComponents(k.normal)}}}or._edgeVector=$.create();class ar extends Pe{get options(){return this._options}get reversedFlag(){return this._reversed}claimPolyface(y=!0,k=Q.smallMetricDistance){return y&&this._polyface.data.compress(k),this._polyface}toggleReversedFacetFlag(){this._reversed=!this._reversed}constructor(y){super(),this._options=y||Ie.createForFacets(),this._polyface=ji.create(this._options.needNormals,this._options.needParams,this._options.needColors,this._options.needTwoSided),this._reversed=!1}static create(y){return new ar(y)}addTransformedUnitBox(y){this.addTransformedRangeMesh(y,ut.createXYZXYZ(0,0,0,1,1,1))}addTransformedRangeMesh(y,k,M){const b=this._polyface.data.pointCount,E=k.corners();for(const R of E)this._polyface.addPoint(y.multiplyPoint3d(R));let D=0;for(const R of tr.cornerIndexCCW){if(!M||D<M.length&&M[D]){const y=R.map((y=>y+b));this._reversed&&y.reverse(),this._options.shouldTriangulate?(this.addIndexedTrianglePointIndexes(y[0],y[1],y[2],!1),this.addIndexedTrianglePointIndexes(y[0],y[2],y[3],!1)):this.addIndexedQuadPointIndexes(y[0],y[1],y[3],y[2],!1),this._polyface.terminateFacet()}D++}}addTriangleFan(y,k,M){const b=k.numPoints();if(b>2){M&&this.toggleReversedFacetFlag();const E=this.addPoint(y);let D=this.findOrAddPointInLineString(k,0),R=0;for(let y=1;y<b;y++)R=this.findOrAddPointInLineString(k,y),this.addIndexedTrianglePointIndexes(E,D,R),D=R;M&&this.toggleReversedFacetFlag()}}addTrianglesInUncheckedConvexPolygon(y,k){const M=y.numPoints();if(M>2){let b,E;k&&this.toggleReversedFacetFlag(),this._options.needNormals&&(b=y.quickUnitNormal(ar._workVectorFindOrAdd),k&&b.scaleInPlace(-1),E=this._polyface.addNormal(b));const D=this._options.needParams?y.packedUVParams:void 0;let R=-1,X=-1,z=-1;D&&(R=this.addParamInGrowableXYArray(D,0),X=this.addParamInGrowableXYArray(D,1));const N=this.findOrAddPointInLineString(y,0);let Y=this.findOrAddPointInLineString(y,1),O=0,B=M;y.isPhysicallyClosed&&B--;for(let k=2;k<B;k++,Y=O,X=z)O=this.findOrAddPointInLineString(y,k),this.addIndexedTrianglePointIndexes(N,Y,O,!1),void 0!==E&&this.addIndexedTriangleNormalIndexes(E,E,E),D&&(z=this.addParamInGrowableXYArray(D,k),this.addIndexedTriangleParamIndexes(R,X,z)),this._polyface.terminateFacet();k&&this.toggleReversedFacetFlag()}}addPoint(y){return this._polyface.addPoint(y)}findOrAddPoint(y){return this.addPoint(y)}addParamXY(y,k){return this._polyface.addParamUV(y,k)}findOrAddParamXY(y,k){return this.addParamXY(y,k)}findOrAddPointInLineString(y,k,M,b){const E=y.pointAt(k,ar._workPointFindOrAddA);if(E)return M&&M.multiplyPoint3d(E,E),this._polyface.addPoint(E,b)}findOrAddPointInGrowableXYZArray(y,k,M,b){const E=y.getPoint3dAtCheckedPointIndex(k,ar._workPointFindOrAddA);if(E)return M&&M.multiplyPoint3d(E,E),this._polyface.addPoint(E,b)}findOrAddNormalInGrowableXYZArray(y,k,M,b){const E=y.getVector3dAtCheckedVectorIndex(k,ar._workVectorFindOrAdd);if(E)return M&&M.multiplyVector(E,E),this._polyface.addNormal(E,b)}addParamInGrowableXYArray(y,k){if(!y)return;const M=y.getPoint2dAtCheckedPointIndex(k,ar._workUVFindOrAdd);return M?this._polyface.addParam(M):void 0}findOrAddParamInGrowableXYArray(y,k){return this.addParamInGrowableXYArray(y,k)}findOrAddParamInLineString(y,k,M,b,E){const D=y.fractions&&k<y.fractions.length?y.fractions.atUncheckedIndex(k):k/y.points.length;return this._polyface.addParamUV(D,M,b,E)}findOrAddNormalInLineString(y,k,M,b,E){const D=y.packedSurfaceNormals;if(D){const y=D.getVector3dAtCheckedVectorIndex(k,ar._workVectorFindOrAdd);if(y)return M&&M.multiplyVector(y,y),this._polyface.addNormal(y,b,E)}}addPointXYZ(y,k,M){return this._polyface.addPointXYZ(y,k,M)}findOrAddPointXYZ(y,k,M){return this.addPointXYZ(y,k,M)}getUVTransformForTriangleFacet(y,k,M){const b=y.vectorTo(k),D=y.vectorTo(M),R=xt.createRigidFromColumns(b,D,E.XYZ);return pt.createOriginAndMatrix(y,R).inverse()}getNormalForTriangularFacet(y,k,M){const b=y.vectorTo(k),E=y.vectorTo(M);let D=b.crossProduct(E).normalize();return D=D||$.create(),D}addQuadFacet(y,k,M,b){if(y instanceof nt&&(y=y.getPoint3dArray()),y.length<4)return;const E=this.options.needParams,D=this.options.needNormals,R=this.options.needColors;let X,z,N,Y,O,B,V,U,L,Z,q,jr,Gr,Jr,Kr,so;if(E)if(void 0!==k&&k.length>3)X=k[0],z=k[1],N=k[2],Y=k[3];else{const k=this.getUVTransformForTriangleFacet(y[0],y[1],y[2]);void 0===k?X=z=N=Y=H.createZero():(X=H.createFrom(k.multiplyPoint3d(y[0])),z=H.createFrom(k.multiplyPoint3d(y[1])),N=H.createFrom(k.multiplyPoint3d(y[2])),Y=H.createFrom(k.multiplyPoint3d(y[3])))}if(D&&(void 0!==M&&M.length>3?(O=M[0],B=M[1],V=M[2],U=M[3]):(O=this.getNormalForTriangularFacet(y[0],y[1],y[2]),B=this.getNormalForTriangularFacet(y[0],y[1],y[2]),V=this.getNormalForTriangularFacet(y[0],y[1],y[2]),U=this.getNormalForTriangularFacet(y[0],y[1],y[2]))),R&&void 0!==b&&b.length>3&&(L=b[0],Z=b[1],q=b[2],jr=b[3]),this._options.shouldTriangulate){const k=y[0].vectorTo(y[2]),M=y[1].vectorTo(y[3]);k.magnitude()>=M.magnitude()?(this.addTriangleFacet([y[0],y[1],y[2]],E?[X,z,N]:void 0,D?[O,B,V]:void 0,R?[L,Z,q]:void 0),this.addTriangleFacet([y[0],y[2],y[3]],E?[X,N,Y]:void 0,D?[O,V,U]:void 0,R?[L,q,jr]:void 0)):(this.addTriangleFacet([y[0],y[1],y[3]],E?[X,z,Y]:void 0,D?[O,B,U]:void 0,R?[L,Z,jr]:void 0),this.addTriangleFacet([y[1],y[2],y[3]],E?[z,N,Y]:void 0,D?[B,V,U]:void 0,R?[Z,q,jr]:void 0))}else E&&(Gr=this._polyface.addParam(X),Jr=this._polyface.addParam(z),Kr=this._polyface.addParam(N),so=this._polyface.addParam(Y),this.addIndexedQuadParamIndexes(Gr,Jr,so,Kr)),D&&(Gr=this._polyface.addNormal(O),Jr=this._polyface.addNormal(B),Kr=this._polyface.addNormal(V),so=this._polyface.addNormal(U),this.addIndexedQuadNormalIndexes(Gr,Jr,so,Kr)),R&&(Gr=this._polyface.addColor(L),Jr=this._polyface.addColor(Z),Kr=this._polyface.addColor(q),so=this._polyface.addColor(jr),this.addIndexedQuadColorIndexes(Gr,Jr,so,Kr)),Gr=this.addPoint(y[0]),Jr=this.addPoint(y[1]),Kr=this.addPoint(y[2]),so=this.addPoint(y[3]),this.addIndexedQuadPointIndexes(Gr,Jr,so,Kr)}addIndexedQuadPointIndexes(y,k,M,b,E=!0){this._reversed?(this._polyface.addPointIndex(y),this._polyface.addPointIndex(M),this._polyface.addPointIndex(b),this._polyface.addPointIndex(k)):(this._polyface.addPointIndex(y),this._polyface.addPointIndex(k),this._polyface.addPointIndex(b),this._polyface.addPointIndex(M)),E&&this._polyface.terminateFacet()}addIndexedQuadParamIndexes(y,k,M,b){this._reversed?(this._polyface.addParamIndex(y),this._polyface.addParamIndex(M),this._polyface.addParamIndex(b),this._polyface.addParamIndex(k)):(this._polyface.addParamIndex(y),this._polyface.addParamIndex(k),this._polyface.addParamIndex(b),this._polyface.addParamIndex(M))}addIndexedQuadNormalIndexes(y,k,M,b){this._reversed?(this._polyface.addNormalIndex(y),this._polyface.addNormalIndex(M),this._polyface.addNormalIndex(b),this._polyface.addNormalIndex(k)):(this._polyface.addNormalIndex(y),this._polyface.addNormalIndex(k),this._polyface.addNormalIndex(b),this._polyface.addNormalIndex(M))}addIndexedQuadColorIndexes(y,k,M,b){this._reversed?(this._polyface.addColorIndex(y),this._polyface.addColorIndex(M),this._polyface.addColorIndex(b),this._polyface.addColorIndex(k)):(this._polyface.addColorIndex(y),this._polyface.addColorIndex(k),this._polyface.addColorIndex(b),this._polyface.addColorIndex(M))}addTriangleFacet(y,k,M,b){if(y.length<3)return;let E,D,R,X,z,N;if(y instanceof nt?(X=y.getPoint3dAtCheckedPointIndex(0),z=y.getPoint3dAtCheckedPointIndex(1),N=y.getPoint3dAtCheckedPointIndex(2)):(X=y[0],z=y[1],N=y[2]),this._options.needParams){if(k&&k.length>=3)E=this._polyface.addParam(k[0]),D=this._polyface.addParam(k[1]),R=this._polyface.addParam(k[2]);else{const y=this.getUVTransformForTriangleFacet(X,z,N);E=this._polyface.addParam(H.createFrom(y?y.multiplyPoint3d(X):void 0)),D=this._polyface.addParam(H.createFrom(y?y.multiplyPoint3d(z):void 0)),R=this._polyface.addParam(H.createFrom(y?y.multiplyPoint3d(z):void 0))}this.addIndexedTriangleParamIndexes(E,D,R)}if(this._options.needNormals){if(void 0!==M&&M.length>2)E=this._polyface.addNormal(M[0]),D=this._polyface.addNormal(M[1]),R=this._polyface.addNormal(M[2]);else{const y=this.getNormalForTriangularFacet(X,z,N);E=this._polyface.addNormal(y),D=this._polyface.addNormal(y),R=this._polyface.addNormal(y)}this.addIndexedTriangleNormalIndexes(E,D,R)}this._options.needColors&&void 0!==b&&b.length>2&&(E=this._polyface.addColor(b[0]),D=this._polyface.addColor(b[1]),R=this._polyface.addColor(b[2]),this.addIndexedTriangleColorIndexes(E,D,R)),E=this.addPoint(X),D=this.addPoint(z),R=this.addPoint(N),this.addIndexedTrianglePointIndexes(E,D,R)}addIndexedTrianglePointIndexes(y,k,M,b=!0){this._reversed?(this._polyface.addPointIndex(y),this._polyface.addPointIndex(M),this._polyface.addPointIndex(k)):(this._polyface.addPointIndex(y),this._polyface.addPointIndex(k),this._polyface.addPointIndex(M)),b&&this._polyface.terminateFacet()}addIndexedTriangleParamIndexes(y,k,M){this._reversed?(this._polyface.addParamIndex(y),this._polyface.addParamIndex(M),this._polyface.addParamIndex(k)):(this._polyface.addParamIndex(y),this._polyface.addParamIndex(k),this._polyface.addParamIndex(M))}addIndexedTriangleNormalIndexes(y,k,M){this._reversed?(this._polyface.addNormalIndex(y),this._polyface.addNormalIndex(M),this._polyface.addNormalIndex(k)):(this._polyface.addNormalIndex(y),this._polyface.addNormalIndex(k),this._polyface.addNormalIndex(M))}addIndexedTriangleColorIndexes(y,k,M){this._reversed?(this._polyface.addColorIndex(y),this._polyface.addColorIndex(M),this._polyface.addColorIndex(k)):(this._polyface.addColorIndex(y),this._polyface.addColorIndex(k),this._polyface.addColorIndex(M))}setSectorIndices(y){y.xyzIndex=this.addPoint(y.xyz),y.normal&&(y.normalIndex=this._polyface.addNormal(y.normal)),y.uv&&(y.uvIndex=this._polyface.addParam(y.uv))}addSectorTriangle(y,k,M){y.xyz.isAlmostEqual(k.xyz)||k.xyz.isAlmostEqual(M.xyz)||M.xyz.isAlmostEqual(y.xyz)||(this._options.needNormals&&this.addIndexedTriangleNormalIndexes(y.normalIndex,k.normalIndex,M.normalIndex),this._options.needParams&&this.addIndexedTriangleParamIndexes(y.uvIndex,k.uvIndex,M.uvIndex),this.addIndexedTrianglePointIndexes(y.xyzIndex,k.xyzIndex,M.xyzIndex,!0))}addSectorQuadA01B01(y,k,M,b){y.xyz.isAlmostEqual(k.xyz)&&M.xyz.isAlmostEqual(b.xyz)||(this._options.shouldTriangulate?(this.addSectorTriangle(y,k,b),this.addSectorTriangle(b,M,y)):(this._options.needNormals&&this.addIndexedQuadNormalIndexes(y.normalIndex,k.normalIndex,M.normalIndex,b.normalIndex),this._options.needParams&&this.addIndexedQuadParamIndexes(y.uvIndex,k.uvIndex,M.uvIndex,b.uvIndex),this.addIndexedQuadPointIndexes(y.xyzIndex,k.xyzIndex,M.xyzIndex,b.xyzIndex,!0)))}addBetweenLineStringsWithRuleEdgeNormals(y,k,M,b,E=!1){const D=y.packedPoints,R=M.packedPoints,X=y.packedDerivatives,z=M.packedDerivatives,N=y.fractions,Y=M.fractions,O=this._options.needNormals,B=this._options.needParams,V=new or(O,B,O),U=new or(O,B,O),L=new or(O,B,O),Z=new or(O,B,O),q=new or(O,B,O),jr=new or(O,B,O),Gr=D.length;if(!(Gr<2||Gr!==R.length)){V.loadIndexedPointAndDerivativeCoordinatesFromPackedArrays(0,D,X,N,k),L.loadIndexedPointAndDerivativeCoordinatesFromPackedArrays(0,R,z,Y,b),O&&or.computeNormalsAlongRuleLine(V,L),this.setSectorIndices(V),this.setSectorIndices(L),q.copyContentsFrom(V),jr.copyContentsFrom(L);for(let y=1;y<Gr;y++)U.loadIndexedPointAndDerivativeCoordinatesFromPackedArrays(y,D,X,N,k),Z.loadIndexedPointAndDerivativeCoordinatesFromPackedArrays(y,R,X,Y,b),or.computeNormalsAlongRuleLine(U,Z),this.setSectorIndices(U),this.setSectorIndices(Z),this.addSectorQuadA01B01(V,U,L,Z),V.copyContentsFrom(U),L.copyContentsFrom(Z);E&&this.addSectorQuadA01B01(V,q,L,jr)}}addBetweenLineStringsWithStoredIndices(y,k){const M=y.pointIndices,b=k.pointIndices;let E=y.normalIndices,D=k.normalIndices;this._options.needNormals||(E=void 0,D=void 0);let R=y.paramIndices,X=k.paramIndices;this._options.needParams||(R=void 0,X=void 0);const z=M.length;for(let N=1;N<z;N++)this.options.shouldTriangulate?(lr(M.atUncheckedIndex(N-1),M.atUncheckedIndex(N),b.atUncheckedIndex(N))&&(this.addIndexedTrianglePointIndexes(M.atUncheckedIndex(N-1),M.atUncheckedIndex(N),b.atUncheckedIndex(N),!1),E&&D&&this.addIndexedTriangleNormalIndexes(E.atUncheckedIndex(N-1),E.atUncheckedIndex(N),D.atUncheckedIndex(N-1)),R&&X&&this.addIndexedTriangleParamIndexes(R.atUncheckedIndex(N-1),R.atUncheckedIndex(N),X.atUncheckedIndex(N-1))),lr(b.atUncheckedIndex(N),b.atUncheckedIndex(N-1),M.atUncheckedIndex(N-1))&&(this.addIndexedTrianglePointIndexes(M.atUncheckedIndex(N-1),b.atUncheckedIndex(N),b.atUncheckedIndex(N-1),!1),E&&D&&this.addIndexedTriangleNormalIndexes(E.atUncheckedIndex(N-1),D.atUncheckedIndex(N),D.atUncheckedIndex(N-1)),R&&X&&this.addIndexedTriangleParamIndexes(R.atUncheckedIndex(N-1),X.atUncheckedIndex(N),X.atUncheckedIndex(N-1)))):M.atUncheckedIndex(N-1)===M.atUncheckedIndex(N)&&b.atUncheckedIndex(N-1)===b.atUncheckedIndex(N)||(this.addIndexedQuadPointIndexes(M.atUncheckedIndex(N-1),M.atUncheckedIndex(N),b.atUncheckedIndex(N-1),b.atUncheckedIndex(N),!1),E&&D&&this.addIndexedQuadNormalIndexes(E.atUncheckedIndex(N-1),E.atUncheckedIndex(N),D.atUncheckedIndex(N-1),D.atUncheckedIndex(N)),R&&X&&this.addIndexedQuadParamIndexes(R.atUncheckedIndex(N-1),R.atUncheckedIndex(N),X.atUncheckedIndex(N-1),X.atUncheckedIndex(N))),this._polyface.terminateFacet()}addBetweenTransformedLineStrings(y,k,M,b=!1){if(y instanceof Me){const E=y.points.length;let D=this.findOrAddPointInLineString(y,0,k),R=this.findOrAddPointInLineString(y,0,M);const X=D,z=R;let N=0,Y=0;for(let b=1;b<E;b++)N=this.findOrAddPointInLineString(y,b,k),Y=this.findOrAddPointInLineString(y,b,M),this.addIndexedQuadPointIndexes(D,N,R,Y),D=N,R=Y;b&&this.addIndexedQuadPointIndexes(D,X,R,z)}else{const b=y.children;if(b)for(const y of b)this.addBetweenTransformedLineStrings(y,k,M)}}addBetweenStrokeSetPair(y,k,M,b){if(y instanceof Me&&M instanceof Me)this.addBetweenLineStringsWithRuleEdgeNormals(y,k,M,b,!1);else if(y instanceof bi&&M instanceof bi){if(y.children.length===M.children.length)for(let E=0;E<y.children.length;E++)this.addBetweenStrokeSetPair(y.children[E],k,M.children[E],b)}else if(y instanceof ni&&M instanceof ni){const E=y.children,D=M.children;if(E.length===D.length)for(let y=0;y<E.length;y++){const M=E[y],R=D[y];M instanceof Me&&R instanceof Me&&this.addBetweenLineStringsWithRuleEdgeNormals(M,k,R,b)}}}addCone(y){let k=16;this._options&&(k=this._options.applyTolerancesToArc(y.getMaxRadius()));let M=1;const b=y.strokeConstantVSection(0,k,this._options),E=y.strokeConstantVSection(1,k,this._options);if(this._options){const y=nt.distanceRangeBetweenCorrespondingPoints(b.packedPoints,E.packedPoints);M=this._options.applyMaxEdgeLength(1,y.low)}const D=y.maxIsoParametricDistance();this.addUVGridBody(y,k,M,Re.create(0,D.x),Re.create(0,D.y)),this.endFace(),y.capped&&(Q.isSmallMetricDistance(y.getRadiusA())||(this.addTrianglesInUncheckedConvexPolygon(b,!0),this.endFace()),Q.isSmallMetricDistance(y.getRadiusB())||(this.addTrianglesInUncheckedConvexPolygon(E,!1),this.endFace()))}addTorusPipe(y,k,M){const b=y.getThetaFraction();let E=Q.clamp(Q.resolveNumber(k,8),4,64),D=Q.clamp(Q.resolveNumber(M,Math.ceil(16*b)),2,64);this._options&&(E=this._options.applyTolerancesToArc(y.getMinorRadius()),D=this._options.applyTolerancesToArc(y.getMajorRadius(),y.getSweepAngle().radians)),this.toggleReversedFacetFlag();const R=y.maxIsoParametricDistance();if(this.addUVGridBody(y,E,D,Re.create(0,R.x),Re.create(0,R.y)),this.toggleReversedFacetFlag(),y.capped&&b<1){const k=y.getConstructiveFrame(),M=y.getMinorRadius(),b=y.getMajorRadius(),D=2*M,R=b-M,X=b+M,z=-M,N=pt.createRowValues(D,0,0,R,0,0,-1,0,0,D,0,z),Y=k.multiplyTransformTransform(N).inverse();if(Y){const k=$n.createLinestringOnUVLine(y,0,0,1,0,E,!1,!0);k.computeUVFromXYZTransform(Y),this.addTrianglesInUncheckedConvexPolygon(k,!1)}const O=y.getSweepAngle().radians,B=Math.cos(O),V=Math.sin(O),U=pt.createRowValues(-B*D,0,-V,X*B,-V*D,0,B,X*V,0,D,0,z),L=k.multiplyTransformTransform(U).inverse();if(L){const k=$n.createLinestringOnUVLine(y,1,1,0,1,E,!1,!0);k.computeUVFromXYZTransform(L),this.addTrianglesInUncheckedConvexPolygon(k,!1)}}}addLinearSweepLineStringsXYZOnly(y,k){if(y instanceof Me){let M=j.create(),b=j.create(),E=0,D=0,R=0,X=0;const z=y.numPoints();for(let N=0;N<z;N++)M=y.pointAt(N,M),b=M.plus(k,b),D=this.addPoint(M),X=this.addPoint(b),N>0&&this.addIndexedQuadPointIndexes(E,D,R,X),E=D,R=X}else if(y instanceof ni)for(const M of y.children)this.addLinearSweepLineStringsXYZOnly(M,k)}addRotationalSweep(y){const k=y.getCurves(),M=Jn.createForParityRegionOrChain(k,this._options).getStrokes(),b=y.cloneAxisRay(),E=Zn.computeMaxVectorFromRay(b,M),D=b.direction.crossProduct(E);this._options.needNormals&&Zn.buildRotationalNormalsInLineStrings(M,b,D);const R=E.magnitude(),X=Math.abs(R*y.getSweep().radians);let z=Ie.applyAngleTol(this._options,1,y.getSweep().radians,void 0);z=Ie.applyMaxEdgeLength(this._options,z,X);for(let N=1;N<=z;N++){const k=y.getFractionalRotationTransform((N-1)/z),b=y.getFractionalRotationTransform(N/z);this.addBetweenRotatedStrokeSets(M,k,N-1,b,N)}if(y.capped){const k=y.getSweepContourRef();k.purgeFacets(),k.emitFacets(this,!0,void 0),k.emitFacets(this,!1,y.getFractionalRotationTransform(1))}}addTriangulatedRegion(y){const k=Mn.createForLinearSweep(y);k&&k.emitFacets(this,this.reversedFlag,void 0)}applyStrokeCountsToCurvePrimitives(y){const k=this._options;if(y instanceof ae)y.computeStrokeCountForOptions(k);else if(y instanceof si){const k=y.children;if(k)for(const y of k)this.applyStrokeCountsToCurvePrimitives(y)}}addBetweenStrokeSetsWithRuledNormals(y,k,M){const b=[y],E=[0];for(let D=1;D<M;D++){const R=D/M,X=Ri.interpolateBetween(y,D/M,k);b.push(X),E.push(R)}b.push(k),E.push(1);for(let D=0;D<M;D++)this.addBetweenStrokeSetPair(b[D],E[D],b[D+1],E[D+1])}createIndicesInLineString(y,k,M){const b=y.numPoints(),E=y.ensureEmptyPointIndices(),D=this.findOrAddPointInLineString(y,0,M);if(E.push(D),b>1){let k,R=D;for(let D=1;D+1<b;D++)k=this.findOrAddPointInLineString(y,D,M,R),E.push(k),R=k;k=this.findOrAddPointInLineString(y,b-1,M,D),E.push(k)}if(this._options.needNormals&&void 0!==y.packedSurfaceNormals){const k=y.ensureEmptyNormalIndices(),E=this.findOrAddNormalInLineString(y,0,M);k.push(E);let D,R=E;if(b>1){for(let E=1;E+1<b;E++)D=this.findOrAddNormalInLineString(y,E,M,R),k.push(D),R=D;D=this.findOrAddNormalInLineString(y,b-1,M,E,R),k.push(D)}}if(this._options.needParams&&void 0!==y.packedUVParams){const M=y.ensureEmptyUVIndices(),E=this.findOrAddParamInLineString(y,0,k);M.push(E);let D,R=E;if(b>1){for(let E=1;E+1<b;E++)D=this.findOrAddParamInLineString(y,E,k,R),M.push(D),R=D;D=this.findOrAddParamInLineString(y,b-1,k,R,E),M.push(D)}}}addBetweenRotatedStrokeSets(y,k,M,b,E){if(y instanceof Me){const D=y.cloneTransformed(k);this.createIndicesInLineString(D,M);const R=y.cloneTransformed(b);this.createIndicesInLineString(R,E),this.addBetweenLineStringsWithStoredIndices(D,R)}else if(y instanceof bi)for(const D of y.children)this.addBetweenRotatedStrokeSets(D,k,M,b,E);else if(y instanceof ni)for(const D of y.children)D instanceof Me&&this.addBetweenRotatedStrokeSets(D,k,M,b,E)}addLinearSweep(y){const k=y.getCurvesRef(),M=Jn.createForParityRegionOrChain(k,this._options).getStrokes(),b=y.cloneSweepVector(),E=pt.createTranslation(b),D=M.cloneTransformed(E),R=this._options.applyMaxEdgeLength(1,b.magnitude());if(this.addBetweenStrokeSetsWithRuledNormals(M,D,R),y.capped&&k.isAnyRegionType){const k=y.getSweepContourRef();k.purgeFacets();const M=k.localToWorld.matrix.dotColumnZ(b)>0;k.emitFacets(this,M,void 0),k.emitFacets(this,!M,E)}}addRuledSweep(y){const k=y.sweepContoursRef();let M,b;const E=[];for(const D of k)E.push(Jn.createForParityRegionOrChain(D.curves,this._options));if(Jn.enforceStrokeCountCompatibility(E)){Jn.enforceCompatibleDistanceSums(E);for(let y=0;y<k.length;y++){if(b=E[y].getStrokes(),b||(b=k[y].curves.cloneStroked()),y>0&&M&&b){const y=ft.createNull();if(Jn.extendDistanceRangeBetweenStrokes(M,b,y)&&!y.isNull){const k=this._options.applyMaxEdgeLength(1,y.high);this.addBetweenStrokeSetsWithRuledNormals(M,b,k)}}M=b}}return y.capped&&k[0].curves.isAnyRegionType&&(k[0].purgeFacets(),k[0].emitFacets(this,!0,void 0),k[k.length-1].purgeFacets(),k[k.length-1].emitFacets(this,!1,void 0)),!0}addSphere(y,k){let M=k||this.options.applyTolerancesToArc(y.maxAxisRadius());Q.isOdd(M)&&(M+=1);const b=Q.clampToStartEnd(Math.abs(M*y.latitudeSweepFraction),1,Math.ceil(.5*M)),E=y.strokeConstantVSection(0,M,this._options);y.capped&&!Q.isSmallMetricDistance(E.quickLength())&&(this.addTrianglesInUncheckedConvexPolygon(E,!0),this.endFace());const D=y.maxIsoParametricDistance();this.addUVGridBody(y,M,b,Re.create(0,D.x),Re.create(0,D.y)),this.endFace();const R=y.strokeConstantVSection(1,M,this._options);y.capped&&!Q.isSmallMetricDistance(R.quickLength())&&(this.addTrianglesInUncheckedConvexPolygon(R,!1),this.endFace())}addBox(y){const k=y.getCorners(),M=Q.maxXY(y.getBaseX(),y.getBaseX()),b=Q.maxXY(y.getBaseY(),y.getTopY());let E=0;for(let Y=0;Y<4;Y++)E=Q.maxXY(E,k[Y].distance(k[Y+4]));const D=this._options.applyMaxEdgeLength(1,M),R=this._options.applyMaxEdgeLength(1,b),X=this._options.applyMaxEdgeLength(1,E),z=Re.create(0,M),N=Re.create(0,E);this.addUVGridBody(jn.create(k[0],k[1],k[4],k[5]),D,X,z,N),z.shift(M),this.addUVGridBody(jn.create(k[1],k[3],k[5],k[7]),R,X,z,N),z.shift(b),this.addUVGridBody(jn.create(k[3],k[2],k[7],k[6]),D,X,z,N),z.shift(M),this.addUVGridBody(jn.create(k[2],k[0],k[6],k[4]),R,X,z,N),this.endFace(),y.capped&&(z.set(0,M),N.set(0,b),this.addUVGridBody(jn.create(k[4],k[5],k[6],k[7]),D,R,z,N),this.endFace(),z.set(0,M),N.set(0,b),this.addUVGridBody(jn.create(k[2],k[3],k[0],k[1]),D,R,z,N),this.endFace())}addPolygon(y,k){for(void 0===k&&(k=y.length);k>1&&y[k-1].isAlmostEqual(y[0]);)k--;let M=0;if(this._reversed)for(let b=k;--b>=0;)M=this.addPoint(y[b]),this._polyface.addPointIndex(M);else for(let b=0;b<k;b++)M=this.addPoint(y[b]),this._polyface.addPointIndex(M);this._polyface.terminateFacet()}addPolygonGrowableXYZArray(y){let k=y.length;for(;k>2&&Q.isSmallMetricDistance(y.distanceIndexIndex(0,k-1));)k--;for(;k>2&&Q.isSmallMetricDistance(y.distanceIndexIndex(k-2,k-1));)k--;if(3===k){const M=y.crossProductIndexIndexIndex(0,1,2).magnitude(),b=y.distanceIndexIndex(0,1)+y.distanceIndexIndex(0,2)+y.distanceIndexIndex(1,2);M<Q.smallMetricDistance*b&&(k=0)}if(k>2){let M=0;if(this._reversed)for(let b=k;--b>=0;)M=this.findOrAddPointInGrowableXYZArray(y,b),this._polyface.addPointIndex(M);else for(let b=0;b<k;b++)M=this.findOrAddPointInGrowableXYZArray(y,b),this._polyface.addPointIndex(M);this._polyface.terminateFacet()}}addFacetFromGrowableArrays(y,k,M,b,E){let D=y.length;for(;D>1&&Q.isSmallMetricDistance(y.distanceIndexIndex(0,D-1));)D--;let R=0;if(k&&k.length<D&&(k=void 0),M&&M.length<D&&(M=void 0),b&&b.length<D&&(b=void 0),E&&E.length<D&&(E=void 0),this._reversed)for(let X=D;--X>=0;)R=this.findOrAddPointInGrowableXYZArray(y,X),this._polyface.addPointIndex(R),k&&(R=this.findOrAddNormalInGrowableXYZArray(k,X),this._polyface.addNormalIndex(R)),M&&(R=this.addParamInGrowableXYArray(M,X),this._polyface.addParamIndex(R)),b&&(R=this._polyface.addColor(b[X]),this._polyface.addColorIndex(R));else for(let X=0;X<D;X++)R=this.findOrAddPointInGrowableXYZArray(y,X),this._polyface.addPointIndex(R,!E||E[X]),k&&(R=this.findOrAddNormalInGrowableXYZArray(k,X),this._polyface.addNormalIndex(R)),M&&(R=this.addParamInGrowableXYArray(M,X),this._polyface.addParamIndex(R)),b&&(R=this._polyface.addColor(b[X]),this._polyface.addColorIndex(R));this._polyface.terminateFacet()}addFacetFromVisitor(y){this.addFacetFromGrowableArrays(y.point,y.normal,y.param,y.color,y.edgeVisible)}addFacetsFromVisitor(y){for(y.reset();y.moveToNextFacet();)this.addFacetFromVisitor(y)}addFacetFromIndexedVisitor(y,k){if(k.length>y.pointIndex.length)return!1;const M=new nt(k.length),b=y.normal?new nt(k.length):void 0,E=y.param?new Fe(k.length):void 0,D=y.color?new Array(k.length):void 0,R=y.edgeVisible?new Array(k.length):void 0;for(let X=0;X<k.length;++X){const z=k[X];if(z<0||z>=y.point.length)return!1;M.pushXYZ(y.point.getXAtUncheckedPointIndex(z),y.point.getYAtUncheckedPointIndex(z),y.point.getZAtUncheckedPointIndex(z)),y.normal&&b&&b.pushXYZ(y.normal.getXAtUncheckedPointIndex(z),y.normal.getYAtUncheckedPointIndex(z),y.normal.getZAtUncheckedPointIndex(z)),y.param&&E&&E.pushXY(y.param.getXAtUncheckedPointIndex(z),y.param.getYAtUncheckedPointIndex(z)),y.color&&D&&(D[X]=y.color[z]),y.edgeVisible&&R&&(R[X]=y.edgeVisible[z])}return this.addFacetFromGrowableArrays(M,b,E,D,R),!0}addIndexedPolyface(y,k=!1,M){this._polyface.addIndexedPolyface(y,k,M)}endFace(){return this._polyface.setNewFaceData()}handleCone(y){return this.addCone(y)}handleTorusPipe(y){return this.addTorusPipe(y)}handleSphere(y){return this.addSphere(y)}handleBox(y){return this.addBox(y)}handleLinearSweep(y){return this.addLinearSweep(y)}handleRotationalSweep(y){return this.addRotationalSweep(y)}handleRuledSweep(y){return this.addRuledSweep(y)}handleLoop(y){return this.addTriangulatedRegion(y)}handleParityRegion(y){return this.addTriangulatedRegion(y)}handleUnionRegion(y){return this.addTriangulatedRegion(y)}addGeometryQuery(y){y.dispatchToGeometryHandler(this)}addGraph(y,k=y=>us.testNodeMaskNotExterior(y),M=y=>us.testMateMaskExterior(y)){let b=0;const E=this._options.needNormals,D=this._options.needParams;let R=0;E&&(R=this._polyface.addNormalXYZ(0,0,1)),y.announceFaceLoops(((y,X)=>{if(k(X)&&X.countEdgesAroundFace()>2){let y=X;do{b=this.addPointXYZ(y.x,y.y,y.z),this._polyface.addPointIndex(b,void 0===M||M(y)),D&&(b=this.addParamXY(y.x,y.y),this._polyface.addParamIndex(b)),E&&this._polyface.addNormalIndex(R),y=y.faceSuccessor}while(y!==X);this._polyface.terminateFacet()}return!0}))}addGraphFaces(y){let k=0;for(const M of y){let y=M;do{k=this.addPointXYZ(y.x,y.y,y.z),this._polyface.addPointIndex(k),y=y.faceSuccessor}while(y!==M);this._polyface.terminateFacet()}}static graphToPolyface(y,k,M=y=>us.testNodeMaskNotExterior(y),b=y=>us.testMateMaskExterior(y)){const E=ar.create(k);return E.addGraph(y,M,b),E.endFace(),E.claimPolyface()}static graphFacesToPolyface(y){const k=ar.create();return k.addGraphFaces(y),k.endFace(),k.claimPolyface()}static polygonToTriangulatedPolyface(y,k){if(k||(k=Fi.createFrameWithCCWPolygon(y)),k){const M=k.multiplyInversePoint3dArray(y);Ur.areaXY(M)<0&&M.reverse();const b=Us.createTriangulatedGraphFromSingleLoop(M);if(b){const y=this.graphToPolyface(b);return y.tryTransformInPlace(k),y}}}addCoordinateFacets(y,k,M,b=!1){for(let E=0;E<y.length;E++){const b=k?k[E]:void 0,D=M?M[E]:void 0;3===y[E].length?this.addTriangleFacet(y[E],b,D):4===y[E].length&&this.addQuadFacet(y[E],b,D)}b&&this.endFace()}addUVGridBody(y,k,M,b,E){let D,R,X,z,N=new It(k),Y=new It(k);const O=this._reversed,B=this.options.needNormals;B&&(X=new It(k),z=new It(k));const V=this.options.needParams;let U;V&&(D=new It(k),R=new It(k)),N.ensureCapacity(k),Y.ensureCapacity(k);const L=H.create(),Z=$.create(),q=1/k,jr=1/M,Gr=Et.createXYPlane();for(let Jr=0;Jr<=M;Jr++){Y.clear(),B&&z.clear(),V&&R.clear();for(let M=0;M<=k;M++){const k=M*q,D=Jr*jr;y.uvFractionToPointAndTangents(k,D,Gr),Y.push(this._polyface.addPoint(Gr.origin)),B&&(Gr.vectorU.crossProduct(Gr.vectorV,Z),Z.normalizeInPlace(),O&&Z.scaleInPlace(-1),z.push(this._polyface.addNormal(Z))),V&&R.push(this._polyface.addParam(H.create(b?b.fractionToPoint(k):k,E?E.fractionToPoint(D):D,L)))}if(Jr>0)for(let y=0;y<k;y++)this._options.shouldTriangulate?(this.addIndexedTrianglePointIndexes(N.atUncheckedIndex(y),N.atUncheckedIndex(y+1),Y.atUncheckedIndex(y),!1),B&&this.addIndexedTriangleNormalIndexes(X.atUncheckedIndex(y),X.atUncheckedIndex(y+1),z.atUncheckedIndex(y)),V&&this.addIndexedTriangleParamIndexes(D.atUncheckedIndex(y),D.atUncheckedIndex(y+1),R.atUncheckedIndex(y)),this._polyface.terminateFacet(),this.addIndexedTrianglePointIndexes(Y.atUncheckedIndex(y),N.atUncheckedIndex(y+1),Y.atUncheckedIndex(y+1),!1),B&&this.addIndexedTriangleNormalIndexes(z.atUncheckedIndex(y),X.atUncheckedIndex(y+1),z.atUncheckedIndex(y+1)),V&&this.addIndexedTriangleParamIndexes(R.atUncheckedIndex(y),D.atUncheckedIndex(y+1),R.atUncheckedIndex(y+1)),this._polyface.terminateFacet()):(this.addIndexedQuadPointIndexes(N.atUncheckedIndex(y),N.atUncheckedIndex(y+1),Y.atUncheckedIndex(y),Y.atUncheckedIndex(y+1),!1),B&&this.addIndexedQuadNormalIndexes(X.atUncheckedIndex(y),X.atUncheckedIndex(y+1),z.atUncheckedIndex(y),z.atUncheckedIndex(y+1)),V&&this.addIndexedQuadParamIndexes(D.atUncheckedIndex(y),D.atUncheckedIndex(y+1),R.atUncheckedIndex(y),R.atUncheckedIndex(y+1)),this._polyface.terminateFacet());U=Y,Y=N,N=U,V&&(U=R),R=D,D=U,B&&(U=z),z=X,X=U}N.clear(),Y.clear()}static pointsToTriangulatedPolyface(y,k){const M=Us.createTriangulatedGraphFromPoints(y,po.ReplaceIfLarger,k?.chordTol);if(M)return ar.graphToPolyface(M,k)}addGreedyTriangulationBetweenLineStrings(y,k){nr.createContext().emitTriangles(cr(y),cr(k),(y=>{this.addTriangleFacet(y.points)}))}addMiteredPipesFromPoints(y,k,M=12){const b=Ln.createMiteredPipeSections(y,k),E=j.create(),D=j.create(),R=j.create(),X=j.create();M<3&&(M=3);const z=1/M;for(let N=1;N<b.length;N++){const y=b[N-1],k=b[N];y.fractionToPoint(0,E),k.fractionToPoint(0,R);for(let b=1;b<=M;b++,E.setFromPoint3d(D),R.setFromPoint3d(X)){const M=b*z;y.fractionToPoint(M,D),k.fractionToPoint(M,X),this.addQuadFacet([E,R,X,D])}}}addMiteredPipes(y,k,M=12){if(Array.isArray(y))this.addMiteredPipesFromPoints(new ce(y),k,M);else if(y instanceof nt)this.addMiteredPipesFromPoints(y,k,M);else if(y instanceof it)this.addMiteredPipesFromPoints(y,k,M);else if(y instanceof Me)this.addMiteredPipesFromPoints(y.packedPoints,k,M);else if(y instanceof Ot){const b=Me.create();y.emitStrokes(b,this._options),this.addMiteredPipesFromPoints(b.packedPoints,k,M)}}getEdgeIndices(y){let k=-1,M=-1;for(let b=this._polyface.facetIndex0(y.facetIndex);b<this._polyface.facetIndex1(y.facetIndex);++b)y.vertexIndexA===this._polyface.data.pointIndex[b]?k=b:y.vertexIndexB===this._polyface.data.pointIndex[b]&&(M=b);return k<0||M<0?void 0:{edgeIndexA:k,edgeIndexB:M}}addSweptFace(y,k){const M=this.getEdgeIndices(y);if(void 0===M)return!1;const b=k+y.facetIndex;if(!this._polyface.isValidFacetIndex(b))return!1;const E=this._polyface.numEdgeInFacet(y.facetIndex);if(E!==this._polyface.numEdgeInFacet(b))return!1;const D=this._polyface.facetIndex0(y.facetIndex),R=this._polyface.facetIndex0(b),X=E-1-(M.edgeIndexA-D),z=E-1-(M.edgeIndexB-D),N=[M.edgeIndexB,M.edgeIndexA,R+X,R+z],Y=[];let O;void 0!==this.options.needColors&&void 0!==this._polyface.data.color&&void 0!==this._polyface.data.colorIndex&&(O=[]);for(let B=0;B<4;++B){const y=this._polyface.data.getPoint(this._polyface.data.pointIndex[N[B]]);if(void 0===y)return!1;if(Y.push(y),void 0!==O){const y=this._polyface.data.getColor(this._polyface.data.colorIndex[N[B]]);if(void 0===y)return!1;O.push(y)}}return this.addQuadFacet(Y,void 0,void 0,O),!0}addSweptIndexedPolyface(y,k,M=!1){let b=!0;const E=Fn.sumFacetAreas(y,k);Q.isAlmostEqualNumber(0,E)&&(b=!1);const D=Fn.partitionFacetIndicesByVisibilityVector(y,k,W.createDegrees(.001)),R=D[0].length,X=D[1].length;D[2].length>0&&(b=!1),R>0&&X>0&&(b=!1);const z=R>0,N=this._polyface.facetCount;this.addIndexedPolyface(y,z);const Y=this._polyface.facetCount;this.addIndexedPolyface(y,!z,pt.createTranslation(k));const O=Y-N,B=Array.from({length:O},((y,k)=>N+k)),V=Ji.createSubsetVisitor(this._polyface,B,1),U=[];Fn.createIndexedEdges(V).sortAndCollectClusters(void 0,U,void 0,void 0);const L=this._options.shouldTriangulate;this._options.shouldTriangulate=M;for(const Z of U)if(Z instanceof on)this.addSweptFace(Z,O);else if(Array.isArray(Z))for(const y of Z)this.addSweptFace(y,O);return this._options.shouldTriangulate=L,b}}function cr(y){return Array.isArray(y)?new ce(y):y instanceof Me?y.packedPoints:y}function lr(y,k,M){return y!==k&&k!==M&&M!==y}ar._workPointFindOrAddA=j.create(),ar._workVectorFindOrAdd=$.create(),ar._workUVFindOrAdd=H.create();class hr{constructor(y=5){this._activeMomentData=Ei.create(),this._activeMomentData.needOrigin=!0,this._gaussMapper=new re(y)}get momentData(){return this._activeMomentData}startParentCurvePrimitive(y){}startCurvePrimitive(y){}endCurvePrimitive(y){}endParentCurvePrimitive(y){}announceIntervalForUniformStepStrokes(y,k,M,b){this.startCurvePrimitive(y),k<1&&(k=1);const E=1/k;let D,R;for(let X=1;X<=k;X++){const z=Q.interpolate(M,(X-1)*E,b),N=X===k?b:Q.interpolate(M,X*E,b),Y=this._gaussMapper.mapXAndW(z,N);for(let k=0;k<Y;k++){R=this._gaussMapper.gaussX[k];const M=y.fractionToPointAndDerivative(R);D=this._gaussMapper.gaussW[k]*M.direction.magnitude(),this._activeMomentData.accumulateScaledOuterProduct(M.origin,D)}}}announceSegmentInterval(y,k,M,b,E,D){this._activeMomentData.accumulateLineMomentsXYZ(k,M)}announcePointTangent(y,k,M){}visitLeaves(y){if(y instanceof ae)y.emitStrokableParts(this);else if(y instanceof si)for(const k of y.children)this.visitLeaves(k)}}class dr{pushNewChain(y){const k=[];y&&k.push(y),this._chains.push(k)}findOrCreateTailChain(){return 0===this._chains.length&&this.pushNewChain(),this._chains[this._chains.length-1]}findAnyChainToConnect(y){for(let k=0;k<this._chains.length;k++){const M=this._chains[k];if(this._xyzWork1=M[M.length-1].endPoint(this._xyzWork1),this._xyzWork1.isAlmostEqual(y))return{chainIndex:k,atEnd:!0};if(this._xyzWork1=M[0].startPoint(this._xyzWork1),this._xyzWork1.isAlmostEqual(y))return{chainIndex:k,atEnd:!1}}}constructor(y){this._chains=[],this._makeClones=y}announceCurvePrimitive(y,k=!1){if(y){if(this._makeClones){const k=y.clone();if(!(k&&k instanceof ae))return;this.transferMarkup(y,k),y=k}if(k){this._xyzWork0=y.startPoint(this._xyzWork0);let k=this.findAnyChainToConnect(this._xyzWork0);k?k.atEnd?this._chains[k.chainIndex].push(y):(y.reverseInPlace(),this._chains[k.chainIndex].splice(0,0,y)):(this._xyzWork0=y.endPoint(this._xyzWork0),k=this.findAnyChainToConnect(this._xyzWork0),k?k.atEnd?(y.reverseInPlace(),this._chains[k.chainIndex].push(y)):this._chains[k.chainIndex].splice(0,0,y):this._chains.push([y]))}else{const k=this.findOrCreateTailChain();0!==k.length&&dr.needBreakBetweenPrimitives(k[k.length-1],y)?this.pushNewChain(y):k.push(y)}}}transferMarkup(y,k){y&&k&&(k.startCut=y.startCut,k.endCut=y.endCut)}promoteArrayToCurves(y,k){if(0!==y.length)return k&&(dr._staticPointA=y[0].startPoint(dr._staticPointA),dr._staticPointB=y[y.length-1].endPoint(dr._staticPointB),dr._staticPointA.isAlmostEqual(dr._staticPointB))?hi.createArray(y):1===y.length?y[0]:oi.createArray(y)}grabResult(y=!1){const k=this._chains;if(0===k.length)return;if(1===k.length)return this.promoteArrayToCurves(k[0],y);const M=ri.create();for(const b of k){const k=this.promoteArrayToCurves(b,y);M.tryAddChild(k)}return M}static needBreakBetweenPrimitives(y,k,M=!1){return void 0===y||void 0===k||void 0!==y.endCut||void 0!==k.startCut||(dr._staticPointA=y.endPoint(dr._staticPointA),dr._staticPointB=k.startPoint(dr._staticPointB),M?!dr._staticPointA.isAlmostEqualXY(dr._staticPointB):!dr._staticPointA.isAlmostEqual(dr._staticPointB))}}class ur extends Pe{constructor(y){super(),this._options=y||new Dr}handleCurveChain(y){const k=y.children.length,M=[];let b=0;for(let E=0;E<k;){const D=y.children[E];if(this._options.consolidateLinearGeometry&&(D instanceof Ce||D instanceof Me)){M.length=0;let R=E;for(;R<y.children.length;R++){const k=y.children[R];if(k instanceof Ce)M.push(k.startPoint()),M.push(k.endPoint());else{if(!(k instanceof Me))break;{const y=k.packedPoints;for(let k=0;k<y.length;k++)M.push(y.getPoint3dAtUncheckedPointIndex(k))}}}if(M.length>1){const D=Mi.compressShortEdges(M,this._options.duplicatePointTolerance),X=Mi.compressByPerpendicularDistance(D,this._options.colinearPointTolerance);0===E&&R===k&&ki.compressColinearWrapInPlace(X,this._options.duplicatePointTolerance,this._options.colinearPointTolerance),X.length<2?y.children[b++]=Me.create(X[0]):2===X.length?y.children[b++]=Ce.create(X[0],X[1]):y.children[b++]=Me.createPoints(X)}else y.children[b++]=D;E=R}else if(this._options.consolidateCompatibleArcs&&D instanceof Ti){for(;++E<y.children.length;){const k=y.children[E];if(!(k instanceof Ti))break;if(!Ln.appendToArcInPlace(D,k))break}y.children[b++]=D}else y.children[b++]=D,E++}y.children.length=b}handlePath(y){return this.handleCurveChain(y)}handleLoop(y){return this.handleCurveChain(y)}handleParityRegion(y){for(const k of y.children)k.dispatchToGeometryHandler(this)}handleUnionRegion(y){for(const k of y.children)k.dispatchToGeometryHandler(this)}}class fr{constructor(y,k){this.fraction=y,this.otherCurveDetail=k}setFrom(y,k){k&&this.isSameFraction(y)&&(this.otherCurveDetail=y.otherCurveDetail?y.otherCurveDetail:this.otherCurveDetail),this.fraction=y.fraction}isSameFraction(y){return Q.isSmallAngleRadians(this.fraction-y.fraction)}set(y,k){this.fraction=y,this.otherCurveDetail=k}}class gr{static hasInteriorDetailAIntersections(y,k=Q.smallAngleRadians){if(0===y.length)return!1;for(const M of y)if(M.detailA.fraction>k||M.detailA.fraction<1-k)return!0;return!1}collectFragmentAndAdvanceCut(y,k,M,b){if(!k.isSameFraction(M)){const E=y.clonePartialCurve(k.fraction,M.fraction);void 0!==E&&(E.startCut=k.otherCurveDetail,E.endCut=M.otherCurveDetail,b.push(E))}k.setFrom(M,!0)}collectSinglePrimitiveFragments(y,k,M){if(void 0===k||!gr.hasInteriorDetailAIntersections(k))return void M.push(y.clone());k.sort(((y,k)=>y.detailA.fraction-k.detailA.fraction));const b=new fr(0,void 0),E=new fr(1,void 0);for(const D of k)E.set(D.detailA.fraction,D.detailB),this.collectFragmentAndAdvanceCut(y,b,E,M);E.set(1,void 0),this.collectFragmentAndAdvanceCut(y,b,E,M)}static cloneCurvesWithXYSplits(y,k){const M=new gr;if(y instanceof ae){const b=[],E=is.intersectionXYPairs(y,!1,k,!1);return M.collectSinglePrimitiveFragments(y,E,b),1===b.length?b[0]:oi.createArray(b)}if(y instanceof ni){const b=[];for(const E of y.children){const y=is.intersectionXYPairs(E,!1,k,!1);M.collectSinglePrimitiveFragments(E,y,b)}return oi.createArray(b)}}}class pr{static testPointInOnOutLoopXY(y,k,M){let b;const E=j.create(k,M);for(let D=0;Math.abs(D)<6;D=-1.2313*(D+.3212897)){b=_t.createXYAngle(k,M,W.createRadians(D));const R=b.getNormalRef(),X=[];for(const k of y.children)k instanceof ae&&k.appendPlaneIntersectionPoints(b,X);ae.snapAndRestrictDetails(X,!1,!0);let z,N,Y=0,B=0,V=0;for(const y of X){if(y.intervalRole!==O.isolated&&void 0!==y.intervalRole&&V++,z=y.point.x-k,N=y.point.y-M,Q.isSameCoordinateXY(z,N,0,0))return 0;const b=Q.crossProductXYXY(R.x,R.y,z,N);if(E.isAlmostEqualXY(y.point))return 0;b<0?Y++:b>0&&B++}if(0!==V)continue;const U=1&Y;if(U===(1&B))return 1===U?1:-1}return-1}static testPointInOnOutParityRegionXY(y,k,M){let b=-1;for(const E of y.children)if(E instanceof hi){const y=this.testPointInOnOutLoopXY(E,k,M);if(0===y)return 0;y>0&&(b=-b)}return b}static testPointInOnOutUnionRegionXY(y,k,M){for(const b of y.children){const y=this.testPointInOnOutRegionXY(b,k,M);if(y>=0)return y}return-1}static testPointInOnOutRegionXY(y,k,M){return y instanceof hi?this.testPointInOnOutLoopXY(y,k,M):y instanceof bi?this.testPointInOnOutParityRegionXY(y,k,M):y instanceof xs?this.testPointInOnOutUnionRegionXY(y,k,M):-1}}class mr{constructor(){this.primitiveToPair=new Map,this.primitiveToIndex=new Map,this._numIndexedPrimitives=0}assignPrimitiveIndex(y){void 0!==y&&void 0===this.primitiveToIndex.get(y)&&this.primitiveToIndex.set(y,this._numIndexedPrimitives++)}insertPrimitiveToPair(y,k){if(y){const M=this.primitiveToPair.get(y);this.assignPrimitiveIndex(y),M?M.push(k):this.primitiveToPair.set(y,[k])}}insertPair(y){const k=y.detailA.curve;k&&this.insertPrimitiveToPair(k,y);const M=y.detailB.curve;M&&this.insertPrimitiveToPair(M,y)}splitAndAppendMissingClosedPrimitives(y,k=Q.smallMetricDistance){for(const M of y){let y=!1;if(M instanceof Ti?y=M.sweep.isFullCircle:M instanceof Ce||M instanceof Me||(y=M.startPoint().isAlmostEqualXY(M.endPoint(),k)),y&&!this.primitiveToPair.has(M)){const y=M.clonePartialCurve(0,.5),k=M.clonePartialCurve(.5,1);y&&k&&(this.insertPair(Pt.createCapture(vt.createCurveEvaluatedFraction(y,0),vt.createCurveEvaluatedFraction(k,1))),this.insertPair(Pt.createCapture(vt.createCurveEvaluatedFraction(y,1),vt.createCurveEvaluatedFraction(k,0))))}}}}class xr{static assembleHalfEdgeGraph(y,k,M=Q.smallMetricDistance){const b=new mr;for(const D of k)b.insertPair(D);y.length>b.primitiveToPair.size&&b.splitAndAppendMissingClosedPrimitives(y,M);const E=new fs;for(const D of b.primitiveToPair.entries()){const y=D[0],k=D[1].reduce(((k,M)=>{if(!M.detailA.hasFraction1)return[...k,M];const b=vr(M,y),E=vt.createCurveFractionPoint(y,b.fraction,b.point),D=vt.createCurveFractionPoint(y,b.fraction1,b.point1);return[...k,Pt.createCapture(E,E),Pt.createCapture(D,D)]}),[]);k.sort(((k,M)=>yr(k,y)-yr(M,y)));let b={point:y.startPoint(),fraction:0};for(const D of k){const k=vr(D,y),R=Q.restrictToInterval(k.fraction,0,1);b=this.addHalfEdge(E,y,b.point,b.fraction,k.point,R,M)}this.addHalfEdge(E,y,b.point,b.fraction,y.endPoint(),1,M)}return Hs.clusterAndMergeXYTheta(E,(y=>y.sortAngle)),E}static addHalfEdge(y,k,M,b,E,D,R=Q.smallMetricDistance){if(M.isAlmostEqualXY(E,R))return{point:M,fraction:b};const X=y.createEdgeXYAndZ(M,0,E,0),z=vt.createCurveEvaluatedFractionFraction(k,b,D),N=X.edgeMate;return X.edgeTag=z,X.sortData=1,N.edgeTag=z,N.sortData=-1,X.sortAngle=_r(k,b,!1),N.sortAngle=_r(k,D,!0),{point:E,fraction:D}}static collectSignedLoop(y,k,M=1e-10,b){let E=b?0:Er.computeXYArea(y);return void 0===E&&(E=0),Math.abs(E)<M&&(E=0),y.computedAreaInPlanarSubdivision=E,E>0?k.positiveAreaLoops.push(y):E<0?k.negativeAreaLoops.push(y):k.slivers.push(y),E}static createLoopInFace(y,k){let M=y;const b=hi.create();do{const y=M.edgeTag;if(y){let E;E=M.sortData>0?y.curve.clonePartialCurve(y.fraction,y.fraction1):y.curve.clonePartialCurve(y.fraction1,y.fraction),E&&(void 0!==k&&k(M,E,b),b.tryAddChild(E))}M=M.faceSuccessor}while(M!==y);return b}static isNullFace(y){const k=y.faceSuccessor.faceSuccessor===y;let M=!1;if(k){const k=Hs.curvatureSortKey(y),b=Hs.curvatureSortKey(y.faceSuccessor.edgeMate);Q.isSameCoordinate(k,b)||(M=!0)}return k&&!M}static nonNullEdgeMate(y,k){if(this.isNullFace(k))return;let M=k.edgeMate;for(;this.isNullFace(M);)if(M=M.faceSuccessor.edgeMate,M===k)return;return M}static collectSignedLoopSetsInHalfEdgeGraph(y,k=1e-10){const M=tn.collectConnectedComponentsWithExteriorParityMasks(y,void 0),b=[],E=new Map;for(const D of M){const M={positiveAreaLoops:[],negativeAreaLoops:[],slivers:[]},R=[];for(const b of D){const D=this.isNullFace(b),X=this.createLoopInFace(b,((k,M,b)=>{if(!D){const D=this.nonNullEdgeMate(y,k);if(void 0!==D){const y=E.get(D);if(void 0===y){const y=new di(b,M,void 0,void 0);E.set(k,y)}else y instanceof di&&(y.setB(b,M),R.push(y),E.delete(D))}}}));this.collectSignedLoop(X,M,k,D)}M.edges=R,b.push(M),E.clear()}return b}}function _r(y,k,M){const b=y.fractionToPointAndDerivative(k),E=M?-1:1;return Math.atan2(E*b.direction.y,E*b.direction.x)}function yr(y,k){return y.detailA.curve===k?y.detailA.fraction:y.detailB.curve===k?y.detailB.fraction:void 0}function vr(y,k){return y.detailA.curve===k?y.detailA:y.detailB.curve===k?y.detailB:void 0}class Pr extends Pe{constructor(){super(...arguments),this._point0=j.create(),this._point1=j.create()}handleArc3d(y){const k=this._activeMomentData,M=y.sweep.sweepRadians,b=.5*M;let E=Math.sin(b),D=Math.cos(b),R=Math.sin(M);W.isFullCircleRadians(M)&&(E=0,D=-1,R=0);const X=2*E*E*E*D/(b-E*D),z=E*E*E,N=.5*(M-R),Y=.25*N*(1+X)-z*z*4/(9*N),O=.25*N*(1-X/3),B=4*E*E*E/(3*(M-R)),V=y.sweep.fractionToRadians(.5),U=y.radiansToRotatedBasis(V),L=U.origin.plusScaled(U.vectorU,B);k.accumulateXYProductsInCentroidalFrame(Y,0,O,N,L,U.vectorU,U.vectorV);const Z=y.fractionToPoint(0),q=y.fractionToPoint(1);k.accumulateTriangleMomentsXY(void 0,Z,q)}handleLineString3d(y){this._activeMomentData.accumulateTriangleToLineStringMomentsXY(void 0,y.packedPoints)}handleLineSegment3d(y){const k=this._activeMomentData;y.startPoint(this._point0),y.endPoint(this._point1),k.accumulateTriangleMomentsXY(void 0,this._point0,this._point1)}handleLoop(y){const k=this._activeMomentData=Ei.create();k.needOrigin=!1;for(const M of y.children)M.dispatchToGeometryHandler(this);return this._activeMomentData=void 0,k}handleParityRegion(y){const k=[];let M,b=0;for(const E of y.children)if(E instanceof hi){const y=this.handleLoop(E);if(y){k.push(y);const E=Math.abs(y.quantitySum);E>b&&(b=E,M=y)}}if(M){const y=Ei.create(),b=M.signFactor(1);y.accumulateProducts(M,b);for(const E of k)if(E!==M){const k=E.signFactor(-1);y.accumulateProducts(E,k)}return y}}handleUnionRegion(y){const k=Ei.create();for(const M of y.children){const y=M.dispatchToGeometryHandler(this);if(y){const M=y.signFactor(1);k.accumulateProducts(y,M)}}return k}getStrokeOptions(){if(this._strokeOptions)return this._strokeOptions;const y=Ie.createForCurves();return y.angleTol=W.createDegrees(5),this._strokeOptions=y,y}handleCurvePrimitive(y){const k=Me.create(),M=this.getStrokeOptions();y.emitStrokes(k,M),this.handleLineString3d(k)}handleBSplineCurve3d(y){return this.handleCurvePrimitive(y)}handleBSplineCurve3dH(y){return this.handleCurvePrimitive(y)}handleTransitionSpiral(y){return this.handleCurvePrimitive(y)}}class Ar{startComponent(y){return!0}finishComponent(y){return!0}enterFace(y,k){return!0}leaveFace(y,k){return!0}}class Ir extends Ar{constructor(y,k){super(),this._inComponent=[!1,!1,!1],this._exteriorMask=k,this._faceSelectFunction=y}startComponent(y){return y.setMaskAroundFace(this._exteriorMask),!0}enterFace(y,k){const M=k.edgeTag;return 1!==k.edgeTag&&2!==k.edgeTag||(this._inComponent[M]=!this._inComponent[M]),this._faceSelectFunction(this._inComponent[1],this._inComponent[2])||k.setMaskAroundFace(this._exteriorMask),!0}leaveFace(y,k){const M=k.edgeTag;return 1!==k.edgeTag&&2!==k.edgeTag||(this._inComponent[M]=!this._inComponent[M]),!0}}class Sr{static faceToFaceSearchFromOuterLoop(y,k,M,b,E){if(k.isMaskSet(M))return;if(!E.startComponent(k))return;const D=[];k.setMaskAroundFace(M);let R=k;do{let y=R,k=R.edgeMate;if(!k.isMaskSet(M)){D.push(R),D.push(k);let X=k.faceSuccessor;if(k.setMaskAroundFace(M),y=k,E.enterFace(D,k))for(;;){if(k=X.edgeMate,!k.isMaskSet(M)){if(k.setMaskAroundFace(M),!E.enterFace(D,k))return;D.push(X),D.push(k),X=k,y=k}if(X.setMask(b),X=X.faceSuccessor,X===y){if(E.leaveFace(D,X),D.length<=2)break;D.pop(),X=D[D.length-1],D.pop(),y=D[D.length-1]}if(X.isMaskSet(b))return}}R=R.faceSuccessor}while(R!==k);E.finishComponent(k)}static doPolygonBoolean(y,k,M,b){const E=new fs,D=Kr.BOUNDARY_EDGE|Kr.PRIMARY_EDGE,R=Er.addLoopsWithEdgeTagToGraph(E,y,D,1),X=Er.addLoopsWithEdgeTagToGraph(E,k,D,2);if(b&&b("unmerged loops",E,"U"),R||X){Hs.splitIntersectingEdges(E),b&&b("After splitIntersectingEdges",E,"S"),Hs.clusterAndMergeXYTheta(E),b&&b("After clusterAndMergeXYTheta",E,"M"),new ms(E).regularizeGraph(!0,!0),b&&b("After regularize",E,"MR");const y=tn.findMinimumAreaFace(E);if(void 0===y)return;const k=Kr.EXTERIOR,D=E.grabMask(),R=E.grabMask(),X=k|D|R;E.clearMask(X);const z=new Ir(M,k);return this.faceToFaceSearchFromOuterLoop(E,y,D,R,z),b&&b("After faceToFaceSearchFromOuterLoop",E,"MRX"),E.dropMask(D),E.dropMask(R),E}}static doBinaryBooleanBetweenMultiLoopInputs(y,k,M,b,E,D){const R=new fs,X=Kr.BOUNDARY_EDGE|Kr.PRIMARY_EDGE,z=Tr.create(k,E);z.graph=R,z.faceAreaFunction=y=>tn.signedFaceArea(y);for(const N of y)if(N.length>2){const y=new wr(N,z.groupA);Er.addLoopsWithEdgeTagToGraph(R,N,X,y)}for(const N of b)if(N.length>2){const y=new wr(N,z.groupB);Er.addLoopsWithEdgeTagToGraph(R,N,X,y)}return Hs.splitIntersectingEdges(R),Hs.clusterAndMergeXYTheta(R),new ms(R).regularizeGraph(!0,!0),z.runClassificationSweep(M),D&&z.unmaskMaskedNullFaces(Kr.EXTERIOR),R}}!function(y){y[y.Union=0]="Union",y[y.Parity=1]="Parity",y[y.Intersection=2]="Intersection",y[y.NonBounding=-1]="NonBounding"}(Fo||(Fo={}));class wr{constructor(y,k){this.region=y,this.parentGroup=k,this.sweepState=0}clearState(){this.sweepState=0}}class Cr{constructor(y,k){this.members=[],this.parent=y,this.groupOpType=k,this._numIn=0}clearState(){for(const y of this.members)y.clearState();this._numIn=0}range(){const y=ut.createNull();for(const k of this.members)if(k.region instanceof Ot)k.region.extendRange(y);else{const M=ut.createFromVariantData(k.region);y.extendRange(M)}return y}getInOut(){return this.groupOpType===Fo.Union?this._numIn>0:this.groupOpType===Fo.Parity?Q.isOdd(this._numIn):this.groupOpType===Fo.Intersection&&this._numIn===this.members.length}addMember(y,k=!1){if(y instanceof hi||y instanceof bi){const k=y.clone();Er.consolidateAdjacentPrimitives(k),this.members.push(new wr(k,this))}else if(y instanceof xs)for(const M of y.children)this.addMember(M);else if(Array.isArray(y))for(const M of y)this.addMember(M);else k&&y instanceof Ce&&this.members.push(new wr(y,this))}recordMemberStateChange(y,k){const M=Q.isOdd(y),b=Q.isOdd(k);!M&&b?this._numIn++:M&&!b&&this._numIn--}}class Tr{constructor(y,k){this.groupA=new Cr(this,y),this.groupB=new Cr(this,k),this.extraGeometry=new Cr(this,Fo.NonBounding),this.binaryOp=ko.Union}static create(y,k){return new Tr(y,k)}addMembers(y,k){this.groupA.addMember(y),this.groupB.addMember(k),this.addConnectives()}addConnectives(){const y=this.groupA.range(),k=this.groupB.range(),M=y.union(k),b=Er.computeXYAreaTolerance(M);let E=.1;this._workSegment=Ee.findExtremePointsInDirection(M.corners(),Tr._bridgeDirection,this._workSegment),this._workSegment&&(E*=this._workSegment.point0Ref.distanceXY(this._workSegment.point1Ref));const D=[],o=y=>{const k=Er.computeXYArea(y);void 0===k||Math.abs(k)<b||(this._workSegment=Ee.findExtremePointsInDirection(y,Tr._bridgeDirection,this._workSegment),this._workSegment&&D.push(this._workSegment.point1Ref))};for(const X of[this.groupA.members,this.groupB.members])for(const y of X)if(y.region instanceof hi)o(y.region);else if(y.region instanceof bi)for(const k of y.region.children)o(k);const R=bt.createZero();for(const X of D){const y=E+bt.create(X,Tr._bridgeDirection,R).intersectionWithRange3d(M).high,k=j.createAdd2Scaled(X,1,Tr._bridgeDirection,y),b=Ce.createXYXY(X.x,X.y,k.x,k.y);this.extraGeometry.addMember(b,!0)}}annotateAndMergeCurvesInGraph(y=Q.smallMetricDistance){const k=[];for(const E of[this.groupA,this.groupB,this.extraGeometry])for(const y of E.members){let M=k.length;if(y.region instanceof Ot)for(Er.collectCurvePrimitives(y.region,k,!0,!0);M<k.length;M++)k[M].parent=y}const M=is.allIntersectionsAmongPrimitivesXY(k,y),b=xr.assembleHalfEdgeGraph(k,M,y);this.graph=b,this.faceAreaFunction=kr}runClassificationSweep(y,k){this._announceFaceFunction=k,this.binaryOp=y,this.graph.clearMask(Kr.EXTERIOR);for(const D of[this.groupA,this.groupB])D.clearState();const M=this.graph.grabMask(),b=this.graph.grabMask(),E=br.create(this.graph);for(const D of E.components){const y=tn.findMinimumAreaFace(D.faces,this.faceAreaFunction);if(y){const k=Kr.EXTERIOR|M|b;this.graph.clearMask(k),Sr.faceToFaceSearchFromOuterLoop(this.graph,y,M,b,this)}}this.graph.dropMask(M),this.graph.dropMask(b)}unmaskMaskedNullFaces(y){for(const k of this.graph.allHalfEdges){const M=k.faceSuccessor;M.faceSuccessor===k&&k.getMask(y)&&M.getMask(y)&&(k.edgeMate.getMask(y)&&M.edgeMate.getMask(y)||(k.clearMask(y),M.clearMask(y)))}}getInOut(){return this.binaryOp===ko.Union?this.groupA.getInOut()||this.groupB.getInOut():this.binaryOp===ko.Intersection?this.groupA.getInOut()&&this.groupB.getInOut():this.binaryOp===ko.AMinusB?this.groupA.getInOut()&&!this.groupB.getInOut():this.binaryOp===ko.BMinusA?!this.groupA.getInOut()&&this.groupB.getInOut():this.binaryOp===ko.Parity&&this.groupA.getInOut()!==this.groupB.getInOut()}recordTransitionAcrossEdge(y,k){const i=y=>{if(y.parentGroup.groupOpType===Fo.NonBounding)return y;if(0!==k){const M=y.sweepState;y.sweepState+=k,y.parentGroup.recordMemberStateChange(M,y.sweepState)}return y},M=y.edgeTag;if(M instanceof wr)return i(M);if(M instanceof vt){const y=M.curve.parent;if(y instanceof wr)return i(y)}}startComponent(y){return y.setMaskAroundFace(Kr.EXTERIOR),this._announceFaceFunction&&this._announceFaceFunction(this.graph,y,-1,kr(y)),!0}finishComponent(y){return!0}enterFace(y,k){this.recordTransitionAcrossEdge(k,1);const M=this.getInOut();return M||k.setMaskAroundFace(Kr.EXTERIOR),this._announceFaceFunction&&this._announceFaceFunction(this.graph,k,M?1:0,kr(k)),!0}leaveFace(y,k){return this.recordTransitionAcrossEdge(k,-1),!0}}function Fr(y,k,M,b){let E;E=y&&y.point1?-(y.point1.x-y.point.x)*(.5*(y.point.y+y.point1.y)-b.y):-(M.x-k.x)*(.5*(k.y+M.y)-b.y);let D=0;return y&&y.curve&&y.hasFraction1&&(y.curve instanceof Ce||y.curve instanceof Ti&&(D=y.curve.areaToChordXY(y.fraction,y.fraction1))),E+D}function kr(y){let k=0,M=y;do{k+=M.sortData*Fr(M.edgeTag,M,M.faceSuccessor,y)}while((M=M.faceSuccessor)!==y);return k}Tr._bridgeDirection=$.createNormalized(1,-.12328974132467);class Mr{constructor(y){this.faces=y,this.range=gt.createNull(),this.faceAreas=[]}buildFaceData(y,k){const i=k=>(y?y(k,this.range):this.range.extendXY(k.x,k.y),0);this.range.setNull();for(const M of this.faces)M.sumAroundFace(i);this.faceAreas.length=0,k||(k=y=>tn.signedFaceArea(y));for(const M of this.faces)this.faceAreas.push(k(M))}}class br{constructor(y){this.graph=y,this.components=[]}static create(y,k){const M=new br(y),b=tn.collectConnectedComponentsWithExteriorParityMasks(y,void 0);for(const E of b){const y=new Mr(E);y.buildFaceData(k,kr),M.components.push(y)}return M}}!function(y){y[y.Union=0]="Union",y[y.Parity=1]="Parity",y[y.Intersection=2]="Intersection",y[y.AMinusB=3]="AMinusB",y[y.BMinusA=4]="BMinusA"}(ko||(ko={}));class Er{static computeXYAreaMoments(y){const k=new Pr,M=y.dispatchToGeometryHandler(k);if(M instanceof Ei)return M.shiftOriginAndSumsToCentroidOfSums(),M}static computeXYAreaTolerance(y,k=Q.smallMetricDistance){const M=.5*k;return M*(y.xLength()+y.yLength()+M)}static computeXYArea(y){const k=new Pr,M=y.dispatchToGeometryHandler(k);if(M instanceof Ei)return M.quantitySum}static computeXYZWireMomentSums(y){const k=new hr;k.visitLeaves(y);const M=k.momentData;return M.shiftOriginAndSumsToCentroidOfSums(),M}static addLoopsToGraph(y,k,M){if(k instanceof hi){const b=k.getPackedStrokes();b&&this.addLoopsToGraph(y,b,M)}else if(k instanceof bi)for(const b of k.children){const k=b.getPackedStrokes();k&&this.addLoopsToGraph(y,k,M)}else if(k instanceof it){const b=Us.directCreateFaceLoopFromCoordinates(y,k);void 0!==b&&M(y,b)}else if(Array.isArray(k)&&k.length>0)if(j.isAnyImmediatePointType(k[0])){const b=Us.directCreateFaceLoopFromCoordinates(y,k);void 0!==b&&M(y,b)}else if(k[0]instanceof it)for(const b of k){const k=Us.directCreateFaceLoopFromCoordinates(y,b);void 0!==k&&M(y,k)}else for(const b of k)Array.isArray(b)&&this.addLoopsToGraph(y,b,M)}static addLoopsWithEdgeTagToGraph(y,k,M,b){const E=[];if(this.addLoopsToGraph(y,k,((y,k)=>{k&&(E.push(k),k.setMaskAndEdgeTagAroundFace(M,b,!0))})),E.length>0)return E}static finishGraphToPolyface(y,k){if(y)return k&&(Us.triangulateAllPositiveAreaFaces(y),Us.flipTriangles(y)),ar.graphToPolyface(y)}static polygonXYAreaIntersectLoopsToPolyface(y,k,M=!1){const b=Sr.doPolygonBoolean(y,k,((y,k)=>y&&k),this._graphCheckPointFunction);return this.finishGraphToPolyface(b,M)}static polygonXYAreaUnionLoopsToPolyface(y,k,M=!1){const b=Sr.doPolygonBoolean(y,k,((y,k)=>y||k),this._graphCheckPointFunction);return this.finishGraphToPolyface(b,M)}static polygonXYAreaDifferenceLoopsToPolyface(y,k,M=!1){const b=Sr.doPolygonBoolean(y,k,((y,k)=>y&&!k),this._graphCheckPointFunction);return this.finishGraphToPolyface(b,M)}static regionBooleanXY(y,k,M,b=Q.smallMetricDistance){const E=xs.create(),D=Tr.create(Fo.Union,Fo.Union);D.addMembers(y,k),D.annotateAndMergeCurvesInGraph(b);const R=D.groupA.range().union(D.groupB.range()),X=this.computeXYAreaTolerance(R,b);return D.runClassificationSweep(M,((y,k,M,b)=>{if(!(k.countEdgesAroundFace()<2||Math.abs(b)<X||1!==M)){const y=xr.createLoopInFace(k);y&&E.tryAddChild(y)}})),E}static polygonBooleanXYToPolyface(y,k,M,b=!1){const E=Sr.doBinaryBooleanBetweenMultiLoopInputs(y,Fo.Union,k,M,Fo.Union,!0);return this.finishGraphToPolyface(E,b)}static polygonBooleanXYToLoops(y,k,M){const b=Sr.doBinaryBooleanBetweenMultiLoopInputs(y,Fo.Union,k,M,Fo.Union,!0);if(!b)return;const E=tn.collectExtendedBoundaryLoopsInGraph(b,Kr.EXTERIOR),D=[];for(const R of E){const y=new nt;for(const M of R)y.pushXYZ(M.x,M.y,M.z);y.pushWrap(1);const k=hi.create();k.tryAddChild(Me.createCapture(y)),D.push(k)}return Er.sortOuterAndHoleLoopsXY(D)}static constructPolygonWireXYOffset(y,k,M){return(new rs).constructPolygonWireXYOffset(y,k,M)}static constructCurveXYOffset(y,k){const M=we.create(k);return as.constructCurveXYOffset(y,M)}static testPointInOnOutRegionXY(y,k,M){return pr.testPointInOnOutRegionXY(y,k,M)}static createLoopPathOrBagOfCurves(y,k=!0,M=!1){const b=y.length;if(0===b)return;let E,D=0,R=!1;k&&(D=Q.maxXY(D,y[0].startPoint().distance(y[b-1].endPoint())));for(let X=0;X+1<b;X++)D=Q.maxXY(D,y[X].endPoint().distance(y[X+1].startPoint()));Q.isSmallMetricDistance(D)?(E=k?hi.create():oi.create(),R=!0):E=ri.create();for(const X of y)E.tryAddChild(X);return R&&M&&Er.consolidateAdjacentPrimitives(E),E}static setCheckPointFunction(y){this._graphCheckPointFunction=y}static cloneCurvesWithXYSplits(y,k){return gr.cloneCurvesWithXYSplits(y,k)}static splitToPathsBetweenBreaks(y,k){if(void 0===y)return;if(y instanceof ae)return y;const M=y.collectCurvePrimitives(),b=new dr(k);for(const E of M)b.announceCurvePrimitive(E);return b.grabResult()}static collectInsideAndOutsideOffsets(y,k,M){return as.collectInsideAndOutsideXYOffsets(y,k,M)}static collectChains(y,k=Q.smallMetricDistance){return as.collectChains(y,k)}static splitPathsByRegionInOnOutXY(y,k){const M={insideParts:[],outsideParts:[],coincidentParts:[]},b=Er.cloneCurvesWithXYSplits(y,k),E=Er.splitToPathsBetweenBreaks(b,!0);if(E instanceof si)for(const D of E.children){const y=si.createCurveLocationDetailOnAnyCurvePrimitive(D);y&&Rr(D,Er.testPointInOnOutRegionXY(k,y.point.x,y.point.y),M.outsideParts,M.coincidentParts,M.insideParts)}else if(E instanceof ae){const y=si.createCurveLocationDetailOnAnyCurvePrimitive(E);y&&Rr(E,Er.testPointInOnOutRegionXY(k,y.point.x,y.point.y),M.outsideParts,M.coincidentParts,M.insideParts)}return M}static rectangleEdgeTransform(y,k=!0){if(y instanceof Me)return this.rectangleEdgeTransform(y.packedPoints);if(y instanceof it){let M;if(k&&5===y.length){if(!Q.isSmallMetricDistance(y.distanceIndexIndex(0,4)))return;M=y}else if(k||4!==y.length){if(y.length<(k?5:4))return;if(M=nt.create(y),ki.compressInPlaceByShortEdgeLength(M,Q.smallMetricDistance),M.length<(k?5:4))return}else M=y;const b=M.vectorIndexIndex(0,1),E=M.vectorIndexIndex(0,3),D=M.vectorIndexIndex(1,2),R=b.crossProduct(E);if(R.normalizeInPlace()&&D.isAlmostEqual(E)&&b.isPerpendicularTo(E))return pt.createOriginAndMatrixColumns(M.getPoint3dAtUncheckedPointIndex(0),b,E,R)}else{if(Array.isArray(y))return this.rectangleEdgeTransform(new ce(y),k);if(y instanceof hi&&1===y.children.length&&y.children[0]instanceof Me)return this.rectangleEdgeTransform(y.children[0].packedPoints,!0);if(y instanceof oi&&1===y.children.length&&y.children[0]instanceof Me)return this.rectangleEdgeTransform(y.children[0].packedPoints,k);if(y instanceof ni&&!y.checkForNonLinearPrimitives()){const k=y.getPackedStrokes();if(k)return this.rectangleEdgeTransform(k)}}}static consolidateAdjacentPrimitives(y,k){const M=new ur(k);y.dispatchToGeometryHandler(M)}static sortOuterAndHoleLoopsXY(y){const k=[];for(const M of y)if(M instanceof hi)Or.pushLoop(k,M);else if(M instanceof it){const y=hi.createPolygon(M);Or.pushLoop(k,y)}return Or.sortAsAnyRegion(k)}static constructAllXYRegionLoops(y,k=Q.smallMetricDistance){const M=Er.collectCurvePrimitives(y,void 0,!0,!0),b=this.curveArrayRange(M),E=this.computeXYAreaTolerance(b,k),D=is.allIntersectionsAmongPrimitivesXY(M,k),R=xr.assembleHalfEdgeGraph(M,D,k);return xr.collectSignedLoopSetsInHalfEdgeGraph(R,E)}static collectCurvePrimitives(y,k,M=!1,b=!1){const E=void 0===k?[]:k;if(y instanceof ae)y.collectCurvePrimitives(E,M,b);else if(y instanceof si)y.collectCurvePrimitives(E,M,b);else if(Array.isArray(y))for(const D of y)this.collectCurvePrimitives(D,E,M,b);return E}static expandLineStrings(y){const k=[];for(const M of y)if(M instanceof Me)for(let y=0;y+1<M.packedPoints.length;y++){const b=M.getIndexedSegment(y);void 0!==b&&k.push(b)}else k.push(M);return k}static curveArrayRange(y,k){const M=ut.create();if(y instanceof Ot)y.extendRange(M,k);else if(Array.isArray(y))for(const b of y)b instanceof Ot?b.extendRange(M,k):b instanceof j?M.extendPoint(b,k):b instanceof nt?M.extendRange(b.getRange(k)):Array.isArray(b)&&M.extendRange(this.curveArrayRange(b,k));return M}static triangulateStrokedRegionComponent(y){let k;if(Array.isArray(y)){if(0===y.length)return;const M=y[0];if(j.isAnyImmediatePointType(M))k=Us.createTriangulatedGraphFromSingleLoop(y);else if(y.length>1){let b;if(M instanceof st)b=y;else{b=[];for(const k of y)b.push(nt.create(k))}const E=Ur.sortOuterAndHoleLoopsXY(b);1===E.length&&(k=Us.createTriangulatedGraphFromLoops(E[0]))&&Us.flipTriangles(k)}else k=Us.createTriangulatedGraphFromSingleLoop(M)}else k=Us.createTriangulatedGraphFromSingleLoop(y);return k||(k=Sr.doPolygonBoolean(y,[],((y,k)=>y)))&&Us.triangulateAllPositiveAreaFaces(k)&&Us.flipTriangles(k),k}static strokeRegionComponent(y,k){const M=y.cloneStroked(k),b=[];if(M instanceof hi)M.children.length>0&&M.children[0]instanceof Me&&b.push(M.children[0].packedPoints);else if(M instanceof bi)for(const E of M.children)E.children.length>0&&E.children[0]instanceof Me&&b.push(E.children[0].packedPoints);return b}static triangulateRegionComponent(y,k){const M=this.strokeRegionComponent(y,k);return this.triangulateStrokedRegionComponent(M)}static facetRegionXY(y,k){let M;if(y instanceof xs)for(const b of y.children){const y=Er.triangulateRegionComponent(b,k);y&&(M?M.allHalfEdges.push(...y.allHalfEdges):M=y)}else M=this.triangulateRegionComponent(y,k);if(M)return k?.maximizeConvexFacets&&Gs.expandConvexFaces(M),ar.graphToPolyface(M,k)}static convexDecomposePolygonXY(y,k=!0){const M=Er.triangulateStrokedRegionComponent(y);if(!M)return;k&&Gs.expandConvexFaces(M);const b=[];return M.announceFaceLoops(((y,k)=>(k.isMaskSet(Kr.EXTERIOR)||b.push(nt.create(k.collectAroundFace((y=>y.getPoint3d())))),!0))),b}}function Rr(y,k,M,b,E){k>0?E.push(y):k<0?M.push(y):b.push(y)}class Dr{constructor(){this.consolidateLinearGeometry=!0,this.consolidateCompatibleArcs=!0,this.duplicatePointTolerance=Q.smallMetricDistance,this.colinearPointTolerance=Q.smallMetricDistance}}class Xr{}class zr extends Xr{get signedArea(){return this._signedArea}constructor(y){super(),this.data=y,this._signedArea=Ur.areaXY(y)}classifyPointXY(y){return Ur.classifyPointInPolygonXY(y.x,y.y,this.data)}getAnyInteriorPoint(){for(let y=0;y<this.data.length;y++){const k=this.constructInteriorPointNearEdge(y,.2349);if(void 0!==k)return k}}grabPolygon(){return this.data}grabLoop(){return hi.createPolygon(this.data)}reverseForAreaSign(y){y*this._signedArea<0&&(this.data.reverseInPlace(),this._signedArea*=-1)}constructInteriorPointNearEdge(y,k){if(y+1<this.data.length){const M=this.data.getPoint3dAtUncheckedPointIndex(y),b=this.data.getPoint3dAtUncheckedPointIndex(y+1),E=M.vectorTo(b),D=M.interpolate(k,b);if(E.rotate90CCWXY(E),E.normalizeInPlace()){this._signedArea<0&&E.scaleInPlace(-1);const y=Math.sqrt(Math.abs(this._signedArea));for(let k=1e-5;k<3;k*=5){const M=D.plusScaled(E,k*y);if(1===this.classifyPointXY(M))return M}}}}}class Nr extends Xr{get signedArea(){return this._signedArea}constructor(y){super(),this.data=y;const k=Er.computeXYAreaMoments(y);this._signedArea=void 0!==k?k.quantitySum:0}classifyPointXY(y){return Er.testPointInOnOutRegionXY(this.data,y.x,y.y)}constructInteriorPointNearChild(y,k){if(y<this.data.children.length){const M=this.data.children[y].fractionToPointAndUnitTangent(k);M.direction.rotate90CCWXY(M.direction),this._signedArea<0&&M.direction.scaleInPlace(-1);const b=Math.sqrt(Math.abs(this._signedArea));for(let y=1e-5;y<3;y*=5){const k=M.fractionToPoint(y*b);if(1===this.classifyPointXY(k))return k}}}getAnyInteriorPoint(){for(let y=0;y<this.data.children.length;y++){const k=this.constructInteriorPointNearChild(y,.2349);if(void 0!==k)return k}}grabPolygon(){const y=this.data.cloneStroked();if(y instanceof ni){const k=Me.create();for(const M of y.children)M instanceof ae&&M.emitStrokes(k);return k.numPoints()>0?k.packedPoints:void 0}}grabLoop(){return this.data}reverseForAreaSign(y){y*this._signedArea<0&&(this.data.reverseChildrenInPlace(),this._signedArea*=-1)}}class Or{constructor(y,k){this._loopCarrier=y instanceof st?new zr(y):new Nr(y),this.range=k,this.sortKey=Math.abs(this._loopCarrier.signedArea),this.isHole=!1}static pushPolygon(y,k){const M=k.getRange(),b=new Or(k,M);return b.sortKey>0&&(y.push(b),!0)}static pushLoop(y,k){const M=k.range(),b=new Or(k,M);return b.sortKey>0&&(y.push(b),!0)}static assignParentsAndDepth(y){y.sort(((y,k)=>k.sortKey-y.sortKey));for(let k=y.length;k-- >0;){const M=y[k],b=M._loopCarrier.getAnyInteriorPoint();if(void 0!==b){y[k].parentIndex=void 0,y[k].outputSetIndex=void 0;for(let E=k;E-- >0;){const k=y[E];if(k.range.containsXY(b.x,b.y)&&1===k._loopCarrier.classifyPointXY(b)){M.parentIndex=E;break}}}}}static assemblePolygonSet(y){const k=[];for(const M of y){M.isHole=!1;const b=M.parentIndex;void 0!==b&&(M.isHole=!y[b].isHole),M.isHole?(M._loopCarrier.reverseForAreaSign(-1),k[y[b].outputSetIndex].push(M._loopCarrier.grabPolygon())):(M._loopCarrier.reverseForAreaSign(1),M.outputSetIndex=k.length,k.push([]),k[M.outputSetIndex].push(M._loopCarrier.grabPolygon()))}return k}static assembleLoopSet(y){const k=[],M=y.length;for(let b=0;b<M;b++){const E=y[b],D=E.parentIndex;if(E.isHole=void 0!==D&&!y[D].isHole,!E.isHole){E._loopCarrier.reverseForAreaSign(1);const D=E._loopCarrier.grabLoop();let R;for(let k=b+1;k<M;k++){const M=y[k];M.parentIndex===b&&(void 0===R?(R=bi.create(),R.tryAddChild(D),M._loopCarrier.reverseForAreaSign(-1),R.tryAddChild(M._loopCarrier.grabLoop())):(M._loopCarrier.reverseForAreaSign(-1),R.tryAddChild(M._loopCarrier.grabLoop())))}void 0!==R?k.push(R):void 0!==D&&k.push(D)}}return k}static sortAsAnyRegion(y){this.assignParentsAndDepth(y);const k=this.assembleLoopSet(y);if(1===k.length)return k[0];{const y=xs.create();for(const M of k)y.tryAddChild(M);return y}}static sortAsArrayOfArrayOfPolygons(y){return this.assignParentsAndDepth(y),this.assemblePolygonSet(y)}grabPolygon(){return this._loopCarrier.grabPolygon()}grabLoop(){return this._loopCarrier.grabLoop()}reverseForAreaSign(y){this._loopCarrier.reverseForAreaSign(y)}getAnyInteriorPoint(){return this._loopCarrier.getAnyInteriorPoint()}}class Yr{constructor(){this.point=new j,this.a=0,this.v=new $,this.code=z.Unknown,this.closestEdgeIndex=0,this.closestEdgeParam=0}invalidate(){this.point.setZero(),this.a=0,this.v.setZero(),this.code=z.Unknown,this.closestEdgeIndex=0,this.closestEdgeParam=0}static create(y){return void 0===y?y=new Yr:y.invalidate(),y}copyContentsFrom(y){this.point.setFrom(y.point),this.a=y.a,this.v.setFrom(y.v),this.code=y.code,this.closestEdgeIndex=y.closestEdgeIndex,this.closestEdgeParam=y.closestEdgeParam}get isValid(){return this.code!==z.Unknown}get isInsideOrOn(){return this.code===z.InsidePolygon||this.code===z.OnPolygonVertex||this.code===z.OnPolygonEdgeInterior||this.code===z.InsidePolygonProjectsToVertex||this.code===z.InsidePolygonProjectsToEdgeInterior}static createAtVertexOrEdge(y,k,M=0){const b=new Yr;return b.point.setFrom(y),b.closestEdgeIndex=k,b.closestEdgeParam=M,M=Q.clamp(M,0,1),b.code=M>0&&M<1?z.OnPolygonEdgeInterior:z.OnPolygonVertex,b}}class Br{constructor(y,k){this.detailA=y||Yr.create(),this.detailB=k||Yr.create()}static create(y,k,M){return M?(M.detailA=y,M.detailB=k,M):new Br(y,k)}clone(y){return(y=y||new Br).detailA.copyContentsFrom(this.detailA),y.detailB.copyContentsFrom(this.detailB),y}swapDetails(){const y=this.detailA;this.detailA=this.detailB,this.detailB=y}}class Vr{constructor(y){this.xyz=y,this.edge=void 0,this.sortCoordinate0=this.sortCoordinate1=0,this.sortDelta=0,this.isNotch=!1}static createCaptureWithReturnEdge(y){const k=new Vr(y);return y.length>=2&&(k.edge=bt.createStartEnd(y.front(),y.back())),k}setSortCoordinates(y){this.sortDelta=this.edge.direction.dotProduct(y.direction);const k=y.dotProductToPoint(this.edge.origin);this.sortDelta>=0?(this.sortCoordinate0=k,this.sortCoordinate1=k+this.sortDelta):(this.sortCoordinate0=k+this.sortDelta,this.sortCoordinate1=k)}containsSortLimits(y){return y.sortCoordinate0>=this.sortCoordinate1||y.sortCoordinate0<=this.sortCoordinate0||y.sortCoordinate1<=this.sortCoordinate0||y.sortCoordinate1>=this.sortCoordinate1?0:this.sortDelta*y.sortDelta>0?1:-1}absorb(y){this.xyz.pushFromGrowableXYZArray(y.xyz),this.sortCoordinate0=y.sortCoordinate1}static sortFunction(y,k){return y.sortCoordinate0-k.sortCoordinate0>0?1:-1}front(y){return this.xyz.front(y)}back(y){return this.xyz.back(y)}}class Lr{constructor(){this.inputLoops=[],this.outputLoops=[]}mostDistantPoint(y,k,M){let b,E=-1;M.setZero();for(const D of this.inputLoops)D.front(k),b=k.distanceSquared(y),b>E&&(E=b,M.setFromPoint3d(k)),D.back(k),b=k.distanceSquared(y),b>E&&(E=b,M.setFromPoint3d(k))}sortInputs(){if(this.inputLoops.length>0&&this.inputLoops[0].xyz.length>0){const y=this.inputLoops[0].xyz.front(),k=j.create(),M=j.create();this.mostDistantPoint(y,k,M),this.mostDistantPoint(M,k,y);const b=bt.createStartEnd(y,M);b.direction.normalizeInPlace();for(const E of this.inputLoops)E.setSortCoordinates(b);this.inputLoops.sort(((y,k)=>Vr.sortFunction(y,k)))}}sortAndMergeLoops(){this.sortInputs();const y=this.inputLoops,k=this.outputLoops,M=[];k.length=0;for(const b of y){for(b.isNotch=!1;M.length>0;){const y=M[M.length-1],E=y.containsSortLimits(b);if(0!==E){if(1===E){b.isNotch=!1;break}y.absorb(b),b.isNotch=!0;break}y.isNotch||k.push(y),M.pop()}M.push(b)}for(const b of M)b.isNotch||k.push(b)}}class Ur{static sumTriangleAreas(y){let k=0;const M=y.length;if(Array.isArray(y)){if(M>=3){const b=y[0],E=b.vectorTo(y[1]);let D=$.create();for(let R=2;R<M;R++)D=b.vectorTo(y[R],D),k+=E.crossProductMagnitude(D),E.setFrom(D)}return.5*k}const b=$.create();for(let E=2;E<M;E++)y.crossProductIndexIndexIndex(0,E-1,E,b),k+=b.magnitude();return.5*k}static sumTriangleAreasPerpendicularToUpVector(y,k){let M=k.magnitude();M<Q.smallMetricDistance&&(k=$.create(0,0,1),M=1);let b=0;const E=y.length;if(Array.isArray(y)){if(E>=3){const M=y[0],D=M.vectorTo(y[1]);let R=$.create();for(let X=2;X<E;X++)R=M.vectorTo(y[X],R),b+=D.tripleProduct(R,k),D.setFrom(R)}return.5*b/M}const D=$.create();for(let R=2;R<E;R++)y.crossProductIndexIndexIndex(0,R-1,R,D),b+=D.dotProduct(k);return.5*b/M}static sumTriangleAreasXY(y){let k=0;const M=y.length;if(M>=3){const b=y[0],E=b.vectorTo(y[1]);let D=$.create();for(let R=2;R<M;R++)D=b.vectorTo(y[R],D),k+=E.crossProductXY(D),E.setFrom(D)}return k*=.5,k}static areaNormalGo(y,k){k?k.setZero():k=new $;const M=y.length;if(3===M)y.crossProductIndexIndexIndex(0,1,2,k);else if(M>3)for(let b=2;b<M;b++)y.accumulateCrossProductIndexIndexIndex(0,b-1,b,k);return k.scaleInPlace(.5),k.isZero?void 0:k}static areaNormal(y,k){return k||(k=$.create()),Ur.areaNormalGo(new ce(y),k),k}static area(y){return Ur.areaNormal(y).magnitude()}static areaXY(y){let k=0;if(y instanceof it){if(y.length>2){const M=y.getXAtUncheckedPointIndex(0),b=y.getYAtUncheckedPointIndex(0);let E,D,R=y.getXAtUncheckedPointIndex(1)-M,X=y.getYAtUncheckedPointIndex(1)-b;for(let z=2;z+1<y.length;z++,R=E,X=D)E=y.getXAtUncheckedPointIndex(z)-M,D=y.getYAtUncheckedPointIndex(z)-b,k+=Q.crossProductXYXY(R,X,E,D)}}else for(let M=1;M+1<y.length;M++)k+=y[0].crossProductToPointsXY(y[M],y[M+1]);return.5*k}static sumAreaXY(y){let k=0;for(const M of y)k+=this.areaXY(M);return k}static centroidAreaNormal(y){if(Array.isArray(y)){const k=new ce(y);return this.centroidAreaNormal(k)}const k=y.length;if(3===k){const k=y.crossProductIndexIndexIndex(0,1,2),M=.5*k.magnitude(),b=y.getPoint3dAtCheckedPointIndex(0);y.accumulateScaledXYZ(1,1,b),y.accumulateScaledXYZ(2,1,b),b.scaleInPlace(1/3);const E=bt.createCapture(b,k);return E.tryNormalizeInPlaceWithAreaWeight(M)?E:void 0}if(k>=3){const M=$.createZero();for(let B=2;B<k;B++)y.accumulateCrossProductIndexIndexIndex(0,B-1,B,M);M.normalizeInPlace();const b=y.getPoint3dAtCheckedPointIndex(0),E=$.create(),D=$.create();y.vectorXYAndZIndex(b,1,E);let R=$.create();const X=$.createZero(),z=$.createZero();let N;for(let B=2;B<k;B++){y.vectorXYAndZIndex(b,B,D),R=E.crossProduct(D,R),N=M.dotProduct(R),z.addInPlace(R);const k=N/6;X.plus2Scaled(E,k,D,k,X),E.setFrom(D)}const Y=.5*z.magnitude(),O=Q.conditionalDivideFraction(1,Y);if(void 0!==O){const y=bt.createCapture(b.plusScaled(X,O),z);return y.tryNormalizeInPlaceWithAreaWeight(Y),y}}}static centroidAndAreaXY(y,k){let M=0;if(k.set(0,0),y.length<3)return;const b=y[0];let E=J.create(0,0),D=0;for(let X=1;X+1<y.length;X++){const k=b.vectorTo(y[X]),M=b.vectorTo(y[X+1]),R=k.crossProduct(M);E=E.plus(k.plus(M).scale(R)),D+=R}M=.5*D;const R=Q.conditionalDivideFraction(1,6*M);if(void 0!==R)return k.setFrom(b.plusScaled(E,R)),M;k.setFrom(b)}static unitNormal(y,k){k.setZero();let M=y.length;return M>1&&y.getPoint3dAtUncheckedPointIndex(0).isExactEqual(y.getPoint3dAtUncheckedPointIndex(M-1))&&--M,3===M?(y.crossProductIndexIndexIndex(0,1,2,k),k.normalizeInPlace()):4===M?(y.vectorIndexIndex(0,2,Ur._vector0),y.vectorIndexIndex(1,3,Ur._vector1),Ur._vector0.crossProduct(Ur._vector1,k),k.normalizeInPlace()):(Ur.areaNormalGo(y,k),k.normalizeInPlace())}static addSecondMomentAreaProducts(y,k,M){this.addSecondMomentTransformedProducts(Ur._triangleMomentWeights,y,k,2,M)}static addSecondMomentVolumeProducts(y,k,M){this.addSecondMomentTransformedProducts(Ur._tetrahedralMomentWeights,y,k,3,M)}static addSecondMomentTransformedProducts(y,k,M,b,E){const D=Ur._normal;if(Ur.unitNormal(k,D)){const R=Ur._vector0,X=Ur._vector1,z=Ur._vector2,N=Ur._matrixA,Y=Ur._matrixB,O=Ur._matrixC,B=k.vectorXYAndZIndex(M,0,Ur._vectorOrigin),V=k.length;let U=0;for(let L=2;L<V;L++)2===b?(k.vectorIndexIndex(0,L-1,R),k.vectorIndexIndex(0,L,X),U=D.tripleProduct(R,X),N.setOriginAndVectors(B,R,X,D),N.multiplyMatrixMatrix(y,Y),Y.multiplyMatrixMatrixTranspose(N,O),E.addScaledInPlace(O,U)):3===b&&(k.vectorXYAndZIndex(M,0,R),k.vectorXYAndZIndex(M,L-1,X),k.vectorXYAndZIndex(M,L,z),U=R.tripleProduct(X,z),N.setOriginAndVectors(M,R,X,z),N.multiplyMatrixMatrix(y,Y),Y.multiplyMatrixMatrixTranspose(N,O),E.addScaledInPlace(O,U))}}static testXYPolygonTurningDirections(y){let k=y.length,M=k-1;for(;M>1&&y[M].x===y[0].x&&y[M].y===y[0].y;)k=M--;if(k>2){let b=H.create(y[M].x-y[M-1].x,y[M].y-y[M-1].y);const E=H.create(y[0].x-y[M].x,y[0].y-y[M].y),D=b.x*E.y-b.y*E.x;for(let M=1;M<k;M++)if(b=E.clone(),H.create(y[M].x-y[M-1].x,y[M].y-y[M-1].y,E),(b.x*E.y-b.y*E.x)*D<=0)return 0;return D>0?1:-1}return 0}static isConvex(y){if(!(y instanceof it))return this.isConvex(new ce(y));let k=y.length;k>1&&y.getPoint3dAtUncheckedPointIndex(0).isExactEqual(y.getPoint3dAtUncheckedPointIndex(k-1))&&--k;const M=$.create();if(!this.unitNormal(y,M))return!1;let b=0,E=0;const D=this._vector0;let R=$.createStartEnd(y.getPoint3dAtUncheckedPointIndex(k-1),y.getPoint3dAtUncheckedPointIndex(0),this._vector1);for(let X=1;X<=k;X++){D.setFromVector3d(R),R=$.createStartEnd(y.getPoint3dAtUncheckedPointIndex(X-1),y.getPoint3dAtUncheckedPointIndex(X%k),R);const z=M.tripleProduct(D,R);z>=0?b+=z:E+=z}return Math.abs(E)<Q.smallMetricDistanceSquared*b}static classifyPointInPolygon(y,k,M){const b=new zt(y,k);let E=0;const D=M.length;let R,X=-1;for(E=0;E<D;E++)if(R=E+1,R>=D&&(R=0),b.tryStartEdge(M[E].x,M[E].y,M[R].x,M[R].y)){X=R;break}if(!(X<0)){for(let y=1;y<=D;y++)if(R=X+y,R>=D&&(R-=D),!b.advance(M[R].x,M[R].y))return b.classifyCounts();return b.classifyCounts()}}static classifyPointInPolygonXY(y,k,M){const b=new zt(y,k);let E=0;const D=M.length;let R,X=-1;for(E=0;E<D;E++)if(R=E+1,R>=D&&(R=0),b.tryStartEdge(M.getXAtUncheckedPointIndex(E),M.getYAtUncheckedPointIndex(E),M.getXAtUncheckedPointIndex(R),M.getYAtUncheckedPointIndex(R))){X=R;break}if(!(X<0)){for(let y=1;y<=D;y++)if(R=X+y,R>=D&&(R-=D),!b.advance(M.getXAtUncheckedPointIndex(R),M.getYAtUncheckedPointIndex(R)))return b.classifyCounts();return b.classifyCounts()}}static orientLoopsCCWForOutwardNormalInPlace(y,k){if(y instanceof it)return this.orientLoopsCCWForOutwardNormalInPlace([y],k);const M=$.create();let b=0;for(const E of y)this.unitNormal(E,M)&&M.dotProduct(k)<0&&(E.reverseInPlace(),b++);return b}static sortOuterAndHoleLoopsXY(y){const k=[];for(const M of y)Or.pushPolygon(k,M);return Or.sortAsArrayOfArrayOfPolygons(k)}static sortOuterAndHoleLoops(y,k){const M=Fi.createRightHandedFrame(k,y),b=M?.inverse(),E=[];if(void 0!==b)for(const X of y){const y=new nt(X.length);for(const k of X.points)y.push(b.multiplyPoint3d(k));E.push(y)}const D=Ur.sortOuterAndHoleLoopsXY(E),R=[];if(void 0!==M)for(const X of D){const y=[];for(const k of X){const b=new nt(k.length);for(const y of k.points)b.push(M.multiplyPoint3d(y));y.push(b)}R.push(y)}return R}static closestPointOnBoundary(y,k,M=Q.smallMetricDistance,b){if(!(y instanceof it))return this.closestPointOnBoundary(new ce(y),k,M,b);const E=M*M;let D=y.length;for(;D>1&&!(y.distanceSquaredIndexIndex(0,D-1)>E);)--D;if(b=Yr.create(b),0===D)return b;if(1===D)return y.getPoint3dAtUncheckedPointIndex(0,b.point),b.a=b.point.distance(k),b.v.setZero(),b.code=z.OnPolygonVertex,b.closestEdgeIndex=0,b.closestEdgeParam=0,b;let R=D-1,X=Q.largeCoordinateResult;for(let N=0;N<D;++N){let M=N+1;M===D&&(M=0);const Y=y.distanceSquaredIndexIndex(N,M);if(Y<=E)continue;const O=y.distanceSquaredIndexXYAndZ(N,k),B=y.dotProductIndexIndexXYAndZ(N,M,k)/Y;if(B<=0){const D=O;if(D<=E)return y.getPoint3dAtUncheckedPointIndex(N,b.point),b.a=Math.sqrt(D),b.v.setZero(),b.code=z.OnPolygonVertex,b.closestEdgeIndex=N,b.closestEdgeParam=0,b;D<X&&y.dotProductIndexIndexXYAndZ(N,R,k)<=0&&(y.getPoint3dAtUncheckedPointIndex(N,b.point),b.a=Math.sqrt(D),y.crossProductIndexIndexIndex(N,R,M,b.v),b.code=z.OnPolygonVertex,b.closestEdgeIndex=N,b.closestEdgeParam=0,X=D)}else if(B<=1){const D=O-B*B*Y;if(D<=E){const k=O;if(B<=.5&&k<=E)return y.getPoint3dAtUncheckedPointIndex(N,b.point),b.a=Math.sqrt(k),b.v.setZero(),b.code=z.OnPolygonVertex,b.closestEdgeIndex=N,b.closestEdgeParam=0,b;const R=D+(1-B)*(1-B)*Y;return B>.5&&R<=E?(y.getPoint3dAtUncheckedPointIndex(M,b.point),b.a=Math.sqrt(R),b.v.setZero(),b.code=z.OnPolygonVertex,b.closestEdgeIndex=M,b.closestEdgeParam=0,b):(y.interpolateIndexIndex(N,B,M,b.point),b.a=Math.sqrt(D),b.v.setZero(),b.code=z.OnPolygonEdgeInterior,b.closestEdgeIndex=N,b.closestEdgeParam=B,b)}D<X&&(y.interpolateIndexIndex(N,B,M,b.point),b.a=Math.sqrt(D),y.crossProductIndexIndexXYAndZ(N,M,k,b.v),b.code=z.OnPolygonEdgeInterior,b.closestEdgeIndex=N,b.closestEdgeParam=B,X=D)}R=N}return b}static closestPoint(y,k,M=Q.smallMetricDistance,b){if(!(y instanceof it))return this.closestPoint(new ce(y),k,M,b);if(!this.unitNormal(y,this._normal))return Yr.create(b);const E=this._workPlane=_t.createXYZUVW(y.getXAtUncheckedPointIndex(0),y.getYAtUncheckedPointIndex(0),y.getZAtUncheckedPointIndex(0),this._normal.x,this._normal.y,this._normal.z,this._workPlane),D=this._workXYZ=E.projectPointToPlane(k,this._workXYZ);return(b=this.closestPointOnBoundary(y,D,M,b)).isValid&&(b.v.dotProduct(this._normal)>0&&(b.point.setFrom(D),z.OnPolygonVertex===b.code?b.code=z.InsidePolygonProjectsToVertex:z.OnPolygonEdgeInterior===b.code&&(b.code=z.InsidePolygonProjectsToEdgeInterior)),b.a=k.distance(b.point),b.v.setZero()),b}static intersectRay3d(y,k,M=Q.smallMetricDistance,b){if(!(y instanceof it))return this.intersectRay3d(new ce(y),k,M,b);if(!this.unitNormal(y,this._normal))return Yr.create(b);this._workPlane=_t.createXYZUVW(y.getXAtUncheckedPointIndex(0),y.getYAtUncheckedPointIndex(0),y.getZAtUncheckedPointIndex(0),this._normal.x,this._normal.y,this._normal.z,this._workPlane);const E=this._workXYZ=j.createZero(this._workXYZ),D=k.intersectionWithPlane(this._workPlane,E);if(void 0===D)return Yr.create(b);if((b=this.closestPointOnBoundary(y,E,M,b)).isValid){b.point.setFrom(E),b.a=D;const y=b.v.dotProduct(this._normal);0===y||(z.OnPolygonVertex===b.code?b.code=y>0?z.InsidePolygonProjectsToVertex:z.OutsidePolygonProjectsToVertex:z.OnPolygonEdgeInterior===b.code&&(b.code=y>0?z.InsidePolygonProjectsToEdgeInterior:z.OutsidePolygonProjectsToEdgeInterior))}return b}static intersectSegment(y,k,M,b=Q.smallMetricDistance,E){return this._workRay=bt.createStartEnd(k,M,this._workRay),this.intersectRay3d(y,this._workRay,b,E)}static computeEdgeDataXY(y,k,M,b,E=Q.smallMetricDistance,D){const R=k%y.length,X=(R+1)%y.length;y.vectorIndexIndex(R,X,b).unitPerpendicularXY(b).negate(b);const z=y.getXAtUncheckedPointIndex(R)-M.x,N=y.getYAtUncheckedPointIndex(R)-M.y;let Y=Q.dotProductXYXY(z,N,b.x,b.y);const O=Q.crossProductXYXY(z,N,b.x,b.y),B=Q.distanceXYXY(y.getXAtUncheckedPointIndex(R),y.getYAtUncheckedPointIndex(R),y.getXAtUncheckedPointIndex(X),y.getYAtUncheckedPointIndex(X));let V=Q.safeDivideFraction(O,B,0);return Q.isSameCoordinate(0,Y,E)&&(Y=0),Q.isSameCoordinate(0,V,E)?V=0:Q.isSameCoordinate(1,V,E)&&(V=1),H.create(Y,V,D)}static convexBarycentricCoordinatesOnEdge(y,k,M,b,E,D,R,X){const z=!M.isZero&&0===b.x&&Q.isIn01(b.y),N=!D.isZero&&0===R.x&&Q.isIn01(R.y);if(z&&N)return X.fill(0),X[E]=1,X;const Y=y.length;if(z){X.fill(0);const y=k,M=E,D=b.y;return X[y]=1-D,X[M]=D,X}if(N){X.fill(0);const y=E,k=(E+1)%Y,M=R.y;return X[y]=1-M,X[k]=M,X}}static convexBarycentricCoordinates(y,k,M=Q.smallMetricDistance){if(Array.isArray(y))return this.convexBarycentricCoordinates(new ce(y),k);let b=y.length;for(;b>1&&y.getPoint3dAtUncheckedPointIndex(0).isExactEqual(y.getPoint3dAtUncheckedPointIndex(b-1));)--b;if(b<3||!Ur.unitNormal(y,this._normal))return;const D=this._workMatrix3d=xt.createRigidHeadsUp(this._normal,E.ZXY,this._workMatrix3d),R=new nt(b);for(let E=0;E<b;++E)R.push(D.multiplyInverseXYZAsPoint3d(y.getXAtUncheckedPointIndex(E),y.getYAtUncheckedPointIndex(E),y.getZAtUncheckedPointIndex(E),this._workXYZ));const X=this._workXYZ=D.multiplyInverseXYZAsPoint3d(k.x,k.y,k.z,this._workXYZ);let z=b-1;const N=this._vector0,Y=this._workXY0=this.computeEdgeDataXY(R,z,X,N,M,this._workXY0);if(Y.x<0)return;const O=$.createFrom(N,this._vector1),B=this._workXY1=H.createFrom(Y,this._workXY1),V=Array(y.length).fill(0),U=M>0?1/(M*M):Q.largeCoordinateResult;let L=0;for(let E=0;E<b;++E){const y=$.createFrom(N,this._vector2),k=this._workXY2=E<b-1?this.computeEdgeDataXY(R,E,X,y,M,this._workXY2):H.createFrom(Y,this._workXY2);if(k.x<0)return;if(void 0!==this.convexBarycentricCoordinatesOnEdge(R,z,O,B,E,y,k,V))return V;if(0===y.x&&0===y.y)continue;if(0===B.x||0===k.x)continue;const D=Math.abs(O.crossProductXY(y)),Z=Q.conditionalDivideCoordinate(D,B.x*k.x,U);void 0===Z&&e(),V[E]=Z,L+=Z,O.setFrom(y),B.setFrom(k),z=E}const Z=Q.conditionalDivideCoordinate(1,L);void 0===Z&&e();for(let E=0;E<b;++E)V[E]*=Z;return V}static forceClosure(y,k=Q.smallMetricDistance){y.length>=2&&(y instanceof nt?y.forceClosure(k):y[0].distance(y[y.length-1])>k?y.push(y[0].clone()):y[y.length-1].setFromPoint3d(y[0]))}static ensureClosed(y,k=Q.smallMetricDistance){if(y.length>=2){let M=!1;if(M=y instanceof it?!y.almostEqualIndexIndex(0,y.length-1,0):!y[0].isExactEqual(y[y.length-1]),M){const M=nt.create(y);this.forceClosure(M,k),y=M}}return y}static closestApproach(y,k,M=Number.MAX_VALUE,b=!1){let E;const D=this.ensureClosed(y),R=this.ensureClosed(k),X=this._workCLDPair=Mi.closestApproach(D,!1,R,!1,M,this._workCLDPair);return X&&X.detailA.childDetail&&X.detailB.childDetail&&(E=Br.create(Yr.createAtVertexOrEdge(X.detailA.point,X.detailA.childDetail.a,X.detailA.childDetail.fraction),Yr.createAtVertexOrEdge(X.detailB.point,X.detailB.childDetail.a,X.detailB.childDetail.fraction)),E.detailA.a=E.detailB.a=X.detailA.a),E}}Ur._triangleMomentWeights=Xt.createRowValues(2/24,1/24,0,4/24,1/24,2/24,0,4/24,0,0,0,0,4/24,4/24,0,.5),Ur._tetrahedralMomentWeights=Xt.createRowValues(1/60,1/120,1/120,1/24,1/120,1/60,1/120,1/24,1/120,1/120,1/60,1/24,1/24,1/24,1/24,1/6),Ur._vector0=$.create(),Ur._vector1=$.create(),Ur._vector2=$.create(),Ur._vectorOrigin=$.create(),Ur._normal=$.create(),Ur._matrixA=Xt.createIdentity(),Ur._matrixB=Xt.createIdentity(),Ur._matrixC=Xt.createIdentity();class Zr{static splitConvexPolygonInsideOutsidePlane(y,k,M,b,E){const D=Zr._xyz0Work,R=Zr._xyz1Work,X=Zr._xyz2Work,z=k.length;if(M.clear(),b.clear(),z>2){k.back(D),E.setNull();let N=y.altitude(D);E.extendX(N);for(let Y=0;Y<z;Y++){k.getPoint3dAtUncheckedPointIndex(Y,R);const z=y.altitude(R);E.extendX(z);let O=!1;if(N*z<0){const y=-N/(z-N);y>1-1e-8&&z>=0?O=!0:(D.interpolate(y,R,X),M.push(X),b.push(X))}(z>=0||O)&&M.push(R),(z<=0||O)&&b.push(R),D.setFromPoint3d(R),N=z}}}static clipConvexPolygonInPlace(y,k,M,b=!0,E=Q.smallMetricDistance){M.clear();const D=b?1:-1,R=k.length;let X=0;const z=-E;let N=0;if(k.length>1){let b,Y=k.length-1,O=D*k.evaluateUncheckedIndexPlaneAltitude(Y,y);Math.abs(O)<E&&(O=0);for(let B=0;B<R;O=b,Y=B++){if(b=D*k.evaluateUncheckedIndexPlaneAltitude(B,y),Math.abs(b)<E&&(b=0),b<0&&X++,O*b<0){const y=-O/(b-O);y>1-1e-8&&b>=0||(M.pushInterpolatedFromGrowableXYZArray(k,Y,y,B),b>0&&N++)}b>=z&&(M.pushFromGrowableXYZArray(k,B),O<-z&&N++),Y=B,O=b}}return M.length<=2?k.clear():X>0&&(k.clear(),k.pushFromGrowableXYZArray(M)),M.clear(),N}static polygonPlaneCrossings(y,k,M){if(M.length=0,k.length>=2){const b=this._xyz0Work;k.getPoint3dAtUncheckedPointIndex(k.length-1,b);let E=y.altitude(b);const D=this._xyz1Work;for(let R=0;R<k.length;R++){k.getPoint3dAtUncheckedPointIndex(R,D);const X=y.altitude(D);if(E*X<0){const y=-E/(X-E);M.push(b.interpolate(y,D))}0===X&&M.push(D.clone()),b.setFromPoint3d(D),E=X}}}static gatherCutLoopsFromPlaneClip(y,k,M=3,b=Q.smallMetricDistance){const E=new Lr;let D=0;const R=k.length;for(;D<R;D++){const M=k.evaluateUncheckedIndexPlaneAltitude(D,y);if(Math.abs(M)<=b)break}if(D===R)return E;let X=D;for(;X<R;){const z=new nt;z.pushFromGrowableXYZArray(k,X);let N=X+1;for(;N<R;){z.pushFromGrowableXYZArray(k,N);const M=k.evaluateUncheckedIndexPlaneAltitude(N,y);if(Math.abs(M)<=b)break;N++}if(N===R)for(let y=0;y<=D;y++)z.pushFromGrowableXYZArray(k,y);z.length>=M&&E.inputLoops.push(Vr.createCaptureWithReturnEdge(z)),X=N}return E}static reorderCutLoops(y){if(1!==y.inputLoops.length){if(2===y.inputLoops.length){if(y.inputLoops[0].edge.direction.dotProduct(y.inputLoops[1].edge.direction)>0)return y.outputLoops.push(y.inputLoops[0]),void y.outputLoops.push(y.inputLoops[1]);const k=y.inputLoops[1].xyz;return y.inputLoops[0].xyz.pushFromGrowableXYZArray(k),void y.outputLoops.push(y.inputLoops[0])}y.sortAndMergeLoops()}}static intersectRangeConvexPolygonInPlace(y,k){if(y.isNull)return;const M=new nt,b=Dt.create();return b.set(0,0,-1,y.high.z),this.clipConvexPolygonInPlace(b,k,M,!0),0!==k.length&&(b.set(0,0,1,-y.low.z),this.clipConvexPolygonInPlace(b,k,M,!0),0!==k.length&&(b.set(0,-1,0,y.high.y),this.clipConvexPolygonInPlace(b,k,M,!0),0!==k.length&&(b.set(0,1,0,-y.low.y),this.clipConvexPolygonInPlace(b,k,M,!0),0!==k.length&&(b.set(-1,0,0,y.high.x),this.clipConvexPolygonInPlace(b,k,M,!0),0!==k.length&&(b.set(1,0,0,-y.low.x),this.clipConvexPolygonInPlace(b,k,M,!0),0!==k.length)))))?k:void 0}}Zr._xyz0Work=j.create(),Zr._xyz1Work=j.create(),Zr._xyz2Work=j.create();class qr{static convexPolygonSplitInsideOutsidePlane(y,k,M,b,E){const D=new ce(k),R=new ce(M),X=new ce(b);Zr.splitConvexPolygonInsideOutsidePlane(y,D,R,X,E)}static polygonPlaneCrossings(y,k,M){const b=new ce(k);return Zr.polygonPlaneCrossings(y,b,M)}static convexPolygonClipInPlace(y,k,M,b=Q.smallMetricDistance){void 0===M&&(M=[]),M.length=0;let E=0;const D=-b;if(k.length>2){let b=k[k.length-1],R=y.altitude(b);for(const X of k){const k=y.altitude(X);if(k<0&&E++,R*k<0){const y=-R/(k-R);y>1-1e-8&&k>=0||M.push(b.interpolate(y,X))}k>=D&&M.push(X),b=j.createFrom(X),R=k}}if(M.length<=2)k.length=0;else if(E>0){k.length=0;for(const y of M)k.push(y);M.length=0}}}qr._xyz0Work=j.create();class Wr extends tt{constructor(y,k,M,b){super(),this._invisible=M,this._interior=b,this._inwardNormal=y,this._distanceFromOrigin=k}isAlmostEqual(y){return Q.isSameCoordinate(this._distanceFromOrigin,y._distanceFromOrigin)&&this._inwardNormal.isAlmostEqual(y._inwardNormal)&&this._interior===y._interior&&this._invisible===y._invisible}clone(){return new Wr(this._inwardNormal.clone(),this._distanceFromOrigin,this._invisible,this._interior)}cloneNegated(){const y=new Wr(this._inwardNormal.clone(),this._distanceFromOrigin,this._invisible,this._interior);return y.negateInPlace(),y}static createPlane(y,k=!1,M=!1,b){const E=y.getNormalRef().dotProduct(y.getOriginRef());return b?(b._invisible=k,b._interior=M,b._inwardNormal=y.getNormalRef().clone(),b._distanceFromOrigin=E,b):new Wr(y.getNormalRef().clone(),E,k,M)}static createNormalAndDistance(y,k,M=!1,b=!1,E){const D=y.normalize();if(D)return E&&(E._invisible=M,E._interior=b,E._inwardNormal=D,E._distanceFromOrigin=k),new Wr(D,k,M,b)}static createNormalAndPoint(y,k,M=!1,b=!1,E){const D=y.normalize();if(D){const y=D.dotProduct(k);return E&&(E._invisible=M,E._interior=b,E._inwardNormal=D,E._distanceFromOrigin=y),new Wr(D,y,M,b)}}static createOriginAndVectors(y,k,M,b=!1,E=!1,D){const R=M.crossProduct(k);return this.createNormalAndPoint(R,y,b,E,D)}static createNormalAndPointXYZXYZ(y,k,M,b,E,D,R=!1,X=!1,z){const N=Q.hypotenuseXYZ(y,k,M),Y=Q.conditionalDivideFraction(1,N);if(void 0!==Y){if(z)return z._inwardNormal.set(y*Y,k*Y,M*Y),z._distanceFromOrigin=z._inwardNormal.dotProductXYZ(b,E,D),z._invisible=R,z._interior=X,z;const N=$.create(y*Y,k*Y,M*Y);return new Wr(N,N.dotProductXYZ(b,E,D),R,X)}}toJSON(){const y={normal:this.inwardNormalRef.toJSON(),dist:this.distance};return this.interior&&(y.interior=!0),this.invisible&&(y.invisible=!0),y}static fromJSON(y,k){return y&&y.normal&&void 0!==y.dist&&Number.isFinite(y.dist)?Wr.createNormalAndDistance($.fromJSON(y.normal),y.dist,!!y.invisible,!!y.interior):Wr.createNormalAndDistance($.unitZ(),0,!1,!1,k)}setFlags(y,k){this._invisible=y,this._interior=k}get distance(){return this._distanceFromOrigin}get inwardNormalRef(){return this._inwardNormal}get interior(){return this._interior}get invisible(){return this._invisible}static createEdgeAndUpVector(y,k,M,b,E){const D=$.createFrom(k.minus(y));let R=M.crossProduct(D).normalize();if(R){if(void 0!==b&&!b.isAlmostZero){const y=$.createRotateVectorAroundVector(R,D,b);y&&(R=y.clone())}return R.negate(R),Wr.createNormalAndPoint(R,y,!1,!1,E)}}static createEdgeXY(y,k,M){const b=$.create(y.y-k.y,k.x-y.x);if(b.normalizeInPlace())return Wr.createNormalAndPoint(b,y,!1,!1,M)}getPlane3d(){const y=this._distanceFromOrigin;return _t.create(j.create(this._inwardNormal.x*y,this._inwardNormal.y*y,this._inwardNormal.z*y),this._inwardNormal)}getPlane4d(){return Dt.create(this._inwardNormal.x,this._inwardNormal.y,this._inwardNormal.z,-this._distanceFromOrigin)}setPlane4d(y){const k=Math.sqrt(y.x*y.x+y.y*y.y+y.z*y.z),M=0===k?1:1/k;this._inwardNormal.x=M*y.x,this._inwardNormal.y=M*y.y,this._inwardNormal.z=M*y.z,this._distanceFromOrigin=-M*y.w}weightedAltitude(y){return y.x*this._inwardNormal.x+y.y*this._inwardNormal.y+y.z*this._inwardNormal.z-y.w*this._distanceFromOrigin}altitude(y){return y.x*this._inwardNormal.x+y.y*this._inwardNormal.y+y.z*this._inwardNormal.z-this._distanceFromOrigin}altitudeXYZ(y,k,M){return y*this._inwardNormal.x+k*this._inwardNormal.y+M*this._inwardNormal.z-this._distanceFromOrigin}normalX(){return this._inwardNormal.x}normalY(){return this._inwardNormal.y}normalZ(){return this._inwardNormal.z}velocity(y){return y.x*this._inwardNormal.x+y.y*this._inwardNormal.y+y.z*this._inwardNormal.z}velocityXYZ(y,k,M){return y*this._inwardNormal.x+k*this._inwardNormal.y+M*this._inwardNormal.z}dotProductPlaneNormalPoint(y){return y.x*this._inwardNormal.x+y.y*this._inwardNormal.y+y.z*this._inwardNormal.z}isPointOnOrInside(y,k=Q.smallMetricDistance){let M=this.altitude(y);return k&&(M+=k),M>=0}isPointInside(y,k=Q.smallMetricDistance){let M=this.altitude(y);return k&&(M-=k),M>0}isPointOn(y,k=Q.smallMetricDistance){return Math.abs(this.altitude(y))<=k}appendIntersectionRadians(y,k){const M=y.toVectors(),b=this.altitude(y.center),E=this.velocity(M.vector0),D=this.velocity(M.vector90);wt.appendImplicitLineUnitCircleIntersections(b,E,D,void 0,void 0,k)}announceClippedArcIntervals(y,k){const M=Wr._clipArcFractionArray;return M.clear(),this.appendIntersectionRadians(y,M),y.sweep.radiansArrayToPositivePeriodicFractions(M),Rs.selectIntervals01(y,M,this,k)}getBoundedSegmentSimpleIntersection(y,k){const M=this.altitude(y),b=this.altitude(k);if(!(M*b>0||0===M&&0===b))return-M/(b-M)}transformInPlace(y){const k=this.getPlane3d(),M=y.matrix,b=y.multiplyPoint3d(k.getOriginRef()),E=M.multiplyInverseTranspose(k.getNormalRef());if(!E)return!1;k.set(b,E);const D=k.getNormalRef().normalize();return!!D&&(this._inwardNormal=D,this._distanceFromOrigin=this._inwardNormal.dotProduct(k.getOriginRef()),!0)}setInvisible(y){this._invisible=y}negateInPlace(){this._inwardNormal=this._inwardNormal.negate(),this._distanceFromOrigin=-this._distanceFromOrigin}offsetDistance(y){this._distanceFromOrigin+=y}clipConvexPolygonInPlace(y,k,M=!0,b=Q.smallMetricDistance){return Zr.clipConvexPolygonInPlace(this,y,k,M,b)}multiplyPlaneByMatrix4d(y,k=!0,M=!0){const b=this.getPlane4d();if(k){const k=y.createInverse();return!!k&&this.multiplyPlaneByMatrix4d(k,!1,M)}return M?y.multiplyTransposePoint4d(b,b):y.multiplyPoint4d(b,b),this.setPlane4d(b),!0}announceClippedSegmentIntervals(y,k,M,b,E){if(k<y)return!1;const D=-this.altitude(M),R=-this.altitude(b)-D,X=Q.conditionalDivideFraction(-D,R);return void 0===X?D<=0&&(E&&E(y,k),!0):(R>0?X<k&&(k=X):X>y&&(y=X),!(k<y||(E&&E(y,k),0)))}getFrame(){const y=this._distanceFromOrigin,k=j.create(this._inwardNormal.x*y,this._inwardNormal.y*y,this._inwardNormal.z*y),M=xt.createRigidHeadsUp(this._inwardNormal,E.ZXY);return pt.createOriginAndMatrix(k,M)}intersectRange(y,k=!1){if(y.isNull)return;const M=y.corners(),b=this.getFrame();b.multiplyInversePoint3dArrayInPlace(M);const E=ut.createArray(M);if(E.low.z*E.high.z>0)return;const D=new nt;return D.pushXYZ(E.low.x,E.low.y,0),D.pushXYZ(E.high.x,E.low.y,0),D.pushXYZ(E.high.x,E.high.y,0),D.pushXYZ(E.low.x,E.high.y,0),D.multiplyTransformInPlace(b),Zr.intersectRangeConvexPolygonInPlace(y,D),0!==D.length?(k&&D.pushWrap(1),D):void 0}appendPolygonClip(y,k,M,b){const E=ft.createNull(),D=b.grabFromCache(),R=b.grabFromCache();Zr.splitConvexPolygonInsideOutsidePlane(this,y,D,R,E),Rs.captureOrDrop(D,3,k,b),Rs.captureOrDrop(R,3,M,b)}projectPointToPlane(y,k){const M=-this.altitude(y);return y.plusXYZ(M*this._inwardNormal.x,M*this._inwardNormal.y,M*this._inwardNormal.z,k)}}Wr._clipArcFractionArray=new It;const Do={aliceBlue:16775408,amber:49151,antiqueWhite:14150650,aqua:16776960,aquamarine:13959039,azure:16777200,beige:14480885,bisque:12903679,black:0,blanchedAlmond:13495295,blue:16711680,blueViolet:14822282,brown:2763429,burlyWood:8894686,cadetBlue:10526303,chartreuse:65407,chocolate:1993170,coral:5275647,cornflowerBlue:15570276,cornSilk:14481663,crimson:3937500,cyan:16776960,darkBlue:9109504,darkBrown:2179941,darkCyan:9145088,darkGoldenrod:755384,darkGray:11119017,darkGreen:25600,darkGrey:11119017,darkKhaki:7059389,darkMagenta:9109643,darkOliveGreen:3107669,darkOrange:36095,darkOrchid:13382297,darkRed:139,darkSalmon:8034025,darkSeagreen:9419919,darkSlateBlue:9125192,darkSlateGray:5197615,darkSlateGrey:5197615,darkTurquoise:13749760,darkViolet:13828244,deepPink:9639167,deepSkyBlue:16760576,dimGray:6908265,dimGrey:6908265,dodgerBlue:16748574,fireBrick:2237106,floralWhite:15792895,forestGreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostWhite:16775416,gold:55295,goldenrod:2139610,gray:8421504,green:32768,greenYellow:3145645,grey:8421504,honeydew:15794160,hotPink:11823615,indianRed:6053069,indigo:8519755,ivory:15794175,khaki:9234160,lavender:16443110,lavenderBlush:16118015,lawnGreen:64636,lemonChiffon:13499135,lightBlue:15128749,lightCoral:8421616,lightCyan:16777184,lightGoldenrodYellow:13826810,lightGray:13882323,lightGreen:9498256,lightGrey:13882323,lightPink:12695295,lightSalmon:8036607,lightSeagreen:11186720,lightSkyBlue:16436871,lightSlateGray:10061943,lightSlateGrey:10061943,lightSteelBlue:14599344,lightyellow:14745599,lime:65280,limeGreen:3329330,linen:15134970,magenta:16711935,maroon:128,mediumAquamarine:11193702,mediumBlue:13434880,mediumOrchid:13850042,mediumPurple:14381203,mediumSeaGreen:7451452,mediumSlateBlue:15624315,mediumSpringGreen:10156544,mediumTurquoise:13422920,mediumVioletRed:8721863,midnightBlue:7346457,mintCream:16449525,mistyRose:14804223,moccasin:11920639,navajoWhite:11394815,navy:8388608,oldLace:15136253,olive:32896,oliveDrab:2330219,orange:42495,orangeRed:17919,orchid:14053594,paleGoldenrod:11200750,paleGreen:10025880,paleTurquoise:15658671,paleVioletRed:9662683,papayaWhip:14020607,peachPuff:12180223,peru:4163021,pink:13353215,plum:14524637,powderBlue:15130800,purple:8388736,rebeccaPurple:10040166,red:255,rosyBrown:9408444,royalBlue:14772545,saddleBrown:1262987,salmon:7504122,sandyBrown:6333684,seaGreen:5737262,seaShell:15660543,sienna:2970272,silver:12632256,skyBlue:15453831,slateBlue:13458026,slateGray:9470064,slateGrey:9470064,snow:16448255,springGreen:8388352,steelBlue:11829830,tan:9221330,teal:8421376,thistle:14204888,tomato:4678655,turquoise:13688896,violet:15631086,wheat:11788021,white:16777215,whiteSmoke:16119285,yellow:65535,yellowGreen:3329434};class Hr{constructor(y=0,k=0,M=0){this.h=y,this.s=k,this.l=M}clone(y,k,M){return new Hr(y??this.h,k??this.s,M??this.l)}toColorDef(y=0){return $r.fromHSL(this.h,this.s,this.l,y)}static fromColorDef(y){return y.toHSL()}}var Ro;!function(y){y[y.VISIBILITY_GOAL=40]="VISIBILITY_GOAL",y[y.HSV_SATURATION_WEIGHT=4]="HSV_SATURATION_WEIGHT",y[y.HSV_VALUE_WEIGHT=2]="HSV_VALUE_WEIGHT"}(Ro||(Ro={}));class Qr{constructor(y=0,k=0,M=0){this.h=y,this.s=k,this.v=M}clone(y,k,M){return new Qr(y??this.h,k??this.s,M??this.v)}toColorDef(y=0){return $r.fromHSV(this,y)}static fromColorDef(y){return y.toHSV()}adjusted(y,k){let M;if(y){if(M=k*Ro.HSV_VALUE_WEIGHT,this.v>=M)return new Qr(this.h,this.s,this.v-M);M-=this.v;const y=Math.min(this.s+M,100);return new Qr(this.h,y,0)}if(M=k*Ro.HSV_SATURATION_WEIGHT,this.s>=M)return new Qr(this.h,this.s-M,this.v);M-=this.s;const b=Math.min(this.v+M,100);return new Qr(this.h,0,b)}}const Xo=new Uint8Array(4),zo=new Uint32Array(Xo.buffer);class $r{constructor(y){zo[0]=y,this._tbgr=zo[0]}static create(y){return this.fromTbgr(this.computeTbgr(y))}static computeTbgr(y){switch(typeof y){case"number":return y;case"string":return this.computeTbgrFromString(y);default:return 0}}toJSON(){return this._tbgr}static fromJSON(y){return this.create(y)}static from(y,k,M,b){return this.fromTbgr(this.computeTbgrFromComponents(y,k,M,b))}static computeTbgrFromComponents(y,k,M,b){return Xo[0]=y,Xo[1]=k,Xo[2]=M,Xo[3]=b||0,zo[0]}static fromTbgr(y){switch(y){case Do.black:return this.black;case Do.white:return this.white;case Do.red:return this.red;case Do.green:return this.green;case Do.blue:return this.blue;default:return new $r(y)}}static fromAbgr(y){return this.fromTbgr(this.getAbgr(y))}static fromString(y){return this.fromTbgr(this.computeTbgrFromString(y))}static isValidColor(y){return"number"==typeof y?y>=0&&y<=4294967295&&Math.floor(y)===y:void 0!==this.tryComputeTbgrFromString(y)}static computeTbgrFromString(y){return this.tryComputeTbgrFromString(y)??0}static tryComputeTbgrFromString(y){if("string"!=typeof y)return;y=y.toLowerCase();let k=/^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(y);if(k){let y;const M=k[1],b=k[2],n=y=>"%"===y[y.length-1],r=y=>{const k=parseFloat(y);return 255*Q.clamp(n(y)?k/100:k,0,1)},o=y=>{const k=n(y)?parseFloat(y)/100*255:parseInt(y,10);return Q.clamp(k,0,255)};switch(M){case"rgb":case"rgba":if(y=/^(\d+%*)\s*[, ]\s*(\d+%*)\s*[, ]\s*(\d+%*)\s*([,\/]\s*([0-9]*\.?[0-9]+%*)\s*)?$/.exec(b),y)return this.computeTbgrFromComponents(o(y[1]),o(y[2]),o(y[3]),"string"==typeof y[5]?255-r(y[5]):0);break;case"hsl":case"hsla":if(y=/^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(b),y){const k=parseFloat(y[1])/360,M=parseInt(y[2],10)/100,b=parseInt(y[3],10)/100,E="string"==typeof y[5]?255-r(y[5]):0;return this.computeTbgrFromHSL(k,M,b,E)}}}else if(k=/^\#([a-f0-9]+)$/.exec(y)){const y=k[1],M=y.length;if(3===M)return this.computeTbgrFromComponents(parseInt(y.charAt(0)+y.charAt(0),16),parseInt(y.charAt(1)+y.charAt(1),16),parseInt(y.charAt(2)+y.charAt(2),16),0);if(6===M)return this.computeTbgrFromComponents(parseInt(y.charAt(0)+y.charAt(1),16),parseInt(y.charAt(2)+y.charAt(3),16),parseInt(y.charAt(4)+y.charAt(5),16),0)}if(y&&y.length>0)for(const[M,b]of Object.entries(Do))if(M.toLowerCase()===y)return b}get colors(){return $r.getColors(this._tbgr)}static getColors(y){return zo[0]=y,{b:Xo[2],g:Xo[1],r:Xo[0],t:Xo[3]}}get tbgr(){return this._tbgr}getAbgr(){return $r.getAbgr(this._tbgr)}static getAbgr(y){return zo[0]=y,Xo[3]=255-Xo[3],zo[0]}getRgb(){return $r.getRgb(this._tbgr)}static getRgb(y){return zo[0]=y,(Xo[0]<<16)+(Xo[1]<<8)+Xo[2]}withAlpha(y){const k=$r.withAlpha(this._tbgr,y);return k===this._tbgr?this:$r.fromTbgr(k)}static withAlpha(y,k){return zo[0]=y,Xo[3]=255-(0|k),zo[0]}getAlpha(){return $r.getAlpha(this._tbgr)}static getAlpha(y){return zo[0]=y,255-Xo[3]}get isOpaque(){return $r.isOpaque(this._tbgr)}static isOpaque(y){return 255===this.getAlpha(y)}getTransparency(){return $r.getTransparency(this._tbgr)}static getTransparency(y){return zo[0]=y,Xo[3]}withTransparency(y){const k=$r.withTransparency(this._tbgr,y);return k===this._tbgr?this:$r.fromTbgr(k)}static withTransparency(y,k){return this.withAlpha(y,255-k)}get name(){return $r.getName(this.tbgr)}static getName(y){for(const[k,M]of Object.entries(Do))if(M===y)return k}toHexString(){return $r.toHexString(this.tbgr)}static toHexString(y){return`#${`000000${this.getRgb(y).toString(16)}`.slice(-6)}`}static getColorsString(y){const k=this.getColors(y);return`${k.r},${k.g},${k.b}`}toRgbString(){return $r.toRgbString(this.tbgr)}static toRgbString(y){return`rgb(${this.getColorsString(y)})`}toRgbaString(){return $r.toRgbaString(this.tbgr)}static toRgbaString(y){return`rgba(${this.getColorsString(y)},${this.getAlpha(y)/255})`}lerp(y,k){return $r.fromTbgr($r.lerp(this.tbgr,y.tbgr,k))}static lerp(y,k,M){const b=this.getColors(y),E=this.getColors(k);return b.r+=(E.r-b.r)*M,b.g+=(E.g-b.g)*M,b.b+=(E.b-b.b)*M,this.computeTbgrFromComponents(b.r,b.g,b.b,b.t)}inverse(){return $r.fromTbgr($r.inverse(this.tbgr))}static inverse(y){const k=this.getColors(y);return this.computeTbgrFromComponents(255-k.r,255-k.g,255-k.b)}static fromHSL(y,k,M,b=0){return this.fromTbgr(this.computeTbgrFromHSL(y,k,M,b))}static computeTbgrFromHSL(y,k,M,b=0){const n=(y,k,M)=>Math.round(255*((y,k,M)=>(M<0&&(M+=1),M>1&&(M-=1),M<1/6?y+6*(k-y)*M:M<.5?k:M<2/3?y+6*(k-y)*(2/3-M):y))(y,k,M));if(y=(y%1+1)%1,k=Q.clamp(k,0,1),M=Q.clamp(M,0,1),0===k)return M*=255,this.computeTbgrFromComponents(M,M,M,b);const E=M<=.5?M*(1+k):M+k-M*k,D=2*M-E;return this.computeTbgrFromComponents(n(D,E,y+1/3),n(D,E,y),n(D,E,y-1/3),b)}toHSL(){const y=this.colors;y.r/=255,y.g/=255,y.b/=255;const k=Math.max(y.r,y.g,y.b),M=Math.min(y.r,y.g,y.b);let b,E=0;const D=(M+k)/2;if(M===k)b=0;else{const R=k-M;switch(b=D<=.5?R/(k+M):R/(2-k-M),k){case y.r:E=(y.g-y.b)/R+(y.g<y.b?6:0);break;case y.g:E=(y.b-y.r)/R+2;break;case y.b:E=(y.r-y.g)/R+4}E/=6}return new Hr(E,b,D)}toHSV(){const{r:y,g:k,b:M}=this.colors;let b=y<k?y:k;M<b&&(b=M);let E=y>k?y:k;M>E&&(E=M);const D=Math.floor(E/255*100+.5),R=E-b,X=0!==E?Math.floor(R/E*100+.5):0;let z=0;if(X){const b=(E-y)/R,D=(E-k)/R,X=(E-M)/R;let N;N=y===E?X-D:k===E?2+b-X:4+D-b,N*=60,N<0&&(N+=360),z=Math.floor(N+.5),z>=360&&(z=0)}else z=0;return new Qr(z,X,D)}static fromHSV(y,k=0){if(!y.s||-1===y.h){const k=255&Math.floor(255*y.v/100+.5+3e-14);return $r.from(k,k,k,0)}let M=y.h,b=y.s,E=y.v;360===M&&(M=0),M/=60;const D=Math.floor(M),R=M-D;E/=100,b/=100;const X=255&Math.floor(E*(1-b)*255+.5),z=255&Math.floor(E*(1-b*R)*255+.5),N=255&Math.floor(E*(1-b*(1-R))*255+.5),Y=255&Math.floor(255*E+.5);let O=0,B=0,V=0;switch(D){case 0:O=Y,V=N,B=X;break;case 1:O=z,V=Y,B=X;break;case 2:O=X,V=Y,B=N;break;case 3:O=X,V=z,B=Y;break;case 4:O=N,V=X,B=Y;break;case 5:O=Y,V=X,B=z}return $r.from(O,V,B,k)}visibilityCheck(y){const k=this.colors,M=y.colors;return.3*Math.abs(k.r-M.r)+.59*Math.abs(k.g-M.g)+.11*Math.abs(k.b-M.b)}adjustedForContrast(y,k){const M=this.visibilityCheck(y);if(Ro.VISIBILITY_GOAL<=M)return void 0!==k?this.withAlpha(k):this;const b=Math.floor((Ro.VISIBILITY_GOAL-M)/255*100);let E=this.toHSV(),D=E.clone();E=E.adjusted(!0,b),D=D.adjusted(!1,b),void 0===k&&(k=this.getAlpha());const R=$r.fromHSV(E).withAlpha(k),X=$r.fromHSV(D).withAlpha(k);return X.getRgb()===y.getRgb()?R:R.getRgb()===y.getRgb()||X.visibilityCheck(y)>=R.visibilityCheck(y)?X:R}equals(y){return this._tbgr===y._tbgr}}$r.black=new $r(Do.black),$r.white=new $r(Do.white),$r.red=new $r(Do.red),$r.green=new $r(Do.green),$r.blue=new $r(Do.blue);class to{constructor(y,k,M){this.r=y,this.g=k,this.b=M,this.r=Math.max(0,Math.min(this.r,255)),this.g=Math.max(0,Math.min(this.g,255)),this.b=Math.max(0,Math.min(this.b,255))}static fromColorDef(y){const k=y.colors;return new to(k.r,k.g,k.b)}toColorDef(y=0){return $r.from(this.r,this.g,this.b,y)}toJSON(){return{r:this.r,g:this.g,b:this.b}}static fromJSON(y){let k=255,M=255,b=255;return void 0!==y&&("number"==typeof y.r&&(k=y.r),"number"==typeof y.g&&(M=y.g),"number"==typeof y.b&&(b=y.b)),new to(k,M,b)}equals(y){return this.r===y.r&&this.g===y.g&&this.b===y.b}compareTo(y){return i(this.r,y.r)||i(this.g,y.g)||i(this.b,y.b)}toHexString(){return this.toColorDef().toHexString()}}class eo{constructor(y,k){this.value=y,this.index=k}}class io{constructor(y,k=Number.MAX_SAFE_INTEGER,M=Le){this._array=[],this._compareValues=y,this._clone=M,this._maximumSize=k}get length(){return this._array.length}get isFull(){return this.length>=this._maximumSize}get isEmpty(){return 0===this.length}clear(){this._array=[]}insert(y,k){const M=this.lowerBound(y);if(M.equal)return this._array[M.index].index;if(this.isFull)return-1;const b=new eo(this._clone(y),this._array.length);return void 0!==k&&k(b.value),this._array.splice(M.index,0,b),b.index}indexOf(y){const k=this.lowerBound(y);return k.equal?this._array[k.index].index:-1}lowerBound(y){return Ue(y,this._array,((y,k)=>this._compareValues(y,k.value)))}toArray(){const y=[];for(const k of this._array)y[k.index]=k.value;return y}}var No,Yo,Oo,Bo,Vo,Uo;!function(y){y[y.Never=0]="Never",y[y.ByView=1]="ByView",y[y.Always=2]="Always",y[y.Blanking=3]="Blanking"}(No||(No={})),function(y){y[y.None=0]="None",y[y.Solid=1]="Solid",y[y.Outline=2]="Outline"}(Yo||(Yo={})),function(y){y[y.Primary=0]="Primary",y[y.Construction=1]="Construction",y[y.Dimension=2]="Dimension",y[y.Pattern=3]="Pattern"}(Oo||(Oo={}));class lo{constructor(k=y.invalid,M=y.invalid,b=Oo.Primary){this.elementId=k,this.subCategoryId=M,this.geometryClass=b}get isDefined(){return!y.isInvalid(this.elementId)||!y.isInvalid(this.subCategoryId)||this.geometryClass!==Oo.Primary}get isUndefined(){return!this.isDefined}equals(y){return 0===this.compare(y)}compare(y){if(this===y)return 0;let k=i(this.geometryClass,y.geometryClass);return 0===k&&(k=n(this.elementId,y.elementId),0===k&&(k=n(this.subCategoryId,y.subCategoryId))),k}}!function(k){k.create=function(){return{modelId:y.invalid,elementId:y.invalid,subCategoryId:y.invalid,geometryClass:Oo.Primary}},k.isDefined=function(k){return!y.isInvalid(k.modelId)||!y.isInvalid(k.elementId)||!y.isInvalid(k.subCategoryId)||k.geometryClass!==Oo.Primary},k.unpack=function(k,M,b){return M.modelId=b??y.fromUint32PairObject(k.modelId),M.elementId=y.fromUint32PairObject(k.elementId),M.subCategoryId=y.fromUint32PairObject(k.subCategoryId),M.geometryClass=k.geometryClass,M}}(Bo||(Bo={})),function(y){function e(){const y={upper:0,lower:0};return{modelId:{...y},elementId:{...y},subCategoryId:{...y},geometryClass:Oo.Primary,animationNodeId:0}}y.create=e,y.createWithIndex=function(){const y=e();return y.index=0,y}}(Vo||(Vo={})),function(y){y[y.Primary=0]="Primary",y[y.VolumeClassifier=1]="VolumeClassifier",y[y.PlanarClassifier=2]="PlanarClassifier"}(Uo||(Uo={}));class ho extends io{constructor(k,M=y.invalid,b=Uo.Primary){super(((y,k)=>y.compare(k)),k),this.modelId=M,this.type=b}get maxFeatures(){return this._maximumSize}get anyDefined(){return this.length>1||1===this.length&&this._array[0].value.isDefined}get isUniform(){return 1===this.length}get uniform(){return 1===this.length?this._array[0].value:void 0}get isVolumeClassifier(){return Uo.VolumeClassifier===this.type}get isPlanarClassifier(){return Uo.PlanarClassifier===this.type}findFeature(y){for(const k of this._array)if(k.index===y)return k.value}insertWithIndex(y,k){const M=this.lowerBound(y);e(M.equal),e(this.isFull);const b=new eo(y,k);this._array.splice(M.index,0,b)}getArray(){return this._array}pack(){return go.pack(this)}}const Lo=Vo.create();function fo(y,k,M){let b;e();const E=Vo.createWithIndex();for(const D of y.iterable(E)){const E=k(D);if(e(),0!==E){if(!b){const k=y.numFeatures;b=M<256?new Uint8Array(k):M<65536?new Uint16Array(k):new Uint32Array(k)}b[D.index]=E}}return b}class go{get byteLength(){return this.data.byteLength}constructor(k,M,b,E,D){switch(this.data=k,this.batchModelId=M,this.batchModelIdPair=y.getUint32Pair(M),this.numFeatures=b,this.type=E,this.animationNodeIds=D,this.numFeatures){case 0:this.anyDefined=!1;break;case 1:this.anyDefined=Bo.isDefined(this.getFeature(0,Bo.create()));break;default:this.anyDefined=!0}e((this.data.length,this._subCategoriesOffset)),e(void 0===this.animationNodeIds||(this.animationNodeIds.length,this.numFeatures))}static pack(k){const M=new Map;for(const y of k.getArray())void 0===M.get(y.value.subCategoryId.toString())&&M.set(y.value.subCategoryId,M.size);const b=3*k.length,E=b+2*M.size,D=new Uint32Array(E);for(const R of k.getArray()){const k=R.value,b=3*R.index;let E=M.get(k.subCategoryId);e(),E|=k.geometryClass<<24,D[b+0]=y.getLowerUint32(k.elementId),D[b+1]=y.getUpperUint32(k.elementId),D[b+2]=E}return M.forEach(((k,M,E)=>{const R=b+2*k;D[R+0]=y.getLowerUint32(M),D[R+1]=y.getUpperUint32(M)})),new go(D,k.modelId,k.length,k.type)}getFeature(y,k){const M=this.getPackedFeature(y,Lo);return Bo.unpack(M,k,this.batchModelId)}findFeature(y,k){return y<this.numFeatures?this.getFeature(y,k):void 0}getElementIdPair(y,k){k=k??{lower:0,upper:0},e(this.numFeatures);const M=3*y;return k.lower=this.data[M],k.upper=this.data[M+1],k}getSubCategoryIdPair(y){const k=3*y;let M=this.data[k+2];return M=(16777215&M)>>>0,M=2*M+this._subCategoriesOffset,{lower:this.data[M],upper:this.data[M+1]}}getAnimationNodeId(y){return void 0!==this.animationNodeIds&&y<this.numFeatures?this.animationNodeIds[y]:0}getPackedFeature(y,k){e(this.numFeatures);const M=3*y;k.elementId.lower=this.data[M],k.elementId.upper=this.data[M+1];const b=this.data[M+2];k.geometryClass=b>>>24&255;let E=(16777215&b)>>>0;return E=2*E+this._subCategoriesOffset,k.subCategoryId.lower=this.data[E],k.subCategoryId.upper=this.data[E+1],k.animationNodeId=this.getAnimationNodeId(y),k.modelId.lower=this.batchModelIdPair.lower,k.modelId.upper=this.batchModelIdPair.upper,k}getModelIdPair(y,k){return k.lower=this.batchModelIdPair.lower,k.upper=this.batchModelIdPair.upper,k}findElementId(y){return y>=this.numFeatures?void 0:this.readId(3*y)}get isUniform(){return 1===this.numFeatures}getUniform(y){return this.isUniform?this.getFeature(0,y):void 0}get isVolumeClassifier(){return Uo.VolumeClassifier===this.type}get isPlanarClassifier(){return Uo.VolumeClassifier===this.type}get isClassifier(){return this.isVolumeClassifier||this.isPlanarClassifier}unpack(){const y=new ho(this.numFeatures,this.batchModelId),k=Bo.create();for(let M=0;M<this.numFeatures;M++)this.getFeature(M,k),y.insertWithIndex(new lo(k.elementId,k.subCategoryId,k.geometryClass),M);return y}populateAnimationNodeIds(y,k){e(this.animationNodeIds),this.animationNodeIds=fo(this,y,k)}*iterator(y){for(let k=0;k<this.numFeatures;k++)this.getPackedFeature(k,y),y.index=k,yield y}iterable(y){return{[Symbol.iterator]:()=>this.iterator(y)}}get _subCategoriesOffset(){return 3*this.numFeatures}readId(k){return y.fromUint32Pair(this.data[k],this.data[k+1])}}const Qo={lastFeatureIndex:-1,idLower:-1,idUpper:-1};class mo{constructor(y){this._data=y,e(this._data.length)}get length(){return this._data.length/3}get byteLength(){return this._data.byteLength}getLastFeatureIndex(y){return this._data[3*y]}getEntry(y,k){if(y>=this.length)return k.idLower=k.idUpper=0,k.lastFeatureIndex=Number.MAX_SAFE_INTEGER,k;const M=3*y;return k.lastFeatureIndex=this._data[M+0],k.idLower=this._data[M+1],k.idUpper=this._data[M+2],k}getModelIdPair(y,k){k?k.lower=k.upper=0:k={lower:0,upper:0};let M=0;const b=this.length;let E=b;for(;E>0;){const k=Math.floor(E/2),b=M+k;y>this.getLastFeatureIndex(b)?(M=b+1,E-=k+1):E=k}return M<b&&(k.lower=this._data[3*M+1],k.upper=this._data[3*M+2]),k}}class xo{constructor(y,k){this._features=y,this._models=k}static create(y,k,M,b,E){const D=3*M+2*E,R=y.subarray(0,D),X=new go(R,k,M,b),z=y.subarray(D),N=new mo(z);return new xo(X,N)}get batchModelId(){return this._features.batchModelId}get batchModelIdPair(){return this._features.batchModelIdPair}get numFeatures(){return this._features.numFeatures}get type(){return this._features.type}get animationNodeIds(){return this._features.animationNodeIds}set animationNodeIds(y){this._features.animationNodeIds=y}get byteLength(){return this._features.byteLength+this._models.byteLength}getPackedFeature(y,k){return this._features.getPackedFeature(y,k),this._models.getModelIdPair(y,k.modelId),k}getFeature(y,k){const M=this.getPackedFeature(y,Lo);return Bo.unpack(M,k)}findFeature(y,k){return y<this.numFeatures?this.getFeature(y,k):void 0}getElementIdPair(y,k){return this._features.getElementIdPair(y,k)}getModelIdPair(y,k){return this._models.getModelIdPair(y,k),k}findElementId(y){return this._features.findElementId(y)}*iterator(y){let k=0;const M=this._models.getEntry(k,Qo);for(let b=0;b<this.numFeatures;b++)b>M.lastFeatureIndex&&this._models.getEntry(++k,M),this._features.getPackedFeature(b,y),y.modelId.lower=M.idLower,y.modelId.upper=M.idUpper,y.index=b,yield y}iterable(y){return{[Symbol.iterator]:()=>this.iterator(y)}}getAnimationNodeId(y){return this._features.getAnimationNodeId(y)}populateAnimationNodeIds(y,k){this._features.animationNodeIds=fo(this,y,k)}}function _o(y,k){if(y.clear(),"string"==typeof k)y.addId(k);else for(const M of k)y.addId(M)}function yo(y,k){return y===k||!(!y||!k)&&y.equals(k)}function vo(y,k){return y===k||void 0!==y&&void 0!==k&&Math.floor(255*y)===Math.floor(255*k)}function Po(y){if(void 0===y)return;const k=1e-4;return 1-(y=Math.max(0,Math.min(y,1)))<k?y=1:y<k&&(y=0),y}class Ao{static fromJSON(y){return!y||function(y){return!(y.rgb||y.lineRgb||void 0!==y.weight||void 0!==y.linePixels||void 0!==y.transparency||void 0!==y.lineTransparency||y.ignoresMaterial||y.nonLocatable||y.emphasized)}(y)?this.defaults:new Ao(y)}static fromRgb(y){return new Ao({rgb:to.fromColorDef(y)})}static fromRgba(y,k=!1){return new Ao({rgb:to.fromColorDef(y),transparency:y.colors.t/255,viewDependentTransparency:!!k||void 0})}static fromTransparency(y,k=!1){return new Ao({transparency:y,viewDependentTransparency:!!k||void 0})}static fromSubCategoryOverride(k){const M=void 0!==k.color?to.fromColorDef(k.color):void 0,b=k.transparency,E=k.weight,D=!(void 0===k.material||!y.isValid(k.material))||void 0;return this.fromJSON({rgb:M,transparency:b,weight:E,ignoresMaterial:D,viewDependentTransparency:!0})}get matchesDefaults(){return this.equals(Ao.defaults)}get overridesRgb(){return void 0!==this.rgb}get overridesTransparency(){return void 0!==this.transparency}get overridesLinePixels(){return void 0!==this.linePixels}get overridesWeight(){return void 0!==this.weight}getLineRgb(){return!1!==this.lineRgb?this.lineRgb??this.rgb:void 0}getLineTransparency(){return!1!==this.lineTransparency?this.lineTransparency??this.transparency:void 0}get overridesSymbology(){return this.overridesRgb||this.overridesTransparency||this.overridesWeight||this.overridesLinePixels||!!this.ignoresMaterial||this.emphasized||this.overridesNonLocatable||void 0!==this.getLineRgb()||void 0!==this.getLineTransparency()}get overridesNonLocatable(){return void 0!==this.nonLocatable}get isFullyTransparent(){const y=this.transparency??0,k=this.getLineTransparency()??0;return y>=1&&k>=1}get anyOverridden(){return this.overridesSymbology||this.overridesNonLocatable}equals(y){return this===y||yo(this.rgb,y.rgb)&&this.weight===y.weight&&vo(this.transparency,y.transparency)&&this.linePixels===y.linePixels&&this.ignoresMaterial===y.ignoresMaterial&&this.nonLocatable===y.nonLocatable&&this.emphasized===y.emphasized&&this.viewDependentTransparency===y.viewDependentTransparency&&((k=this.lineTransparency)===(M=y.lineTransparency)||("number"==typeof k&&"number"==typeof M?vo(k,M):(e(),e(),!1)))&&function(y,k){return y===k||(y instanceof to&&k instanceof to?yo(y,k):(e(),e(),!1))}(this.lineRgb,y.lineRgb);var k,M}toJSON(){const y={};return this.rgb&&(y.rgb=this.rgb.toJSON()),void 0!==this.weight&&(y.weight=this.weight),void 0!==this.transparency&&(y.transparency=this.transparency,this.viewDependentTransparency&&(y.viewDependentTransparency=!0)),void 0!==this.linePixels&&(y.linePixels=this.linePixels),!0===this.ignoresMaterial&&(y.ignoresMaterial=!0),!0===this.nonLocatable&&(y.nonLocatable=!0),!0===this.emphasized&&(y.emphasized=!0),void 0!==this.lineTransparency&&(y.lineTransparency=this.lineTransparency),this.lineRgb&&(y.lineRgb=this.lineRgb,this.viewDependentTransparency&&(y.viewDependentTransparency=!0)),y}cloneProps(y){return{...this.toJSON(),...y}}clone(y){return Ao.fromJSON(this.cloneProps(y))}extendAppearance(y){if(!this.overridesSymbology)return y;const k=y.toJSON();return void 0===k.rgb&&(k.rgb=this.rgb),void 0===k.transparency&&(k.transparency=this.transparency),void 0===k.linePixels&&(k.linePixels=this.linePixels),void 0===k.weight&&(k.weight=this.weight),void 0===k.ignoresMaterial&&this.ignoresMaterial&&(k.ignoresMaterial=!0),void 0===k.nonLocatable&&this.nonLocatable&&(k.nonLocatable=!0),void 0===k.emphasized&&this.emphasized&&(k.emphasized=!0),k.lineRgb||(k.lineRgb=this.lineRgb),void 0===k.lineTransparency&&(k.lineTransparency=this.lineTransparency),!this.viewDependentTransparency||void 0===k.transparency&&void 0===k.lineTransparency||(k.viewDependentTransparency=!0),Ao.fromJSON(k)}constructor(y){this.rgb=void 0!==y.rgb?to.fromJSON(y.rgb):void 0,this.lineRgb="object"==typeof y.lineRgb?to.fromJSON(y.lineRgb):!1!==y.lineRgb&&void 0,this.transparency=Po(y.transparency),this.lineTransparency="number"==typeof y.lineTransparency?Po(y.lineTransparency):!1!==y.lineTransparency&&void 0,this.weight=y.weight,this.linePixels=y.linePixels,this.ignoresMaterial=y.ignoresMaterial,this.nonLocatable=y.nonLocatable,this.emphasized=y.emphasized,void 0!==this.weight&&(this.weight=Math.max(1,Math.min(this.weight,32))),!y.viewDependentTransparency||void 0===this.transparency&&void 0===this.getLineTransparency()||(this.viewDependentTransparency=!0)}}Ao.defaults=new Ao({});const Zo={elementId:{lower:0,upper:0},animationNodeId:0};class So{ignoreAnimationOverrides(y){this._ignoreAnimationOverrides.push(y)}get defaultOverrides(){return this._defaultOverrides}get lineWeights(){return this._lineWeights}get neverDrawn(){return this._neverDrawn}get alwaysDrawn(){return this._alwaysDrawn}isNeverDrawn(y,k,M){return!!this._neverDrawn.has(y,k)||this.neverDrawnAnimationNodes.has(M)}isAlwaysDrawn(y,k){return this._alwaysDrawn.has(y,k)}isSubCategoryVisible(y,k){return this._visibleSubCategories.has(y,k)}isSubCategoryVisibleInModel(y,k,M,b){if(this.ignoreSubCategory)return!0;let E=this.isSubCategoryVisible(y,k);const D=this._modelSubCategoryOverrides.get(M,b);return void 0!==D&&D.has(y,k)&&(E=!E),E}getModelOverrides(y,k){return this._modelOverrides.get(y,k)}getElementAnimationOverrides(y,k,M){if(0===this.animationNodeOverrides.size)return;const b=this.animationNodeOverrides.get(M);if(!b||0===M||0===this._ignoreAnimationOverrides.length)return b;const E=Zo;return E.elementId.lower=y,E.elementId.upper=k,E.animationNodeId=M,this._ignoreAnimationOverrides.some((y=>y(E)))?void 0:b}getElementOverrides(y,k,M){const b=this._elementOverrides.get(y,k),E=this.getElementAnimationOverrides(y,k,M);return b?E?E.extendAppearance(b):b:E}getSubCategoryOverrides(y,k){return this._subCategoryOverrides.get(y,k)}setVisibleSubCategory(y){this._visibleSubCategories.addId(y)}setNeverDrawn(y){this._neverDrawn.addId(y)}setAlwaysDrawn(y){this._alwaysDrawn.addId(y)}setAnimationNodeNeverDrawn(y){this.neverDrawnAnimationNodes.add(y)}setNeverDrawnSet(y){_o(this._neverDrawn,y)}setAlwaysDrawnSet(y,k,M=!0){_o(this._alwaysDrawn,y),this.isAlwaysDrawnExclusive=k,this.alwaysDrawnIgnoresSubCategory=M}getFeatureAppearance(k,M,b=Uo.Primary,E=0){return this.getAppearance(y.getLowerUint32(k.elementId),y.getUpperUint32(k.elementId),y.getLowerUint32(k.subCategoryId),y.getUpperUint32(k.subCategoryId),k.geometryClass,y.getLowerUint32(M),y.getUpperUint32(M),b,E)}getAppearance(k,M,b,E,D,R,X,z,N){if(Uo.VolumeClassifier===z||Uo.PlanarClassifier===z)return this.getClassifierAppearance(k,M,b,E,R,X,N);let Y=this._lineWeights?Ao.defaults:So._weight1Appearance;const O=this.getModelOverrides(R,X);void 0!==O&&(Y=O.extendAppearance(Y));let B,V,U=!1;if(y.isValidUint32Pair(k,M)){if(this.isNeverDrawn(k,M,N))return;if(U=this.isAlwaysDrawn(k,M),!U&&this.isAlwaysDrawnExclusive)return;B=this.getElementOverrides(k,M,N),void 0!==B&&(Y=void 0!==O?B.extendAppearance(Y):B)}if(!this.ignoreSubCategory&&y.isValidUint32Pair(b,E)){if(!(U&&this.alwaysDrawnIgnoresSubCategory||this.isSubCategoryVisibleInModel(b,E,R,X)))return;V=this.getSubCategoryOverrides(b,E),void 0!==V&&(Y=V.extendAppearance(Y))}void 0===B&&void 0===O&&void 0===V&&(Y=this._defaultOverrides.extendAppearance(Y));let L=U||this.isClassVisible(D);return L&&Y.isFullyTransparent&&(L=!1),L?Y:void 0}getClassifierAppearance(k,M,b,E,D,R,X){let z=Ao.defaults;const N=this.getModelOverrides(D,R);void 0!==N&&(z=N.extendAppearance(z));const Y=this.getElementOverrides(k,M,X);if(void 0!==Y&&(z=void 0!==N?Y.extendAppearance(z):Y),!this.ignoreSubCategory&&y.isValidUint32Pair(b,E)){const y=this.getSubCategoryOverrides(b,E);void 0!==y&&(z=y.extendAppearance(z))}return void 0===Y&&void 0===N&&(z=this._defaultOverrides.extendAppearance(z)),z}isClassVisible(y){switch(y){case Oo.Construction:return this._constructions;case Oo.Dimension:return this._dimensions;case Oo.Pattern:return this._patterns;default:return!0}}override(k){let M,b;void 0!==k.elementId?(M=k.elementId,b=this._elementOverrides):void 0!==k.modelId?(M=k.modelId,b=this._modelOverrides):(M=k.subCategoryId,b=this._subCategoryOverrides);let E=k.appearance;const D=y.getLowerUint32(M),R=y.getUpperUint32(M);if(void 0!==k.elementId&&this.isNeverDrawn(D,R,0))return;const X="replace"===k.onConflict?void 0:b.get(D,R);if(X)switch(e(k.onConflict),k.onConflict){case"skip":return;case"extend":E=E.extendAppearance(X);break;default:E=X.extendAppearance(E)}b.set(D,R,E)}overrideModel(y,k,M=!0){this.override({modelId:y,appearance:k,onConflict:M?"replace":"skip"})}overrideSubCategory(y,k,M=!0){this.override({subCategoryId:y,appearance:k,onConflict:M?"replace":"skip"})}overrideElement(y,k,M=!0){this.override({elementId:y,appearance:k,onConflict:M?"replace":"skip"})}overrideAnimationNode(y,k){this.animationNodeOverrides.set(y,k)}setDefaultOverrides(y,k=!0){!k&&y.overridesSymbology||(this._defaultOverrides=y)}getSubCategoryPriority(y,k){return this._subCategoryPriorities.get(y,k)??0}addInvisibleElementOverridesToNeverDrawn(){this._elementOverrides.forEach(((y,k)=>{const M=this.getElementOverrides(y,k,0);M?.isFullyTransparent&&this._neverDrawn.add(y,k)}))}constructor(){this._ignoreAnimationOverrides=[],this._neverDrawn=new y.Uint32Set,this._alwaysDrawn=new y.Uint32Set,this.isAlwaysDrawnExclusive=!1,this.alwaysDrawnIgnoresSubCategory=!0,this.ignoreSubCategory=!1,this._defaultOverrides=Ao.defaults,this._constructions=!1,this._dimensions=!1,this._patterns=!1,this._lineWeights=!0,this._modelOverrides=new y.Uint32Map,this._elementOverrides=new y.Uint32Map,this._subCategoryOverrides=new y.Uint32Map,this._visibleSubCategories=new y.Uint32Set,this._subCategoryPriorities=new y.Uint32Map,this._modelSubCategoryOverrides=new y.Uint32Map,this.neverDrawnAnimationNodes=new Set,this.animationNodeOverrides=new Map}isSubCategoryIdVisible(k){return this.isSubCategoryVisible(y.getLowerUint32(k),y.getUpperUint32(k))}getModelOverridesById(k){return this.getModelOverrides(y.getLowerUint32(k),y.getUpperUint32(k))}getElementOverridesById(k){return this.getElementOverrides(y.getLowerUint32(k),y.getUpperUint32(k),0)}getSubCategoryOverridesById(k){return this.getSubCategoryOverrides(y.getLowerUint32(k),y.getUpperUint32(k))}isFeatureVisible(k){const{elementId:M,subCategoryId:b,geometryClass:E}=k,D=y.isInvalid(M)?void 0:y.getUint32Pair(M);if(void 0!==D&&this.isNeverDrawn(D.lower,D.upper,0))return!1;const R=void 0!==D&&this.isAlwaysDrawn(D.lower,D.upper);return R||this.isAlwaysDrawnExclusive?R:!!this.isSubCategoryIdVisible(b)&&this.isClassVisible(E)}}var Wo;function Co(y,k,M){return y+M*(k-y)}function To(y,k){return i(y.x,k.x)||i(y.y,k.y)||i(y.z,k.z)}So._weight1Appearance=Ao.fromJSON({weight:1}),function(y){y.supplement=function(y){return{getFeatureAppearance:(k,M,b,E,D,R,X,z,N,Y)=>{const O=k.getAppearance(M,b,E,D,R,X,z,N,Y);return O?y(O):O}}},y.chain=function(y,k){return y===k?y:{getFeatureAppearance:(M,b,E,D,R,X,z,N,Y,O)=>k.getFeatureAppearance(function(y,k){return{getAppearance:(M,b,E,D,R,X,z,N,Y)=>k.getFeatureAppearance(y,M,b,E,D,R,X,z,N,Y)}}(M,y),b,E,D,R,X,z,N,Y,O)}}}(Wo||(Wo={}));const qo=new $,jo=new $;function Mo(y,k){return i(y.low,k.low)||i(y.high,k.high)}var Go,Ho,$o,Jo,Ko,ta,ea,ia,Pa,ja,Ka,ec,uc,fc,gc,pc,mc,xc,_c,yc,vc,Pc,Ac,Ic,Sc,wc;function sa(y,k){k&&y.add(k.buffer)}function na(y,k){if("pattern"!==k.type)switch(sa(y,k.params.vertices.data),"instances"===k.modifier?.type&&(sa(y,k.modifier.transforms),sa(y,k.modifier.featureIds),sa(y,k.modifier.symbologyOverrides)),k.type){case"point":sa(y,k.params.indices);break;case"polyline":sa(y,k.params.polyline.indices),sa(y,k.params.polyline.prevIndices),sa(y,k.params.polyline.nextIndicesAndParams);break;case"mesh":sa(y,k.params.surface.indices);const M=k.params.edges;M&&(sa(y,M.segments?.indices),sa(y,M.segments?.endPointAndQuadIndices),sa(y,M.silhouettes?.indices),sa(y,M.silhouettes?.endPointAndQuadIndices),sa(y,M.silhouettes?.normalPairs),sa(y,M.polylines?.indices),sa(y,M.polylines?.prevIndices),sa(y,M.polylines?.nextIndicesAndParams),sa(y,M.indexed?.indices),sa(y,M.indexed?.edges.data))}else sa(y,k.params.xyOffsets)}function ra(y){const k=new Set,i=y=>{y&&k.add(y.buffer)};i(y.binaryData),i(y.featureTable.data),i(y.featureTable.animationNodeIds);for(const M of y.nodes)if(void 0!==M.groupId)for(const y of M.nodes)for(const M of y.primitives)na(k,M);else for(const y of M.primitives)na(k,y);for(const M of y.patterns.values())for(const y of M)na(k,y);return Array.from(k)}!function(k){let E;!function(y){y[y.Step=1]="Step",y[y.Linear=2]="Linear"}(E=k.Interpolation||(k.Interpolation={}));class a{constructor(y){this.time=y.time,this.interpolation=y.interpolation===E.Linear?y.interpolation:E.Step}toJSON(){const y={time:this.time};return this.interpolation===E.Linear&&(y.interpolation=this.interpolation),y}compareTo(y){return i(this.interpolation,y.interpolation)||i(this.time,y.time)}equals(y){return 0===this.compareTo(y)}}k.TimelineEntry=a;class c extends a{constructor(y){super(y),"number"!=typeof y.value?this.value=100:this.value=Math.max(0,Math.min(100,y.value))}toJSON(){const y=super.toJSON();return 100!==this.value&&(y.value=this.value),y}compareTo(y){return e(),super.compareTo(y)||i(this.value,y.value)}}k.VisibilityEntry=c;class l extends a{constructor(y){super(y),y.value&&(this.value=new to(y.value.red,y.value.green,y.value.blue))}toJSON(){const y=super.toJSON();return this.value&&(y.value={red:this.value.r,green:this.value.g,blue:this.value.b}),y}compareTo(y){return e(),super.compareTo(y)||r(((y,k)=>y.compareTo(k)),this.value,y.value)}}k.ColorEntry=l;class d{constructor(y,k,M){this.position=y,this.pivot=k,this.orientation=M}static fromJSON(y){return y.pivot&&y.position&&y.orientation?new d($.fromJSON(y.position),$.fromJSON(y.pivot),Dt.fromJSON(y.orientation)):void 0}toJSON(){return{position:[this.position.x,this.position.y,this.position.z],pivot:[this.pivot.x,this.pivot.y,this.pivot.z],orientation:[this.orientation.x,this.orientation.y,this.orientation.z,this.orientation.w]}}compareTo(y){return To(this.pivot,y.pivot)||To(this.position,y.position)||(k=this.orientation,M=y.orientation,i(k.x,M.x)||i(k.y,M.y)||i(k.z,M.z)||i(k.w,M.w));var k,M}equals(y){return this.pivot.isAlmostEqual(y.pivot)&&this.position.isAlmostEqual(y.position)&&this.orientation.isAlmostEqual(y.orientation)}}k.TransformComponents=d;class g extends a{constructor(y){super(y),this.value=y.value?pt.fromJSON(y.value.transform):pt.identity,y.value&&(this.components=d.fromJSON(y.value))}toJSON(){const y=super.toJSON();return this.components?(y.value=this.components.toJSON(),y.value.transform=this.value.toRows()):y.value={transform:this.value.toRows()},y}compareTo(y){e();const k=super.compareTo(y);return 0!==k?k:this.components||y.components?this.components&&y.components?this.components.compareTo(y.components):this.components?1:-1:To(this.value.origin,y.value.origin)||(M=this.value.matrix,b=y.value.matrix,To(M.columnX(qo),b.columnX(jo))||To(M.columnY(qo),b.columnY(jo))||To(M.columnZ(qo),b.columnZ(jo)));var M,b}}k.TransformEntry=g;class p{constructor(y){this.position=j.fromJSON(y.position),this.direction=j.fromJSON(y.direction),this.hidden=!0===y.hidden,this.visible=!0===y.visible}toJSON(){const y={position:[this.position.x,this.position.y,this.position.z],direction:[this.direction.x,this.direction.y,this.direction.z]};return this.visible&&(y.visible=!0),this.hidden&&(y.hidden=!0),y}compareTo(y){return To(this.position,y.position)||To(this.direction,y.direction)||s(this.visible,y.visible)||s(this.hidden,y.hidden)}equals(y){return 0===this.compareTo(y)}}k.CuttingPlane=p;class m extends a{constructor(y){super(y),y.value&&(this.value=new p(y.value))}toJSON(){const y=super.toJSON();return this.value&&(y.value=this.value.toJSON()),y}compareTo(y){return e(),super.compareTo(y)||r(((y,k)=>y.compareTo(k)),this.value,y.value)}}k.CuttingPlaneEntry=m;class x{constructor(y=0,k=0,M=0){this.init(y,k,M)}init(y=0,k=0,M=0){this.lowerIndex=y,this.upperIndex=k,this.fraction=M}}k.Interval=x;class _{constructor(y,k){this.duration=ft.createNull(),this._entries=y.map((y=>{const M=new k(y);return this.duration.extendX(M.time),M}))}get length(){return this._entries.length}[Symbol.iterator](){return this._entries[Symbol.iterator]()}getEntry(y){return this._entries[y]}getValue(y){return this.getEntry(y)?.value}toJSON(){return this._entries.map((y=>y.toJSON()))}compareTo(y){let k=i(this._entries.length,y._entries.length)||Mo(this.duration,y.duration);if(0===k)for(let M=0;M<this.length&&0===(k=this._entries[M].compareTo(y._entries[M]));M++);return k}equals(y){return 0===this.compareTo(y)}findInterval(y,k){if(0===this.length)return;if(k=k??new x,y<this._entries[0].time)return k.init(0,0,0),k;const M=this.length-1;if(y>=this._entries[M].time)return k.init(M,M,0),k;for(let b=0;b<M;b++){const M=this._entries[b].time,D=this._entries[b+1].time;if(M<=y&&D>=y){let R;return R=E.Linear===this._entries[b].interpolation?(y-M)/(D-M):0,k.init(b,b+1,R),k}}}}k.TimelineEntryList=_;const D=new x;class v extends _{getValue(y){return super.getValue(y)??100}}k.VisibilityTimelineEntries=v;class P extends _{getValue(y){return super.getValue(y)??pt.identity}}k.TransformTimelineEntries=P;class A{constructor(y){this.duration=ft.createNull(),y.visibilityTimeline&&(this.visibility=new v(y.visibilityTimeline,c),this.duration.extendRange(this.visibility.duration)),y.colorTimeline&&(this.color=new _(y.colorTimeline,l),this.duration.extendRange(this.color.duration)),y.transformTimeline&&(this.transform=new P(y.transformTimeline,g),this.duration.extendRange(this.transform.duration)),y.cuttingPlaneTimeline&&(this.cuttingPlane=new _(y.cuttingPlaneTimeline,m),this.duration.extendRange(this.cuttingPlane.duration))}toJSON(){return{visibilityTimeline:this.visibility?.toJSON(),colorTimeline:this.color?.toJSON(),transformTimeline:this.transform?.toJSON(),cuttingPlaneTimeline:this.cuttingPlane?.toJSON()}}compareTo(y){const k=Mo(this.duration,y.duration);return 0!==k?k:!!this.visibility!=!!y.visibility?this.visibility?1:-1:!!this.color!=!!y.color?this.color?1:-1:!!this.transform!=!!y.transform?this.transform?1:-1:!!this.cuttingPlane!=!!y.cuttingPlane?this.cuttingPlane?1:-1:r(((y,k)=>y.compareTo(k)),this.visibility,y.visibility)||r(((y,k)=>y.compareTo(k)),this.color,y.color)||r(((y,k)=>y.compareTo(k)),this.transform,y.transform)||r(((y,k)=>y.compareTo(k)),this.cuttingPlane,y.cuttingPlane)}equals(y){return 0===this.compareTo(y)}getVisibility(y){let k;if(!this.visibility||!(k=this.visibility.findInterval(y,D)))return 100;let M=this.visibility.getValue(k.lowerIndex)??100;return k.fraction>0&&(M=Co(M,this.visibility.getValue(k.upperIndex)??100,k.fraction)),M}getColor(y){let k;if(!this.color||!(k=this.color.findInterval(y,D)))return;const M=this.color.getValue(k.lowerIndex);if(M&&k.fraction>0){const y=this.color.getValue(k.upperIndex);if(y)return function(y,k,M){return new to(Co(y.r,k.r,M),Co(y.g,k.g,M),Co(y.b,k.b,M))}(M,y,k.fraction)}return M}getAnimationTransform(y){let k;if(!this.transform||!(k=this.transform.findInterval(y,D)))return pt.identity;let M=this.transform.getValue(k.lowerIndex);if(k.fraction>0){const y=this.transform.getEntry(k.lowerIndex)?.components,b=this.transform.getEntry(k.upperIndex)?.components;if(y&&b){const E=Dt.interpolateQuaternions(y.orientation,k.fraction,b.orientation),D=xt.createFromQuaternion(E),R=pt.createTranslation(y.pivot),X=pt.createTranslation(y.position.interpolate(k.fraction,b.position)).multiplyTransformMatrix3d(D);X.multiplyTransformTransform(R,X),M=X}else{const y=this.transform.getValue(k.upperIndex),b=M.matrix.inverse()?.toQuaternion(),E=y.matrix.inverse()?.toQuaternion();if(b&&E){const D=Dt.interpolateQuaternions(b,k.fraction,E),R=xt.createFromQuaternion(D),X=$.createFrom(M.origin),z=$.createFrom(y.origin);M=pt.createRefs(X.interpolate(k.fraction,z),R)}}}return M}getCuttingPlane(y){let k;if(!this.cuttingPlane||!(k=this.cuttingPlane.findInterval(y,D)))return;const M=this.cuttingPlane.getValue(k.lowerIndex);if(!M)return;const b=j.createFrom(M.position),E=$.createFrom(M.direction),R=k.fraction>0?this.cuttingPlane.getValue(k.upperIndex):void 0;if(R)b.interpolate(k.fraction,R.position,b),E.interpolate(k.fraction,R.direction,E);else if(M.hidden||M.visible)return;return E.negate(E),E.normalizeInPlace(),_t.create(b,E)}getClipVector(y){const k=this.getCuttingPlane(y);if(!k)return;const M=Wr.createPlane(k),b=vs.createConvexSets([kn.createPlanes([M])]),E=Cs.createCapture(b);return bs.createCapture([E])}getFeatureAppearance(y,k){const M=y<100?1-y/100:void 0,b=this.getColor(k);return void 0!==b||void 0!==M?Ao.fromJSON({rgb:b,transparency:M}):void 0}}k.Timeline=A;class I extends A{constructor(y){super(y),this.batchId=y.batchId,this._elementIds=y.elementIds}static fromJSON(y){return new I(y??{elementIds:[],batchId:0})}toJSON(){return{...super.toJSON(),batchId:this.batchId,elementIds:this._elementIds}}get containsElementIds(){return this._elementIds.length>0}compareElementIds(y){if(typeof this._elementIds==typeof y._elementIds){const k=i(this._elementIds.length,y._elementIds.length);if(0!==k)return k;if("string"==typeof this._elementIds)return e(y._elementIds),n(this._elementIds,y._elementIds)}const k=this.elementIds[Symbol.iterator](),M=y.elementIds[Symbol.iterator]();for(;;){const y=k.next(),b=M.next();if(y.done!==b.done)return s(!!y.done,!!b.done);if(y.done)return 0;const E=n(y.value,b.value);if(0!==E)return E}}compareTo(y){return e(),i(this.batchId,y.batchId)||this.compareElementIds(y)||super.compareTo(y)}static getElementIds(y){return"string"==typeof y?b.iterable(y):Array.isArray(y)?y:[]}get elementIds(){return I.getElementIds(this._elementIds)}get containsFeatureOverrides(){return void 0!==this.visibility||void 0!==this.color}get requiresBatching(){return!!this.cuttingPlane||0!==this.batchId&&(void 0!==this.color||void 0!==this.visibility)}get containsTransform(){return void 0!==this.transform}addSymbologyOverrides(y,k){e(this.batchId);const M=this.getVisibility(k);if(M<=0)return void y.setAnimationNodeNeverDrawn(this.batchId);const b=this.getFeatureAppearance(M,k);b&&y.overrideAnimationNode(this.batchId,b)}}k.ElementTimeline=I;class S extends A{constructor(y){super(y),this._cachedComparisons=new WeakMap,this.modelId=y.modelId,this.realityModelUrl=y.realityModelUrl,this.containsModelClipping=void 0!==this.cuttingPlane;let k=void 0!==this.visibility||void 0!==this.color,M=!1,b=!1;const E=[],D=[];let R=!1;for(const X of y.elementTimelines){const y=I.fromJSON(X);D.push(y),this.duration.extendRange(y.duration),y.containsTransform&&(b=!0,y.batchId&&E.push(y.batchId)),k||=y.containsFeatureOverrides,M||=y.requiresBatching,R=R||y.containsElementIds}this.elementTimelines=D,this.transformBatchIds=E,this.omitsElementIds=D.length>0&&!R,this.containsFeatureOverrides=k,this.requiresBatching=M,this.containsTransform=b}static fromJSON(k){return new S(k??{elementTimelines:[],modelId:y.invalid})}toJSON(){return{...super.toJSON(),modelId:this.modelId,realityModelUrl:this.realityModelUrl,elementTimelines:this.elementTimelines.map((y=>y.toJSON()))}}compareTo(y){if(this===y)return 0;const k=this._cachedComparisons.get(y);if(void 0!==k)return k;e();let M=n(this.modelId,y.modelId)||r(n,this.realityModelUrl,y.realityModelUrl)||i(this.elementTimelines.length,y.elementTimelines.length)||s(this.containsFeatureOverrides,y.containsFeatureOverrides)||s(this.containsModelClipping,y.containsModelClipping)||s(this.containsTransform,y.containsTransform)||super.compareTo(y);if(0===M)for(let b=0;b<this.elementTimelines.length&&0===(M=this.elementTimelines[b].compareTo(y.elementTimelines[b]));b++);return this._cachedComparisons.set(y,M),y._cachedComparisons.set(this,-M),M}findByBatchId(y){return this.elementTimelines.find((k=>k.batchId===y))}addSymbologyOverrides(y,k){const M=this.getFeatureAppearance(this.getVisibility(k),k);M&&y.override({modelId:this.modelId,appearance:M});for(const b of this.elementTimelines)b.addSymbologyOverrides(y,k)}getTransform(y,k){return this.findByBatchId(y)?.getAnimationTransform(k)}get maxBatchId(){if(void 0===this._maxBatchId){this._maxBatchId=0;for(const y of this.elementTimelines)this._maxBatchId=Math.max(this._maxBatchId,y.batchId)}return this._maxBatchId}getTimelineForElement(k,M){if(!this._idPairToElementTimeline){this._idPairToElementTimeline=new y.Uint32Map;for(const y of this.elementTimelines)for(const k of y.elementIds)this._idPairToElementTimeline.setById(k,y)}return this._idPairToElementTimeline.get(k,M)}get discreteBatchIds(){if(!this._discreteBatchIds){this._discreteBatchIds=new Set(this.transformBatchIds);for(const y of this.elementTimelines)y.containsTransform||void 0===y.cuttingPlane||this._discreteBatchIds.add(y.batchId)}return this._discreteBatchIds}getBatchIdForFeature(k){e((y.fromUint32PairObject(k.modelId),this.modelId));const M=this.getTimelineForElement(k.elementId.lower,k.elementId.upper);return M?.batchId??0}}k.ModelTimeline=S;class w{compareTo(y){if(this===y)return 0;const k=this._cachedComparisons.get(y);if(void 0!==k)return k;let M=i(this.modelTimelines.length,y.modelTimelines.length)||s(this.containsModelClipping,y.containsModelClipping)||s(this.requiresBatching,y.requiresBatching)||s(this.containsTransform,y.containsTransform)||s(this.containsFeatureOverrides,y.containsFeatureOverrides)||Mo(this.duration,y.duration);if(0===M)for(let b=0;b<this.modelTimelines.length&&0===(M=this.modelTimelines[b].compareTo(y.modelTimelines[b]));b++);return this._cachedComparisons.set(y,M),y._cachedComparisons.set(this,-M),M}equals(y){return 0===this.compareTo(y)}constructor(y){this._cachedComparisons=new WeakMap,this.duration=ft.createNull();const k=new Set,M=[];let b=!1,E=!1,D=!1,R=!1;for(const X of y){const y=S.fromJSON(X);M.push(y),this.duration.extendRange(y.duration),b||=y.containsModelClipping,E||=y.requiresBatching,D||=y.containsTransform,R||=y.containsFeatureOverrides;for(const M of y.transformBatchIds)k.add(M)}this.modelTimelines=M,this.containsModelClipping=b,this.containsTransform=D,this.requiresBatching=E||this.containsTransform,this.containsFeatureOverrides=R,this.transformBatchIds=k}static fromJSON(y){if(Array.isArray(y)&&0!==y.length)return new w(y)}toJSON(){return this.modelTimelines.map((y=>y.toJSON()))}find(y){return this.modelTimelines.find((k=>k.modelId===y))}getTransformBatchIds(y){return this.find(y)?.transformBatchIds}getTransform(y,k,M){return this.find(y)?.getTransform(k,M)}addSymbologyOverrides(y,k){for(const M of this.modelTimelines)M.addSymbologyOverrides(y,k)}discloseIds(y){for(const k of this.modelTimelines){y.addModel(k.modelId);for(const M of k.elementTimelines)for(const k of M.elementIds)y.addElement(k)}}modelRequiresBatching(y){return this.requiresBatching&&this.modelTimelines.some((k=>k.modelId===y&&k.requiresBatching))}get discreteBatchIds(){if(this._discreteBatchIds)return this._discreteBatchIds;this._discreteBatchIds=new Set;for(const y of this.modelTimelines)for(const k of y.discreteBatchIds)this._discreteBatchIds.add(k);return this._discreteBatchIds}getBatchIdForFeature(k){let M;const b=this._lastFeatureModelTimeline;if(b&&b.idLower===k.modelId.lower&&b.idUpper===k.modelId.upper)M=b.timeline;else{const b=y.fromUint32PairObject(k.modelId);M=this.find(b),this._lastFeatureModelTimeline={timeline:M,idLower:k.modelId.lower,idUpper:k.modelId.upper}}return M?.getBatchIdForFeature(k)??0}get maxBatchId(){return this._maxBatchId??(this._maxBatchId=this.modelTimelines.reduce(((y,k)=>Math.max(y,k.maxBatchId)),0))}}k.Script=w,k.ScriptReference=class{constructor(k,M){"string"==typeof k?(e(),this.sourceId=k,this.script=M):(e(),this.script=k,this.sourceId=y.invalid)}};class C{addVisibility(y,k,M=E.Linear){this.visibility||(this.visibility=[]),this.visibility.push({time:y,value:k,interpolation:M})}addColor(y,k,M=E.Linear){this.color||(this.color=[]);const b=k instanceof to?{red:k.r,green:k.g,blue:k.b}:k;this.color.push({time:y,value:b,interpolation:M})}addCuttingPlane(y,k,M=E.Linear){let b;this.cuttingPlane||(this.cuttingPlane=[]),k&&(b={position:[k.position.x,k.position.y,k.position.z],direction:[k.direction.x,k.direction.y,k.direction.z]},k.visible&&(b.visible=!0),k.hidden&&(b.hidden=!0)),this.cuttingPlane.push({time:y,value:b,interpolation:M})}addTransform(y,k,M,b=E.Linear){this.transform||(this.transform=[]);const D={transform:k?.toRows()};M&&(D.pivot=[M.pivot.x,M.pivot.y,M.pivot.z],D.orientation=M.orientation.toJSON(),D.position=[M.position.x,M.position.y,M.position.z]),this.transform.push({time:y,value:D,interpolation:b})}finish(){const y={};return this.visibility?.length&&(y.visibilityTimeline=this.visibility),this.color?.length&&(y.colorTimeline=this.color),this.transform?.length&&(y.transformTimeline=this.transform),this.cuttingPlane?.length&&(y.cuttingPlaneTimeline=this.cuttingPlane),y}}k.TimelineBuilder=C;class T extends C{constructor(y,k){super(),this.batchId=y,this.elementIds=k}finish(){const y=super.finish();return y.batchId=this.batchId,y.elementIds=this.elementIds,y}}k.ElementTimelineBuilder=T;class F extends C{constructor(y,k){super(),this._elements=[],this.modelId=y,this._obtainNextBatchId=k}addElementTimeline(k){const E=this._obtainNextBatchId();let D;if("string"==typeof k&&y.isValidId64(k)&&(k=[k]),"string"==typeof k)D=k;else{const y=Array.from(k);M.sortArray(y),D=b.compressIds(y)}const R=new T(E,D);return this._elements.push(R),R}finish(){const y=super.finish();return y.modelId=this.modelId,void 0!==this.realityModelUrl&&(y.realityModelUrl=this.realityModelUrl),y.elementTimelines=this._elements.map((y=>y.finish())),y}}k.ModelTimelineBuilder=F,k.ScriptBuilder=class{constructor(){this._nextBatchId=1,this._models=[]}addModelTimeline(y){const k=new F(y,(()=>this._nextBatchId++));return this._models.push(k),k}finish(){return this._models.map((y=>y.finish()))}}}(Go||(Go={})),function(y){function e(y){return"object"==typeof y&&0===Object.keys(y).length}function i(y){return void 0===y||e(y)}function s(y){return null==y}y.asBool=function(y,k=!1){return s(y)?k:!!y},y.asInt=function(y,k=0){return"number"==typeof y?Math.trunc(y):k},y.asDouble=function(y,k=0){return"number"==typeof y?y:k},y.asString=function(y,k=""){return s(y)?k:y.toString()},y.asArray=function(y){return Array.isArray(y)?y:void 0},y.asObject=function(y){return"object"==typeof y?y:void 0},y.setOrRemoveNumber=function(y,k,M,b){M===b?delete y[k]:y[k]=M},y.setOrRemoveBoolean=function(y,k,M,b){M===b?delete y[k]:y[k]=M},y.isEmptyObject=e,y.isEmptyObjectOrUndefined=i,y.isNonEmptyObject=function(y){return!i(y)},y.toObject=function t(y){if("boolean"==typeof y||"number"==typeof y||"string"==typeof y)return y;if("object"!=typeof y)return;if(void 0!==y.toJSON)return t(y.toJSON());if(Array.isArray(y)){const k=new Array(y.length);return y.forEach(((y,M)=>k[M]=t(y))),k}const k={};return Object.getOwnPropertyNames(y).forEach((M=>{const b=t(y[M]);void 0!==b&&(k[M]=b)})),k}}(Ho||(Ho={}));class oa{constructor(y,k){this._curPos=0,void 0!==k?(this._view=new DataView(y,k.byteOffset,k.byteLength),this._byteOffset=k.byteOffset):(this._view=new DataView(y),this._byteOffset=0)}static fromUint8Array(y){const{byteOffset:k,byteLength:M}=y;return new oa(y.buffer,{byteOffset:k,byteLength:M})}static fromArrayBuffer(y,k){return new oa(y,k)}get length(){return this._view.byteLength}get remainingLength(){return this.length-this.curPos}get isPastTheEnd(){return this.curPos>this.length}get isAtTheEnd(){return this.curPos===this.length}get curPos(){return this._curPos}set curPos(y){this._curPos=y,e(this.isPastTheEnd)}advance(y){return this.curPos=this.curPos+y,!this.isPastTheEnd}rewind(y){return!(this.curPos-y<0||(this.curPos=this.curPos-y,0))}reset(){this.curPos=0}readUint8(){return this.read(1,(y=>y.getUint8(this.curPos)))}readUint16(){return this.read(2,(y=>y.getUint16(this.curPos,!0)))}readUint32(){return this.read(4,(y=>y.getUint32(this.curPos,!0)))}readInt32(){return this.read(4,(y=>y.getInt32(this.curPos,!0)))}readFloat32(){return this.read(4,(y=>y.getFloat32(this.curPos,!0)))}readFloat64(){return this.read(8,(y=>y.getFloat64(this.curPos,!0)))}readId64(){return y.fromUint32Pair(this.readUint32(),this.readUint32())}readUint24(){return this.readUint8()|this.readUint8()<<8|this.readUint8()<<16}get nextUint8(){return this.readUint8()}get nextUint16(){return this.readUint16()}get nextUint32(){return this.readUint32()}get nextInt32(){return this.readInt32()}get nextFloat32(){return this.readFloat32()}get nextFloat64(){return this.readFloat64()}get nextId64(){return this.readId64()}get nextUint24(){return this.readUint24()}nextBytes(y){const k=new Uint8Array(this.arrayBuffer,this.curPos+this._byteOffset,y);return this.advance(y),k}readBytes(y,k){return new Uint8Array(this.arrayBuffer,y+this._byteOffset,k)}nextUint32s(y){const k=4*y,M=new Uint32Array(this.arrayBuffer,this.curPos+this._byteOffset,y);return this.advance(k),M}get arrayBuffer(){return this._view.buffer}read(y,k){const M=k(this._view);return this.advance(y),M}}(Ko=$o||($o={}))[Ko.Unknown=0]="Unknown",Ko[Ko.B3dm=1835283298]="B3dm",Ko[Ko.Gltf=1179937895]="Gltf",Ko[Ko.Pnts=1937010288]="Pnts",Ko[Ko.IModel=1818512745]="IModel",Ko[Ko.Cmpt=1953525091]="Cmpt",Ko[Ko.I3dm=1835283305]="I3dm",Ko[Ko.A3x=5780289]="A3x",function(y){y[y.Success=0]="Success",y[y.InvalidTileData=1]="InvalidTileData",y[y.InvalidHeader=2]="InvalidHeader",y[y.InvalidBatchTable=3]="InvalidBatchTable",y[y.InvalidScene=4]="InvalidScene",y[y.InvalidFeatureTable=5]="InvalidFeatureTable",y[y.NewerMajorVersion=6]="NewerMajorVersion",y[y.Canceled=7]="Canceled"}(Jo||(Jo={}));class aa{constructor(y){this._format=function(y){const k=y;return function(y){switch(y){case $o.Unknown:case $o.B3dm:case $o.Gltf:case $o.IModel:case $o.Pnts:case $o.Cmpt:case $o.I3dm:case $o.A3x:return!0;default:return!1}}(k)?k:$o.Unknown}(y.readUint32()),this.version=y.readUint32()}get format(){return this._format}invalidate(){this._format=$o.Unknown}}function ca(y,k){const M=y.readFloat64(),b=y.readFloat64(),E=y.readFloat64();return void 0===k?new j(M,b,E):(k.set(M,b,E),k)}!function(y){y[y.Version1=1]="Version1",y[y.Version2=2]="Version2",y[y.CurrentVersion=1]="CurrentVersion",y[y.Gltf1SceneFormat=0]="Gltf1SceneFormat"}(ta||(ta={})),function(y){y[y.JSON=1313821514]="JSON",y[y.Binary=5130562]="Binary"}(ea||(ea={}));class la{get isTileSection(){return la.Type.TileSection===this.type}get isGlyph(){return la.Type.Glyph===this.type}get isSkyBox(){return la.Type.SkyBox===this.type}constructor(y){this.type=y,this._guid=k.createValue()}compare(y){return n(this._guid,y._guid)}}!function(y){let k;!function(y){y[y.Normal=0]="Normal",y[y.Glyph=1]="Glyph",y[y.TileSection=2]="TileSection",y[y.SkyBox=3]="SkyBox",y[y.FilteredTileSection=4]="FilteredTileSection",y[y.ThematicGradient=5]="ThematicGradient"}(k=y.Type||(y.Type={})),y.Params=class{constructor(k,M=y.Type.Normal,b=!1){this.key=k,this.type=M,this.isOwned=b}get isTileSection(){return y.Type.TileSection===this.type}get isGlyph(){return y.Type.Glyph===this.type}get isSkyBox(){return y.Type.SkyBox===this.type}}}(la||(la={}));class ha{constructor(y){this.key=y.key,this.textureMapping=y.textureMapping,this._guid=k.createValue()}get hasTexture(){return void 0!==this.textureMapping?.texture}compare(y){return n(this._guid,y._guid)}}!function(y){class e{constructor(y){this.diffuse=.6,this.specular=.4,this.specularExponent=13.5,this.reflect=0,this.refract=1,this.ambient=.3,this.shadows=!0,this.key=y}get alpha(){return this._alpha}set alpha(y){var k;this._alpha=void 0!==y?(k=y,Math.max(0,Math.min(1,k))):void 0}static fromColors(y,k,M,b,E,D){const R=new e;return R.key=y,R.diffuseColor=k,R.specularColor=M,R.emissiveColor=b,R.reflectColor=E,R.textureMapping=D,R}}e.defaults=new e,y.Params=e}(ha||(ha={})),Object.freeze(ha.Params.defaults),function(y){function e(k,M=y.rangeScale16){return k>=0&&k<M+1}function i(k,M,b,E=y.rangeScale16){return Math.floor(Math.max(0,Math.min(E,.5+(k-M)*b)))}y.rangeScale16=65535,y.rangeScale8=255,y.computeScale=function(k,M=y.rangeScale16){return 0===k?k:M/k},y.isInRange=e,y.quantize=i,y.isQuantizable=function(k,M,b,E=y.rangeScale16){return e(i(k,M,b,E))},y.unquantize=function(y,k,M){return 0===M?k:k+y/M},y.isQuantized=function(y){return e(y)&&y===Math.floor(y)}}(ia||(ia={}));class da{constructor(y=0,k=0,M=0,b=0){this.origin=new H,this.scale=new H,this.setFrom(y,k,M,b)}setFrom(y,k,M,b){this.origin.x=y,this.origin.y=k,this.scale.x=M,this.scale.y=b}copyFrom(y){this.setFrom(y.origin.x,y.origin.y,y.scale.x,y.scale.y)}clone(y){const k=void 0!==y?y:new da;return k.copyFrom(this),k}setFromRange(y,k=ia.rangeScale16){y.isNull?this.origin.x=this.origin.y=this.scale.x=this.scale.y=0:this.setFrom(y.low.x,y.low.y,ia.computeScale(y.high.x-y.low.x,k),ia.computeScale(y.high.y-y.low.y,k))}static fromRange(y,k,M=ia.rangeScale16){const b=void 0!==k?k:new da;return b.setFromRange(y,M),b}unquantize(y,k,M){return(M=M??new H).x=ia.unquantize(y,this.origin.x,this.scale.x),M.y=ia.unquantize(k,this.origin.y,this.scale.y),M}static fromNormalizedRange(y=ia.rangeScale16){return da.fromRange(gt.createArray([H.create(-1,-1),H.create(1,1)]),void 0,y)}static fromZeroToOne(y=ia.rangeScale16){return da.fromRange(gt.createArray([H.create(0,0),H.create(1,1)]),void 0,y)}static fromOriginAndScale(y,k,M,b){return new da(y,k,M,b)}get rangeDiagonal(){return J.createFrom({x:0===this.scale.x?0:ia.rangeScale16/this.scale.x,y:0===this.scale.y?0:ia.rangeScale16/this.scale.y})}isQuantizable(y){return ia.isQuantizable(y.x,this.origin.x,this.scale.x)&&ia.isQuantizable(y.y,this.origin.y,this.scale.y)}toJSON(){return{origin:{x:this.origin.x,y:this.origin.y},scale:{x:this.scale.x,y:this.scale.y}}}static fromJSON(y){return this.fromOriginAndScale(y.origin.x,y.origin.y,y.scale.x,y.scale.y)}}class ua{get x(){return this._x}set x(y){e(ia.isQuantized(y)),this._x=y}get y(){return this._y}set y(y){e(ia.isQuantized(y)),this._y=y}constructor(){this._x=0,this._y=0}init(y,k){this.x=ia.quantize(y.x,k.origin.x,k.scale.x),this.y=ia.quantize(y.y,k.origin.y,k.scale.y)}static create(y,k){const M=new ua;return M.init(y,k),M}copyFrom(y){this.x=y.x,this.y=y.y}clone(y){const k=void 0!==y?y:new ua;return k.copyFrom(this),k}setFromScalars(y,k){this.x=y,this.y=k}static fromScalars(y,k){const M=new ua;return M.setFromScalars(y,k),M}unquantize(y,k){const M=void 0!==k?k:new H;return M.x=ia.unquantize(this.x,y.origin.x,y.scale.x),M.y=ia.unquantize(this.y,y.origin.y,y.scale.y),M}}!function(y){const k=new ua;function i(y,k,M){const b=2*k,E=y[b+0],D=y[b+1];if(void 0===E||void 0===D)throw new Error("Index out of range");return(M=M??new ua).setFromScalars(E,D),M}y.getQPoint=i,y.unquantizePoint=function(y,M,b){return i(y.points,M,k).unquantize(y.params,b)}}(Pa||(Pa={}));class fa{constructor(y=0,k=0,M=0,b=0,E=0,D=0){this.origin=new j,this.scale=new j,this.setFrom(y,k,M,b,E,D)}setFrom(y,k,M,b,E,D){this.origin.x=y,this.origin.y=k,this.origin.z=M,this.scale.x=b,this.scale.y=E,this.scale.z=D}copyFrom(y){this.setFrom(y.origin.x,y.origin.y,y.origin.z,y.scale.x,y.scale.y,y.scale.z)}clone(y){const k=void 0!==y?y:new fa;return k.copyFrom(this),k}setFromOriginAndScale(y,k){this.setFrom(y.x,y.y,y.z,k.x,k.y,k.z)}setFromRange(y,k=ia.rangeScale16){y.isNull?(this.origin.x=this.origin.y=this.origin.z=0,this.scale.x=this.scale.y=this.scale.z=0):this.setFrom(y.low.x,y.low.y,y.low.z,ia.computeScale(y.high.x-y.low.x,k),ia.computeScale(y.high.y-y.low.y,k),ia.computeScale(y.high.z-y.low.z,k))}unquantize(y,k,M,b){const E=void 0!==b?b:new j;return E.x=ia.unquantize(y,this.origin.x,this.scale.x),E.y=ia.unquantize(k,this.origin.y,this.scale.y),E.z=ia.unquantize(M,this.origin.z,this.scale.z),E}static fromRange(y,k,M=ia.rangeScale16){const b=void 0!==k?k:new fa;return b.setFromRange(y,M),b}static fromOriginAndScale(y,k,M){const b=void 0!==M?M:new fa;return b.setFromOriginAndScale(y,k),b}static fromNormalizedRange(y=ia.rangeScale16){return fa.fromRange(ut.createArray([j.create(-1,-1,-1),j.create(1,1,1)]),void 0,y)}static fromZeroToOne(y=ia.rangeScale16){return fa.fromRange(ut.createArray([j.create(0,0,0),j.create(1,1,1)]),void 0,y)}get rangeDiagonal(){return $.createFrom({x:0===this.scale.x?0:ia.rangeScale16/this.scale.x,y:0===this.scale.y?0:ia.rangeScale16/this.scale.y,z:0===this.scale.z?0:ia.rangeScale16/this.scale.z})}isQuantizable(y){return ia.isQuantizable(y.x,this.origin.x,this.scale.x)&&ia.isQuantizable(y.y,this.origin.y,this.scale.y)&&ia.isQuantizable(y.z,this.origin.z,this.scale.z)}computeRange(y){const k=ut.createNull(y);return k.extendPoint(this.origin),k.extendPoint(this.origin.plus(this.rangeDiagonal)),k}toJSON(){return{origin:{x:this.origin.x,y:this.origin.y,z:this.origin.z},scale:{x:this.scale.x,y:this.scale.y,z:this.scale.z}}}static fromJSON(y,k){return this.fromOriginAndScale(j.fromJSON(y.origin),j.fromJSON(y.scale),k)}}class ga{get x(){return this._x}set x(y){e(ia.isQuantized(y)),this._x=y}get y(){return this._y}set y(y){e(ia.isQuantized(y)),this._y=y}get z(){return this._z}set z(y){e(ia.isQuantized(y)),this._z=y}constructor(){this._x=0,this._y=0,this._z=0}init(y,k){this.x=ia.quantize(y.x,k.origin.x,k.scale.x),this.y=ia.quantize(y.y,k.origin.y,k.scale.y),this.z=ia.quantize(y.z,k.origin.z,k.scale.z)}static create(y,k){const M=new ga;return M.init(y,k),M}copyFrom(y){this.x=y.x,this.y=y.y,this.z=y.z}clone(y){const k=void 0!==y?y:new ga;return k.copyFrom(this),k}setFromScalars(y,k,M){this.x=y,this.y=k,this.z=M}static fromScalars(y,k,M,b){const E=void 0===b?new ga:b;return E.setFromScalars(y,k,M),E}unquantize(y,k){const M=void 0!==k?k:new j;return M.x=ia.unquantize(this.x,y.origin.x,y.scale.x),M.y=ia.unquantize(this.y,y.origin.y,y.scale.y),M.z=ia.unquantize(this.z,y.origin.z,y.scale.z),M}equals(y){return this.x===y.x&&this.y===y.y&&this.z===y.z}compare(y){let k=this.x-y.x;return 0===k&&(k=this.y-y.y,0===k&&(k=this.z-y.z)),k}}!function(y){const k=new ga;function i(y,k,M){const b=3*k,E=y[b+0],D=y[b+1],R=y[b+2];if(void 0===E||void 0===D||void 0===R)throw new Error("Index out of range");return(M=M??new ga).setFromScalars(E,D,R),M}y.getQPoint=i,y.unquantizePoint=function(y,M,b){return i(y.points,M,k).unquantize(y.params,b)}}(ja||(ja={})),Symbol.iterator,function(y){y[y.None=0]="None",y[y.ContainsCurves=1]="ContainsCurves",y[y.Incomplete=4]="Incomplete",y[y.DisallowMagnification=8]="DisallowMagnification",y[y.MultiModelFeatureTable=16]="MultiModelFeatureTable"}(Ka||(Ka={})),function(y){y[y.Major=35]="Major",y[y.Minor=0]="Minor",y[y.Combined=2293760]="Combined"}(ec||(ec={}));class pa extends aa{get versionMajor(){return this.version>>>16}get versionMinor(){return(65535&this.version)>>>0}get isValid(){return $o.IModel===this.format}get isReadableVersion(){return this.versionMajor<=ec.Major}constructor(y){super(y),this.headerLength=y.readUint32(),this.flags=y.readUint32(),this.contentRange=new ut,ca(y,this.contentRange.low),ca(y,this.contentRange.high),this.tolerance=y.readFloat64(),this.numElementsIncluded=y.readUint32(),this.numElementsExcluded=y.readUint32(),this.tileLength=y.readUint32(),this.emptySubRanges=this.versionMajor>=2?y.readUint32():0;const k=this.headerLength-y.curPos;e(),y.advance(k),y.isPastTheEnd&&this.invalidate()}}class ma{static readFrom(y){const k=y.readUint32(),M=y.readUint32(),b=y.readUint32();return y.isPastTheEnd?void 0:new ma(k,M,b)}constructor(y,k,M){this.length=y,this.numSubCategories=k,this.count=M}}ma.sizeInBytes=12,function(y){y[y.Normal=0]="Normal",y[y.Edge=1]="Edge",y[y.Outline=2]="Outline"}(uc||(uc={}));class xa{constructor(y,k){this.texture=y,this.params=k}computeUVParams(y,k){return this.params.computeUVParams(y,k)}compare(y){return this===y?0:this.texture.compare(y.texture)||this.params.compare(y.params)||r(((y,k)=>{return b=k,r(((y,k)=>y.compare(k)),(M=y).normalMap,b.normalMap)||o(M.greenUp,b.greenUp)||function(y,k){return r(i,y,k)}(M.scale,b.scale)||o(M.useConstantLod,b.useConstantLod);var M,b}),this.normalMapParams,y.normalMapParams)}}!function(y){let k;!function(y){y[y.None=-1]="None",y[y.Parametric=0]="Parametric",y[y.ElevationDrape=1]="ElevationDrape",y[y.Planar=2]="Planar",y[y.DirectionalDrape=3]="DirectionalDrape",y[y.Cubic=4]="Cubic",y[y.Spherical=5]="Spherical",y[y.Cylindrical=6]="Cylindrical",y[y.Solid=7]="Solid",y[y.FrontProject=8]="FrontProject"}(k=y.Mode||(y.Mode={}));class n{constructor(y=1,k=0,M=0,b=0,E=1,D=0){const R=new j(M,D,0),X=xt.createRowValues(y,k,0,b,E,0,0,0,1);this.transform=pt.createRefs(R,X)}compare(y){if(this===y)return 0;const k=i(this.transform.origin.x,y.transform.origin.x)||i(this.transform.origin.y,y.transform.origin.y);if(0!==k)return k;for(const M of[0,1,3,4]){const k=i(this.transform.matrix.coffs[M],y.transform.matrix.coffs[M]);if(0!==k)return k}return 0}}n.identity=new n,y.Trans2x3=n,y.Params=class{constructor(y){this.textureMatrix=y?.textureMat2x3??n.identity,this.weight=y?.textureWeight??1,this.mode=y?.mapMode??k.Parametric,this.worldMapping=y?.worldMapping??!1,this.useConstantLod=y?.useConstantLod??!1,this.constantLodParams={repetitions:y?.constantLodProps?.repetitions??1,offset:y?.constantLodProps?.offset??{x:0,y:0},minDistClamp:y?.constantLodProps?.minDistClamp??1,maxDistClamp:y?.constantLodProps?.maxDistClamp??4294967296}}compare(y){return this===y?0:i(this.weight,y.weight)||i(this.mode,y.mode)||s(this.worldMapping,y.worldMapping)||s(this.useConstantLod,y.useConstantLod)||this.textureMatrix.compare(y.textureMatrix)||(k=this.constantLodParams,M=y.constantLodParams,i(k.repetitions,M.repetitions)||i(k.offset.x,M.offset.x)||i(k.offset.y,M.offset.y)||i(k.minDistClamp,M.minDistClamp)||i(k.maxDistClamp,M.maxDistClamp));var k,M}computeUVParams(k,M){switch(this.mode){default:case y.Mode.Parametric:return this.computeParametricUVParams(k,this.textureMatrix.transform,!this.worldMapping);case y.Mode.Planar:{const y=k.normalIndex;if(!y)return;return this.worldMapping&&(void 0===k.normalIndex||y[0]===y[1]&&y[0]===y[2])?this.computePlanarUVParams(k,this.textureMatrix.transform):this.computeParametricUVParams(k,this.textureMatrix.transform,!this.worldMapping)}case y.Mode.ElevationDrape:return this.computeElevationDrapeUVParams(k,this.textureMatrix.transform,M)}}computeParametricUVParams(y,k,M){const b=[];for(let E=0;E<y.numEdgesThisFacet;E++){let D=H.create();!M&&y.tryGetDistanceParameter(E,D)||y.tryGetNormalizedParameter(E,D)||(D=y.getParam(E)),b.push(k.multiplyPoint2d(D))}return b}computePlanarUVParams(y,k){const M=[],b=y.point;let E;if(E=void 0===y.normal?b.getPoint3dAtUncheckedPointIndex(0).crossProductToPoints(b.getPoint3dAtUncheckedPointIndex(1),b.getPoint3dAtUncheckedPointIndex(2)):y.normal.getVector3dAtCheckedVectorIndex(0),!E.normalize(E))return;E.scale(-1,E);const D=$.create(E.y,-E.x,0),R=D.magnitude();D.normalize(D),R<.001&&(E.set(0,0,-1),D.set(1,0,0));const X=D.crossProduct(E).normalize();if(!X)return;const z=y.numEdgesThisFacet;for(let N=0;N<z;N++){const y=$.createFrom(b.getPoint3dAtUncheckedPointIndex(N));M.push(H.create(y.dotProduct(D),y.dotProduct(X))),k.multiplyPoint2d(M[N],M[N])}return M}computeElevationDrapeUVParams(y,k,M){const b=[],E=y.numEdgesThisFacet;for(let D=0;D<E;D++){const E=y.point.getPoint3dAtUncheckedPointIndex(D);void 0!==M&&M.multiplyPoint3d(E,E),b.push(H.createFrom(E)),k.multiplyPoint2d(b[D],b[D])}return b}}}(xa||(xa={})),Object.freeze(xa.Trans2x3.identity),(wc=fc||(fc={}))[wc.Solid=0]="Solid",wc[wc.Code0=0]="Code0",wc[wc.Code1=2155905152]="Code1",wc[wc.Code2=4177066232]="Code2",wc[wc.Code3=4292935648]="Code3",wc[wc.Code4=4262526480]="Code4",wc[wc.Code5=3772834016]="Code5",wc[wc.Code6=4169726088]="Code6",wc[wc.Code7=4279828248]="Code7",wc[wc.HiddenLine=3435973836]="HiddenLine",wc[wc.Invisible=1]="Invisible",wc[wc.Invalid=-1]="Invalid",function(y){y[y.None=0]="None",y[y.ByView=1]="ByView",y[y.Always=2]="Always",y[y.Behind=4]="Behind",y[y.Blanking=6]="Blanking",y[y.Background=8]="Background"}(gc||(gc={})),function(y){y[y.Rgba=0]="Rgba",y[y.Rgb=2]="Rgb",y[y.Alpha=5]="Alpha"}(pc||(pc={}));class _a{get numBytesPerPixel(){return _a.getNumBytesPerPixel(this.format)}static getNumBytesPerPixel(y){switch(y){case pc.Alpha:return 1;case pc.Rgb:return 3;default:return 4}}get height(){return _a.computeHeight(this.data,this.format,this.width)}static create(y,k,M){if(!this.isValidData(y,k,M))throw new Error("The number of bytes supplied for ImageBuffer do not match its width and format.");return new _a(y,k,M)}static isValidData(y,k,M){const b=this.computeHeight(y,k,M);return M>0&&b>0&&Math.floor(M)===M&&Math.floor(b)===b}static computeHeight(y,k,M){return y.length/(M*this.getNumBytesPerPixel(k))}constructor(y,k,M){this.data=y,this.format=k,this.width=M}}!function(y){y[y.Jpeg=0]="Jpeg",y[y.Png=2]="Png",y[y.Svg=3]="Svg"}(mc||(mc={})),function(y){y[y.Opaque=0]="Opaque",y[y.Translucent=1]="Translucent",y[y.Mixed=2]="Mixed"}(xc||(xc={})),function(y){y[y.Smooth=0]="Smooth",y[y.Stepped=1]="Stepped",y[y.SteppedWithDelimiter=2]="SteppedWithDelimiter",y[y.IsoLines=3]="IsoLines"}(_c||(_c={})),function(y){y[y.SurfaceOnly=0]="SurfaceOnly",y[y.MultiplySurfaceAndGradient=1]="MultiplySurfaceAndGradient"}(yc||(yc={})),function(y){y[y.BlueRed=0]="BlueRed",y[y.RedBlue=1]="RedBlue",y[y.Monochrome=2]="Monochrome",y[y.Topographic=3]="Topographic",y[y.SeaMountain=4]="SeaMountain",y[y.Custom=5]="Custom"}(vc||(vc={}));class ya{static get margin(){return.001}static get contentRange(){return 1-2*ya.margin}static get contentMax(){return 1-ya.margin}get textureTransparency(){let y=xc.Opaque;if(vc.Custom===this.colorScheme){let k=!1,M=!1;for(const y of this.customKeys){const b=y.color.isOpaque;k=k||b,M=M||!b}M&&(y=k?xc.Mixed:xc.Translucent)}return y!==xc.Mixed&&this.marginColor.isOpaque!==(y===xc.Opaque)&&(y=xc.Mixed),y}equals(y){return!(this.mode!==y.mode||this.stepCount!==y.stepCount||!this.marginColor.equals(y.marginColor)||this.colorScheme!==y.colorScheme||this.customKeys.length!==y.customKeys.length||this.colorMix!==y.colorMix||this.transparencyMode!==y.transparencyMode)&&this.customKeys.every(((k,M)=>Ac.keyColorEquals(k,y.customKeys[M])))}static compare(y,k){let M=0;if(0!==(M=i(y.mode,k.mode)))return M;if(0!==(M=i(y.stepCount,k.stepCount)))return M;if(0!==(M=i(y.marginColor.tbgr,k.marginColor.tbgr)))return M;if(0!==(M=i(y.colorScheme,k.colorScheme)))return M;if(0!==(M=i(y.colorMix,k.colorMix)))return M;if(0!==(M=i(y.customKeys.length,k.customKeys.length)))return M;if(0!==(M=i(y.transparencyMode,k.transparencyMode)))return M;for(let b=0;b<y.customKeys.length;b++)if(0!==(M=i(y.customKeys[b].color.tbgr,k.customKeys[b].color.tbgr)))return M;return M}constructor(y){if(this.customKeys=[],void 0===y)this.mode=_c.Smooth,this.stepCount=10,this.marginColor=$r.fromJSON(),this.colorScheme=vc.BlueRed,this.colorMix=0,this.transparencyMode=yc.SurfaceOnly;else{if(this.mode=void 0!==y.mode&&null!==y.mode?y.mode:_c.Smooth,(this.mode<_c.Smooth||this.mode>_c.IsoLines)&&(this.mode=_c.Smooth),this.stepCount="number"==typeof y.stepCount?y.stepCount:10,this.stepCount<2&&(this.stepCount=2),this.marginColor=$r.fromJSON(y.marginColor),this.colorScheme=void 0!==y.colorScheme&&null!==y.colorScheme?y.colorScheme:vc.BlueRed,(this.colorScheme<vc.BlueRed||this.colorScheme>vc.Custom)&&(this.colorScheme=vc.BlueRed),void 0!==y.customKeys&&null!==y.customKeys&&y.customKeys.forEach((y=>this.customKeys.push(new Ac.KeyColor(y)))),this.colorScheme===vc.Custom&&this.customKeys.length<2){this.customKeys=[];for(const y of ya._defaultCustomKeys)this.customKeys.push(new Ac.KeyColor({value:y[0],color:$r.computeTbgrFromComponents(y[1],y[3],y[2])}))}this.colorMix=y.colorMix??0,this.transparencyMode=y.transparencyMode??yc.SurfaceOnly}}static fromJSON(y){return y?new ya(y):this.defaults}toJSON(){const y={};_c.Smooth!==this.mode&&(y.mode=this.mode),10!==this.stepCount&&(y.stepCount=this.stepCount);const k=this.marginColor.toJSON();return 0!==k&&(y.marginColor=k),vc.BlueRed!==this.colorScheme&&(y.colorScheme=this.colorScheme),0!==this.colorMix&&(y.colorMix=this.colorMix),yc.SurfaceOnly!==this.transparencyMode&&(y.transparencyMode=this.transparencyMode),this.customKeys.length>0&&(y.customKeys=this.customKeys.map((y=>({value:y.value,color:y.color.toJSON()})))),y}clone(y){if(void 0===y)return ya.fromJSON(this.toJSON());const k={mode:void 0!==y.mode?y.mode:this.mode,stepCount:void 0!==y.stepCount?y.stepCount:this.stepCount,marginColor:void 0!==y.marginColor?y.marginColor:this.marginColor.tbgr,colorScheme:void 0!==y.colorScheme?y.colorScheme:this.colorScheme,customKeys:void 0!==y.customKeys?y.customKeys:this.customKeys.map((y=>({value:y.value,color:y.color.tbgr}))),colorMix:void 0!==y.colorMix?y.colorMix:this.colorMix,transparencyMode:y.transparencyMode??this.transparencyMode};return ya.fromJSON(k)}}ya.defaults=new ya({}),ya._defaultCustomKeys=[[0,255,255,255],[1,0,0,0]],function(y){y[y.Height=0]="Height",y[y.InverseDistanceWeightedSensors=1]="InverseDistanceWeightedSensors",y[y.Slope=2]="Slope",y[y.HillShade=3]="HillShade"}(Pc||(Pc={})),function(y){let k,M;!function(y){y[y.None=0]="None",y[y.Invert=1]="Invert",y[y.Outline=2]="Outline"}(k=y.Flags||(y.Flags={})),function(y){y[y.None=0]="None",y[y.Linear=1]="Linear",y[y.Curved=2]="Curved",y[y.Cylindrical=3]="Cylindrical",y[y.Spherical=4]="Spherical",y[y.Hemispherical=5]="Hemispherical",y[y.Thematic=6]="Thematic"}(M=y.Mode||(y.Mode={}));class n{constructor(y){this.value=y.value,this.color=$r.fromJSON(y.color)}}y.KeyColor=n,y.keyColorEquals=function(y,k){return y.value===k.value&&y.color.equals(k.color)};class r{constructor(){this.mode=M.None,this.flags=k.None,this.shift=0,this.keys=[]}static fromJSON(y){const M=new r;return y?(M.mode=y.mode,M.flags=void 0===y.flags?k.None:y.flags,M.angle=y.angle?W.fromJSON(y.angle):void 0,M.tint=y.tint,M.shift=y.shift?y.shift:0,y.keys.forEach((y=>M.keys.push(new n(y)))),M.thematicSettings=void 0===y.thematicSettings?void 0:ya.fromJSON(y.thematicSettings),M):M}static createThematic(k){const b=new r;if(b.mode=M.Thematic,b.thematicSettings=k,k.colorScheme<vc.Custom)for(const M of y.Symb._fixedSchemeKeys[k.colorScheme])b.keys.push(new n({value:M[0],color:$r.computeTbgrFromComponents(M[1],M[3],M[2])}));else if(e(k.customKeys.length),k.customKeys.length>1)k.customKeys.forEach((y=>b.keys.push(y)));else for(const M of y.Symb._fixedCustomKeys)b.keys.push(new n({value:M[0],color:$r.from(M[1],M[3],M[2]).toJSON()}));return b}toJSON(){return{...this,thematicSettings:this.thematicSettings?.toJSON(),keys:this.keys.map((y=>({value:y.value,color:y.color.toJSON()})))}}clone(){return r.fromJSON(this.toJSON())}equals(y){return 0===r.compareSymb(this,y)}static compareSymb(y,k){if(y===k)return 0;if(y.mode!==k.mode)return y.mode-k.mode;if(y.flags!==k.flags)return void 0===y.flags?-1:void 0===k.flags?1:y.flags-k.flags;if(y.tint!==k.tint)return void 0===y.tint?-1:void 0===k.tint?1:y.tint-k.tint;if(y.shift!==k.shift)return void 0===y.shift?-1:void 0===k.shift?1:y.shift-k.shift;if(void 0===y.angle!=(void 0===k.angle))return void 0===y.angle?-1:1;if(y.angle&&!y.angle.isAlmostEqualNoPeriodShift(k.angle))return y.angle.radians-k.angle.radians;if(y.keys.length!==k.keys.length)return y.keys.length-k.keys.length;for(let M=0;M<y.keys.length;M++){if(y.keys[M].value!==k.keys[M].value)return y.keys[M].value-k.keys[M].value;if(!y.keys[M].color.equals(k.keys[M].color))return y.keys[M].color.tbgr-k.keys[M].color.tbgr}if(y.thematicSettings!==k.thematicSettings){if(void 0===y.thematicSettings)return-1;if(void 0===k.thematicSettings)return 1;{const M=ya.compare(y.thematicSettings,k.thematicSettings);if(0!==M)return M}}return 0}compare(k){return y.Symb.compareSymb(this,k)}roundToByte(y){return 255&Math.min(y+.5,255)}mapColor(y){y<0?y=0:y>1&&(y=1),this.flags&k.Invert&&(y=1-y);let M,b,E,D=0;if(this.keys.length<=2)b=1-y,E=y;else{for(;D<this.keys.length-2&&y>this.keys[D+1].value;)D++;M=this.keys[D+1].value-this.keys[D].value,E=M<1e-4?0:(y-this.keys[D].value)/M,b=1-E}const R=this.keys[D].color,X=this.keys[D+1].color,z=R.colors,N=X.colors,Y=b*z.r+E*N.r,O=b*z.g+E*N.g,B=b*z.b+E*N.b,V=b*z.t+E*N.t;return $r.from(this.roundToByte(Y),this.roundToByte(O),this.roundToByte(B),this.roundToByte(V))}get hasTranslucency(){for(const y of this.keys)if(!y.color.isOpaque)return!0;return!1}get isOutlined(){return!!(this.flags&k.Outline)}getThematicImageForRenderer(y){e((M.Thematic,this.mode));let k=this.thematicSettings;void 0===k&&(k=ya.defaults);const b=Math.min(k.stepCount,y),E=_c.Smooth===k.mode?y:b,D=new Uint8Array(1*E*4);let R=D.length-1;function c(y){D[R--]=y.getAlpha(),D[R--]=y.colors.b,D[R--]=y.colors.g,D[R--]=y.colors.r}switch(k.mode){case _c.Smooth:for(let y=0;y<E;y++){const k=1-y/E;c(this.mapColor(k))}break;case _c.SteppedWithDelimiter:case _c.IsoLines:case _c.Stepped:e(k.stepCount);for(let y=0;y<E;y++){const k=1-y/(E-1);c(this.mapColor(k))}}e();const X=_a.create(D,pc.Rgba,1);return e(),X}getImage(y,k){return this.mode===M.Thematic&&(y=1),this.produceImage({width:y,height:k,includeThematicMargin:!0})}produceImage(y){const{width:k,height:b,includeThematicMargin:E}={...y},D=void 0===this.angle?0:this.angle.radians,R=Math.cos(D),X=Math.sin(D),z=new Uint8Array(k*b*4);let N=z.length-1;const Y=Math.min(1,Math.abs(this.shift));switch(this.mode){case M.Linear:case M.Cylindrical:{const y=.5-.25*Y*R,E=.5-.25*Y*X;let D,O,B=D=0;for(let k=0;k<2;k++)for(let M=0;M<2;M++)O=(M-y)*R+(k-E)*X,O<B&&(B=O),O>D&&(D=O);for(let Y=0;Y<b;Y++){const V=Y/b-E;for(let b=0;b<k;b++){let E;O=(b/k-y)*R+V*X,E=this.mode===M.Linear?O>0?.5+.5*O/D:.5-.5*O/B:O>0?Math.sin(Math.PI/2*(1-O/D)):Math.sin(Math.PI/2*(1-O/B));const Y=this.mapColor(E);z[N--]=Y.getAlpha(),z[N--]=Y.colors.b,z[N--]=Y.colors.g,z[N--]=Y.colors.r}}break}case M.Curved:{const y=.5+.5*X-.25*Y*R,M=.5-.5*R-.25*Y*X;for(let E=0;E<b;E++){const D=E/b-M;for(let M=0;M<k;M++){const b=M/k-y,E=.8*(b*R+D*X),Y=D*R-b*X,O=Math.sin(Math.PI/2*(1-Math.sqrt(E*E+Y*Y))),B=this.mapColor(O);z[N--]=B.getAlpha(),z[N--]=B.colors.b,z[N--]=B.colors.g,z[N--]=B.colors.r}}break}case M.Spherical:{const y=.5+.125*Math.sin(2*D),M=.5*Y*(R+X)*y,E=.5*Y*(X-R)*y;for(let D=0;D<b;D++){const R=E+D/b-.5;for(let b=0;b<k;b++){const E=M+b/k-.5,D=Math.sin(Math.PI/2*(1-Math.sqrt(E*E+R*R)/y)),X=this.mapColor(D);z[N--]=X.getAlpha(),z[N--]=X.colors.b,z[N--]=X.colors.g,z[N--]=X.colors.r}}break}case M.Hemispherical:{const y=.5+.5*X-.5*Y*R,M=.5-.5*R-.5*Y*X;for(let E=0;E<b;E++){const D=E/b-M;for(let M=0;M<k;M++){const b=M/k-y,E=Math.sin(Math.PI/2*(1-Math.sqrt(b*b+D*D))),R=this.mapColor(E);z[N--]=R.getAlpha(),z[N--]=R.colors.b,z[N--]=R.colors.g,z[N--]=R.colors.r}}break}case M.Thematic:{const y=this.thematicSettings??ya.defaults;for(let M=0;M<b;M++){let D,R=1-M/b;if(E&&(R<ya.margin||R>ya.contentMax))D=y.marginColor;else switch(R=(R-ya.margin)/ya.contentRange,y.mode){case _c.SteppedWithDelimiter:case _c.IsoLines:case _c.Stepped:if(y.stepCount>1){const k=Math.floor(R*y.stepCount-1e-5)/(y.stepCount-1);D=this.mapColor(k)}break;case _c.Smooth:D=this.mapColor(R)}for(let y=0;y<k;y++)z[N--]=D.getAlpha(),z[N--]=D.colors.b,z[N--]=D.colors.g,z[N--]=D.colors.r}}}e();const O=_a.create(z,pc.Rgba,k);return e(),O}}r._fixedSchemeKeys=[[[0,0,255,0],[.25,0,255,255],[.5,0,0,255],[.75,255,0,255],[1,255,0,0]],[[0,255,0,0],[.25,255,0,255],[.5,0,0,255],[.75,0,255,255],[1,0,255,0]],[[0,0,0,0],[1,255,255,255]],[[0,152,148,188],[.5,204,160,204],[1,152,72,128]],[[0,0,255,0],[.2,72,96,160],[.4,152,96,160],[.6,128,32,104],[.7,148,180,128],[1,240,240,240]]],r._fixedCustomKeys=[[0,255,0,0],[1,0,255,0]],y.Symb=r}(Ac||(Ac={})),function(y){y[y.Mesh=0]="Mesh",y[y.Polyline=1]="Polyline",y[y.Point=2]="Point"}(Ic||(Ic={})),function(y){y[y.Unlit=0]="Unlit",y[y.Lit=1]="Lit",y[y.Textured=2]="Textured",y[y.TexturedLit=3]="TexturedLit",y[y.VolumeClassifier=4]="VolumeClassifier"}(Sc||(Sc={}));class va{constructor(y,k,M,b=0,E=fc.Solid,D=gc.None,R,X,z=!1,N){this.type=va.Type.Mesh,this.type=y,this.material=R,this.gradient=X,this.lineColor=va.adjustTransparency(k),this.fillColor=va.adjustTransparency(M),this.width=b,this.linePixels=E,this.fillFlags=D,this.ignoreLighting=z,this._textureMapping=N,e()}static createForType(y,k,M,b=!1){const E=va.adjustTransparency(k.lineColor);switch(y){case va.Type.Mesh:{let D;if(void 0!==k.gradient&&void 0!==M){const y=M(k.gradient);void 0!==y&&(D=new xa(y,new xa.Params))}return new va(y,E,va.adjustTransparency(k.fillColor),k.rasterWidth,k.linePixels,k.fillFlags,k.material,k.gradient,b,D)}case va.Type.Linear:return new va(y,E,E,k.rasterWidth,k.linePixels);default:return new va(y,E,E,0,fc.Solid,gc.Always,void 0,void 0,!0)}}static createForMesh(y,k,M){return va.createForType(va.Type.Mesh,y,M,k)}static createForLinear(y){return va.createForType(va.Type.Linear,y)}static createForText(y){return va.createForType(va.Type.Text,y)}get regionEdgeType(){return this.hasBlankingFill?va.RegionEdgeType.None:void 0!==this.gradient&&void 0!==this.gradient.flags?this.gradient.flags&Ac.Flags.Outline||gc.None===(this.fillFlags&gc.Always)?va.RegionEdgeType.Outline:va.RegionEdgeType.None:this.fillColor.equals(this.lineColor)?va.RegionEdgeType.Default:va.RegionEdgeType.Outline}get wantRegionOutline(){return va.RegionEdgeType.Outline===this.regionEdgeType}get hasBlankingFill(){return gc.Blanking===(this.fillFlags&gc.Blanking)}get hasFillTransparency(){return 255!==this.fillColor.getAlpha()}get hasLineTransparency(){return 255!==this.lineColor.getAlpha()}get textureMapping(){return void 0!==this.material?this.material.textureMapping:this._textureMapping}get isTextured(){return void 0!==this.textureMapping}equals(y,k=va.ComparePurpose.Strict){return va.ComparePurpose.Merge===k?0===this.compareForMerge(y):y===this||this.type===y.type&&this.ignoreLighting===y.ignoreLighting&&this.width===y.width&&this.linePixels===y.linePixels&&this.fillFlags===y.fillFlags&&this.wantRegionOutline===y.wantRegionOutline&&this.material===y.material&&this.textureMapping===y.textureMapping&&!!this.fillColor.equals(y.fillColor)&&!!this.lineColor.equals(y.lineColor)}compareForMerge(y){if(y===this)return 0;let k=i(this.type,y.type);return 0===k&&(k=s(this.ignoreLighting,y.ignoreLighting),0===k&&(k=i(this.width,y.width),0===k&&(k=i(this.linePixels,y.linePixels),0===k&&(k=i(this.fillFlags,y.fillFlags),0===k&&(k=s(this.wantRegionOutline,y.wantRegionOutline),0===k&&(k=s(this.hasFillTransparency,y.hasFillTransparency),0===k&&(k=s(this.hasLineTransparency,y.hasLineTransparency),0===k&&(k=function(y,k){return r(((y,k)=>y.compare(k)),y,k)}(this.material,y.material),0===k&&void 0===this.material&&this.isTextured&&(k=function(y,k){return r(((y,k)=>y.compare(k)),y,k)}(this.textureMapping,y.textureMapping)))))))))),k}static adjustTransparency(y){return y.colors.t<va.minTransparency?y.withTransparency(0):y}}va.minTransparency=15,function(y){let k,M,b;!function(y){y[y.Mesh=0]="Mesh",y[y.Linear=1]="Linear",y[y.Text=2]="Text"}(k=y.Type||(y.Type={})),function(y){y[y.None=0]="None",y[y.Default=1]="Default",y[y.Outline=2]="Outline"}(M=y.RegionEdgeType||(y.RegionEdgeType={})),function(y){y[y.Merge=0]="Merge",y[y.Strict=1]="Strict"}(b=y.ComparePurpose||(y.ComparePurpose={}))}(va||(va={}));const Cc=new Uint16Array(1);function Aa(y){return Ia(.5+255*(.5*function(y){return y<-1?-1:y>1?1:y}(y)+.5))}function Ia(y){return Cc[0]=y,Cc[0]}function Sa(y){return y<0?-1:1}class wa{constructor(y){this.value=Ia(y)}static encode(y){return this.encodeXYZ(y.x,y.y,y.z)}static encodeXYZ(y,k,M){const b=Math.abs(y)+Math.abs(k)+Math.abs(M);let E=y/b,D=k/b;if(M<0){const y=E,k=D;E=(1-Math.abs(k))*Sa(y),D=(1-Math.abs(y))*Sa(k)}return Aa(D)<<8|Aa(E)}static fromVector(y){return new wa(this.encode(y))}decode(){return wa.decodeValue(this.value)}static decodeValue(y,k){let M=255&y,b=y>>8;M=M/255*2-1,b=b/255*2-1;const E=1-(Math.abs(M)+Math.abs(b));let D;if(void 0===k?D=new $(M,b,E):(D=k,D.x=M,D.y=b,D.z=E),D.z<0){const y=D.x,k=D.y;D.x=(1-Math.abs(k))*Sa(y),D.y=(1-Math.abs(y))*Sa(k)}return D.normalizeInPlace(),D}}function Ca(y,k,M,b){const E=Math.ceil(y*k)+M;if(E<=b)return{width:E,height:1};let D=Math.ceil(Math.sqrt(E));const R=D%k;0!==R&&(D+=k-R);const X=Math.ceil(E/D);return e(),e(),e(),e(Math.floor(X)),e(Math.floor(D)),e(),{width:D,height:X}}class Ta{constructor(y){this.name=y.name,this.inputs=y.inputs,this.indices=y.indices}toJSON(){return{name:this.name,inputs:this.inputs,indices:this.indices}}}class Fa extends Ta{constructor(y){super(y),this.qOrigin=Float32Array.from(y.qOrigin),this.qScale=Float32Array.from(y.qScale)}toJSON(){return{...super.toJSON(),qOrigin:Array.from(this.qOrigin),qScale:Array.from(this.qScale)}}}class ka extends Ta{constructor(y){super(y),this.qOrigin=y.qOrigin[0],this.qScale=y.qScale[0]}toJSON(){return{...super.toJSON(),qOrigin:[this.qOrigin],qScale:[this.qScale]}}}class Ma{constructor(y,k,M,b){this.data=y.data,this.width=y.width,this.height=y.height,this.numVertices=y.count,this.numBytesPerVertex=y.numBytesPerVertex,this.displacements=k,this.normals=M,this.params=b}static fromJSON(y){let k,M,b;if(void 0!==y.displacements&&0<y.displacements.length){k=[];for(const M of y.displacements)k.push(new Fa(M))}if(void 0!==y.normals&&0<y.normals.length){M=[];for(const k of y.normals)M.push(new Ta(k))}if(void 0!==y.params&&0<y.params.length){b=[];for(const k of y.params)b.push(new ka(k))}return void 0!==k||void 0!==M||void 0!==b?new Ma(y,k,M,b):void 0}toJSON(){return{data:this.data,width:this.width,height:this.height,count:this.numVertices,numBytesPerVertex:this.numBytesPerVertex,displacements:this.displacements?.map((y=>y.toJSON())),normals:this.normals?.map((y=>y.toJSON())),params:this.params?.map((y=>y.toJSON()))}}static fromChannels(y,k,M){return Ea.buildAuxChannelTable(y,k,M)}}function ba(y){return 0!==y&&(y=1/y),y}class Ea{constructor(y,k){this._props=y,this._numBytesPerVertex=k,this._view=new DataView(y.data.buffer)}static buildAuxChannelTable(y,k,M){const b=y.reduce(((y,k)=>y+Ra(k)),0);if(!b)return;const E=Math.floor((b+3)/4),D=4*E-b;let R;e(),R=0!==D?Ca(Math.floor((k+1)/2),b/2,0,M):Ca(k,E,0,M);const X={data:new Uint8Array(R.width*R.height*4),width:R.width,height:R.height,count:k,numBytesPerVertex:b};return new Ea(X,b).build(y),Ma.fromJSON(X)}build(y){let k=0;for(const M of y)jr.Normal===M.dataType?this.addNormals(M,k):jr.Vector===M.dataType?this.addDisplacements(M,k):this.addParams(M,k),k+=Ra(M)}addNormals(y,k){const M=[],b=[],E=new $;for(let D=0;D<y.data.length;D++){let R=k+2*D;b.push(R/2);const X=y.data[D];M.push(X.input);for(let y=0;y<X.values.length;y+=3){E.x=X.values[y],E.y=X.values[y+1],E.z=X.values[y+2],E.normalizeInPlace();const k=wa.encode(E);this._view.setUint16(R,k,!0),R+=this._numBytesPerVertex}}(this._props.normals??(this._props.normals=[])).push({name:y.name??"",inputs:M,indices:b})}addParams(y,k){const M=[],b=[],E=ft.createNull();for(const R of y.data)M.push(R.input),E.extendArray(R.values);const D=ia.computeScale(E.high-E.low);for(let R=0;R<y.data.length;R++){let M=k+2*R;b.push(M/2);for(const k of y.data[R].values){const y=ia.quantize(k,E.low,D);this._view.setUint16(M,y,!0),M+=this._numBytesPerVertex}}(this._props.params??(this._props.params=[])).push({inputs:M,indices:b,name:y.name??"",qOrigin:[E.low],qScale:[ba(D)]})}addDisplacements(y,k){const M=[],b=[],E=new j,D=ut.createNull();for(const z of y.data){M.push(z.input);for(let y=0;y<z.values.length;y+=3)E.set(z.values[y],z.values[y+1],z.values[y+2]),D.extend(E)}const R=fa.fromRange(D),X=new ga;for(let z=0;z<y.data.length;z++){let M=k+6*z;b.push(M/2);const D=y.data[z];for(let y=0;y<D.values.length;y+=3)E.set(D.values[y],D.values[y+1],D.values[y+2]),X.init(E,R),this._view.setUint16(M+0,X.x,!0),this._view.setUint16(M+2,X.y,!0),this._view.setUint16(M+4,X.z,!0),M+=this._numBytesPerVertex}(this._props.displacements??(this._props.displacements=[])).push({inputs:M,indices:b,name:y.name??"",qOrigin:R.origin.toArray(),qScale:R.scale.toArray().map((y=>ba(y)))})}}function Ra(y){const k=y.data.length;switch(y.dataType){case jr.Vector:return 6*k;case jr.Normal:case jr.Distance:case jr.Scalar:return 2*k}}class Da{constructor(y,k){this._constructor=y,this._data=new y(k?.initialCapacity??0),this.growthFactor=Math.max(1,k?.growthFactor??1.5),this._length=0}get length(){return this._length}get capacity(){return this._data.length}at(y){y<0&&(y=this.length-y);const k=this._data[y];return e(),k}ensureCapacity(y){if(this.capacity>=y)return this.capacity;e(this.growthFactor),y=Math.ceil(y*this.growthFactor);const k=this._data;return this._data=new this._constructor(y),this._data.set(k,0),e(this.capacity),this.capacity}push(y){this.ensureCapacity(this.length+1),this._data[this.length]=y,++this._length}append(y){const k=this.length+y.length;this.ensureCapacity(k),this._data.set(y,this.length),this._length=k}toTypedArray(y=!1){if(y)return this._data;const k=this._data.subarray(0,this.length);return e(this._constructor),e((k.buffer,this._data.buffer)),k}}class Xa extends Da{constructor(y){super(Uint8Array,y)}}class za extends Da{constructor(y){super(Uint32Array,y)}toUint8Array(y=!1){return y?new Uint8Array(this._data.buffer):new Uint8Array(this._data.buffer,0,4*this.length)}}function Na(y,k,M){let b=Math.ceil(1.5*y+2.5*k);const E=6*y;let D=0,R=b,X=1;if(b>=M){R=Math.ceil(Math.sqrt(b));const M=R%15;0!==M&&(R+=15-M),k>0&&y>0&&(D=(60-E%60)%10,b+=Math.ceil(D/4)),X=Math.ceil(b/R),R*X<b&&X++}return{width:R,height:X,silhouettePadding:D,silhouetteStartByteIndex:E}}class Oa{constructor(y){this.data=y,e(this.data.length)}get length(){return this.data.length/3}static fromArray(y){const k=new Uint8Array(3*y.length);for(let M=0;M<y.length;M++)this.encodeIndex(y[M],k,3*M);return new Oa(k)}static encodeIndex(y,k,M){e(k.length),k[M+0]=255&y,k[M+1]=(65280&y)>>8,k[M+2]=(16711680&y)>>16}setNthIndex(y,k){Oa.encodeIndex(k,this.data,3*y)}decodeIndex(y){e(this.length);const k=3*y;return this.data[k]|this.data[k+1]<<8|this.data[k+2]<<16}decodeIndices(){const y=[];for(let k=0;k<this.length;k++)y.push(this.decodeIndex(k));return y}[Symbol.iterator](){return function*(y){for(let k=0;k<y.length;k++)yield y.decodeIndex(k)}(this)}}class Ya{constructor(y=3){this._index32=new Uint32Array(1),this._index8=new Uint8Array(this._index32.buffer,0,3),this._builder=new Xa({initialCapacity:3*y})}get numIndices(){return e(this._builder.length),this._builder.length/3}push(y){this._index32[0]=y,this._builder.append(this._index8)}toVertexIndices(){return new Oa(this._builder.toTypedArray())}}class Ba{constructor(y){this._source=y,this._builder=new za({initialCapacity:3*y.numRgbaPerVertex})}get length(){return e((this._builder.length,this.vertexSize)),this._builder.length/this.vertexSize}get vertexSize(){return this._source.numRgbaPerVertex}push(y){e((y.length,this.vertexSize)),this._builder.append(y)}buildVertexTable(y,k,M){const b=this._source;e(k=k??b.uniformColor);const E=k instanceof Uint32Array?k.length:0,D=M instanceof Uint32Array?M.length:0,R=Ca(this.length,this.vertexSize,E+D,y);let X=this._builder.toTypedArray();if(R.width*R.height>X.length){const y=X;X=new Uint32Array(R.width*R.height),X.set(y,0)}let z=this.vertexSize*this.length;return k instanceof Uint32Array&&(X.set(k,z),z+=k.length),M instanceof Uint32Array&&X.set(M,z),{data:new Uint8Array(X.buffer,X.byteOffset,X.byteLength),usesUnquantizedPositions:b.usesUnquantizedPositions,qparams:b.qparams,width:R.width,height:R.height,hasTranslucency:b.hasTranslucency,uniformColor:k instanceof $r?k:void 0,featureIndexType:b.featureIndexType,uniformFeatureID:b.uniformFeatureID,numVertices:this.length,numRgbaPerVertex:b.numRgbaPerVertex,uvParams:b.uvParams}}}class Va{constructor(y){this._remappedIndices=new Map,this.colors=[],this._32=new Uint32Array(1),this._16=new Uint16Array(this._32.buffer),this._colorTable=y}remap(y,k){const M=k?4:1,b=k?0:1;this._32[0]=y[M];const E=this._16[b];let D=this._remappedIndices.get(E);if(void 0===D){D=this.colors.length,this._remappedIndices.set(E,D);const y=this._colorTable[E];this.colors.push(y)}this._16[b]=D,y[M]=this._32[0]}buildColorTable(){return e(this.colors.length),this.colors.length>1?new Uint32Array(this.colors):$r.fromAbgr(this.colors[0])}}class La{constructor(y,k){this._remappedIndices=new Map,this.materials=[],this._32=new Uint32Array(1),this._8=new Uint8Array(this._32.buffer),this._atlasTable=y,this._createMaterial=k}remap(y,k){const M=k?3:2;this._32[0]=y[M];const b=this._8[3];let E=this._remappedIndices.get(b);if(void 0===E){E=this.materials.length/4,this._remappedIndices.set(b,E);let y=4*b;this.materials.push(this._atlasTable[y++]),this.materials.push(this._atlasTable[y++]),this.materials.push(this._atlasTable[y++]),this.materials.push(this._atlasTable[y])}this._8[3]=E,y[M]=this._32[0]}unpackFloat(y){this._32[0]=y;const k=this._32[0],M=(k>>>24)/2;let b=Math.floor(M),E=2*(M-b);return E=-(2*E-1),b-=38,E*(16777215&k)/16777216*Math.pow(10,b)}materialFromAtlasEntry(y){const k=!!(16777216&y[1]),M={alpha:33554432&y[1]?(y[0]>>>24)/255:void 0,diffuse:{color:k?$r.fromTbgr(16777215&y[0]):void 0,weight:(y[1]>>>8&255)/255},specular:{color:$r.fromTbgr(y[2]),weight:(y[1]>>>16&255)/255,exponent:this.unpackFloat(y[3])}};return void 0===(b=this._createMaterial(M))?void 0:{isAtlas:!1,material:b};var b}buildAtlasTable(){e(this.materials.length);const y=new Uint32Array(this.materials);return this.materials.length>4?y:this.materialFromAtlasEntry(y)}}class Ua{constructor(y,k){if(this.remappedIndices=new Map,this.indices=new Ya,this.vertices=new Ba(y),void 0===y.uniformColor&&(this.colors=new Va(new Uint32Array(y.data.buffer,y.data.byteOffset+4*y.numVertices*y.numRgbaPerVertex))),k){const M=4*(y.numVertices*y.numRgbaPerVertex+k.offset);this.atlas=new La(new Uint32Array(y.data.buffer,y.data.byteOffset+M),k.createMaterial)}this.usesUnquantizedPositions=y.usesUnquantizedPositions}addVertex(y,k){let M=this.remappedIndices.get(y);void 0===M&&(M=this.vertices.length,this.remappedIndices.set(y,M),this.colors?.remap(k,this.usesUnquantizedPositions),this.atlas?.remap(k,this.usesUnquantizedPositions),this.vertices.push(k)),this.indices.push(M)}buildOutput(y,k){const M=this.atlas?.buildAtlasTable();let b;if(M instanceof Uint32Array){const y=void 0!==this.colors?.colors.length&&this.colors?.colors.length>1?this.colors?.colors.length:0;b={isAtlas:!0,hasTranslucency:(k?.isAtlas&&k?.hasTranslucency)??!1,overridesAlpha:(k?.isAtlas&&k?.overridesAlpha)??!1,vertexTableOffset:y,numMaterials:M.length/4}}else b=M;return{indices:this.indices.toVertexIndices(),vertices:this.vertices.buildVertexTable(y,this.colors?.buildColorTable(),M),material:b}}}class Za{constructor(y,k){this._nodes=new Map,this._input=y,this._computeNodeId=k}static split(y,k){const M=new Za(y,k);return M.split(),M._nodes}split(){const y={featureIndex:-1,node:void 0},k=this._input.vertices.numRgbaPerVertex,M=new Uint32Array(k),b=new Uint32Array(this._input.vertices.data.buffer,this._input.vertices.data.byteOffset,this._input.vertices.numVertices*k);let E;if(this._input.vertices.usesUnquantizedPositions){const y=new Uint8Array(M.buffer);E=()=>y[3]|y[7]<<8|y[11]<<16}else E=()=>16777215&M[2];for(const D of this._input.indices){const R=D*k;for(let y=0;y<M.length;y++)M[y]=b[R+y];const X=E();if(y.featureIndex!==X){y.featureIndex=X;const k=this._computeNodeId(X);let M=this._nodes.get(k);void 0===M&&this._nodes.set(k,M=new Ua(this._input.vertices,this._input.atlasInfo)),y.node=M}y.node.addVertex(D,M)}}}function qa(y){const k=Za.split({indices:y.params.indices,vertices:y.params.vertices,featureTable:y.featureTable},y.computeNodeId),M=new Map;for(const[b,E]of k){const{vertices:k,indices:D}=E.buildOutput(y.maxDimension);M.set(b,{vertices:k,indices:D,weight:y.params.weight})}return M}class Wa{constructor(){this.indices=new Ya,this.prevIndices=new Ya,this.nextIndicesAndParams=new za}}function Ga(y,k,M){for(const[b,E]of M){const M=E.remappedIndices.get(k);if(void 0!==M)return y.index=M,y.node=E,y.id=b,!0}return e(),!1}function Ha(y,k,M,b){const E=k[y];if(!E)return;const D=new Uint32Array(E.endPointAndQuadIndices.buffer,E.endPointAndQuadIndices.byteOffset,E.endPointAndQuadIndices.length/4);let R;"silhouettes"===y&&(e(k.silhouettes),R=new Uint32Array(k.silhouettes.normalPairs.buffer,k.silhouettes.normalPairs.byteOffset,k.silhouettes.normalPairs.length/4));let X=0;const z={};for(const N of E.indices){if(Ga(z,N,M)){let k=D[X];const M=(16777215&k)>>>0,E=z.node.remappedIndices.get(M);e(),k=4278190080&k|E;let N=b.get(z.id);N||b.set(z.id,N={}),R?(N.silhouettes||(N.silhouettes={indices:new Ya,endPointAndQuadIndices:new za,normalPairs:new za}),N.silhouettes.normalPairs.push(R[X])):N.segments||(N.segments={indices:new Ya,endPointAndQuadIndices:new za});const Y=N[y];e(),Y.indices.push(z.index),Y.endPointAndQuadIndices.push(k)}++X}}function Ja(y){const k=new Map,M=y.params.surface.material,b=void 0!==M&&M.isAtlas?M.vertexTableOffset:void 0,E=void 0!==b?{offset:b,createMaterial:y.createMaterial}:void 0,D=Za.split({indices:y.params.surface.indices,vertices:y.params.vertices,featureTable:y.featureTable,atlasInfo:E},y.computeNodeId),R=y.params.edges?function(y,k,M){const b=new Map;Ha("segments",y,k,b),Ha("silhouettes",y,k,b),y.polylines&&function(y,k,M){const b=new Uint32Array(y.nextIndicesAndParams.buffer,y.nextIndicesAndParams.byteOffset,y.nextIndicesAndParams.length/4),E=y.prevIndices[Symbol.iterator]();let D=0;const R={};for(const X of y.indices){if(Ga(R,X,k)){const y=E.next().value;e();const k=R.node.remappedIndices.get(y);e();let X=b[D];const z=(16777215&X)>>>0,N=R.node.remappedIndices.get(z);e(),X=4278190080&X|N;let Y=M.get(R.id);Y||M.set(R.id,Y={}),Y.polylines||(Y.polylines=new Wa),Y.polylines.indices.push(R.index),Y.polylines.prevIndices.push(k),Y.polylines.nextIndicesAndParams.push(X)}++D}}(y.polylines,k,b),y.indexed&&function(y,k,M){const b=y.edges.data,E=y.edges.numSegments,D=6*E+y.edges.silhouettePadding;function a(y){return[b[y+0]|b[y+1]<<8|b[y+2]<<16,b[y+3]|b[y+4]<<8|b[y+5]<<16]}function c(y){return[b[y+0]|b[y+1]<<8|b[y+2]<<16,b[y+3]|b[y+4]<<8|b[y+5]<<16,b[y+6]|b[y+7]<<8,b[y+8]|b[y+9]<<8]}function l(y,k,M,b,E){y.silhouettes.push(255&k),y.silhouettes.push((65280&k)>>>8),y.silhouettes.push((16711680&k)>>>16),y.silhouettes.push(255&M),y.silhouettes.push((65280&M)>>>8),y.silhouettes.push((16711680&M)>>>16),y.silhouettes.push(255&b),y.silhouettes.push((65280&b)>>>8),y.silhouettes.push(255&E),y.silhouettes.push((65280&E)>>>8)}let R=0;for(const L of y.indices)R=Math.max(L,R);const X={};let z=0,N=0,Y=0,O=0;for(let L=0,Z=0;L<=R;++L)if(L<E?([z,N]=a(Z),Z+=6):(Z=D+10*(L-E),[z,N,Y,O]=c(Z)),Ga(X,z,k)){let y=M.get(X.id);if(y||M.set(X.id,y={}),y.indexed||(y.indexed={edges:new Xa,silhouettes:new Xa}),L<E){const k=X.node.remappedIndices.get(z);e();const M=X.node.remappedIndices.get(N);e(),V=k,U=M,(B=y.indexed).edges.push(255&V),B.edges.push((65280&V)>>>8),B.edges.push((16711680&V)>>>16),B.edges.push(255&U),B.edges.push((65280&U)>>>8),B.edges.push((16711680&U)>>>16)}else{const k=X.node.remappedIndices.get(z);e();const M=X.node.remappedIndices.get(N);e(),l(y.indexed,k,M,Y,O)}}var B,V,U}(y.indexed,k,b);const E=new Map;for(const[D,R]of b){if(!R.segments&&!R.silhouettes&&!R.indexed)continue;let k={},b={};if(R.indexed){const y=R.indexed.edges.length/6,E=R.indexed.silhouettes.length/10,{width:D,height:X,silhouettePadding:z,silhouetteStartByteIndex:N}=Na(y,E,M),Y=new Uint8Array(D*X*4);Y.set(R.indexed.edges.toTypedArray(),0),E>0&&Y.set(R.indexed.silhouettes.toTypedArray(),N+z);const O=y+E;b=new Oa(new Uint8Array(6*O*3));for(let k=0;k<O;k++)for(let y=0;y<6;y++)b.setNthIndex(6*k+y,k);k={data:Y,width:D,height:X,numSegments:y,silhouettePadding:z}}E.set(D,{weight:y.weight,linePixels:y.linePixels,segments:R.segments?{indices:R.segments.indices.toVertexIndices(),endPointAndQuadIndices:R.segments.endPointAndQuadIndices.toUint8Array()}:void 0,silhouettes:R.silhouettes?{indices:R.silhouettes.indices.toVertexIndices(),endPointAndQuadIndices:R.silhouettes.endPointAndQuadIndices.toUint8Array(),normalPairs:R.silhouettes.normalPairs.toUint8Array()}:void 0,polylines:R.polylines?{indices:R.polylines.indices.toVertexIndices(),prevIndices:R.polylines.prevIndices.toVertexIndices(),nextIndicesAndParams:R.polylines.nextIndicesAndParams.toUint8Array()}:void 0,indexed:R.indexed?{indices:b,edges:k}:void 0})}return E}(y.params.edges,D,y.maxDimension):void 0;for(const[X,z]of D){const{vertices:M,indices:b,material:E}=z.buildOutput(y.maxDimension,y.params.surface.material),D={vertices:M,surface:{type:y.params.surface.type,indices:b,fillFlags:y.params.surface.fillFlags,hasBakedLighting:y.params.surface.hasBakedLighting,textureMapping:y.params.surface.textureMapping,material:void 0!==E?E:y.params.surface.material},edges:R?.get(X),isPlanar:y.params.isPlanar,auxChannels:y.params.auxChannels};k.set(X,D)}return k}function Qa(y){const k=Za.split({indices:y.params.polyline.indices,vertices:y.params.vertices,featureTable:y.featureTable},y.computeNodeId),M=y.params.polyline,b=new Uint32Array(M.nextIndicesAndParams.buffer,M.nextIndicesAndParams.byteOffset,M.nextIndicesAndParams.length/4);let E=0;const D={};for(const X of M.prevIndices){if(Ga(D,X,k)){const y=D.node;y.prevIndices?e(y.nextIndicesAndParams):(e(y.nextIndicesAndParams),y.prevIndices=new Ya(y.indices.numIndices),y.nextIndicesAndParams=new za({initialCapacity:y.indices.numIndices})),y.prevIndices.push(D.index);let k=b[E];const M=(16777215&k)>>>0,R=D.node.remappedIndices.get(M);e(),k=4278190080&k|R,y.nextIndicesAndParams.push(k)}++E}const R=new Map;for(const[X,z]of k){e(void 0!==z.prevIndices&&z.nextIndicesAndParams);const{vertices:k,indices:M}=z.buildOutput(y.maxDimension),b={...y.params,vertices:k,polyline:{indices:M,prevIndices:z.prevIndices.toVertexIndices(),nextIndicesAndParams:z.nextIndicesAndParams.toUint8Array()}};R.set(X,b)}return R}var Tc,Fc;function $a(y,k,M){y[k+0]=255&M,y[k+1]=(65280&M)>>>8,y[k+2]=(16711680&M)>>>16}!function(y){y[y.Untransformed=4294967295]="Untransformed"}(Tc||(Tc={})),function(y){y[y.Hidden=0]="Hidden",y[y.Silhouette=1]="Silhouette",y[y.Visible=2]="Visible"}(Fc||(Fc={}));class tc extends aa{get isValid(){return $o.Gltf===this.format}constructor(y){super(y),this.scenePosition=0,this.sceneStrLength=0,this.binaryPosition=0,this.gltfLength=y.readUint32(),this.sceneStrLength=y.readUint32();const k=y.readUint32();if(this.version===ta.Version2&&k===ta.Gltf1SceneFormat&&(this.version=ta.Version1),this.version===ta.Version1){const M=k;if(ta.Gltf1SceneFormat!==M)return void this.invalidate();this.scenePosition=y.curPos,this.binaryPosition=y.curPos+this.sceneStrLength}else if(this.version===ta.Version2){const M=k;this.scenePosition=y.curPos,y.curPos=y.curPos+this.sceneStrLength;const b=y.readUint32(),E=y.readUint32();if(ea.JSON!==M||ea.Binary!==E||0===b)return void this.invalidate();this.binaryPosition=y.curPos}else this.invalidate()}}const kc=/Node_(.*)/;function ic(y){const k=y.match(kc);if(e(!!k&&k.length),!k||2!==k.length)return 0;const M=Number.parseInt(k[1],10);return e(Number.isNaN(M)),Number.isNaN(M)?0:M}class sc extends la{constructor(y){super(y)}dispose(){}get bytesUsed(){return 0}}class nc extends sc{constructor(y,k){super(k),this._name=y}toImdl(){return this._name}}class rc extends sc{constructor(y){super(la.Type.Normal),this._gradient=y}toImdl(){return this._gradient}}class oc extends ha{toImdl(){return{isAtlas:!1,material:this.key??this.materialParams}}constructor(y,k){super(y),this.materialParams=k??{alpha:y.alpha,diffuse:{color:y.diffuseColor?.toJSON(),weight:y.diffuse},specular:{color:y.specularColor?.toJSON(),weight:y.specular,exponent:y.specularExponent}}}static create(y){const k=new ha.Params;return k.alpha=y.alpha,y.diffuse&&(void 0!==y.diffuse.weight&&(k.diffuse=y.diffuse?.weight),y.diffuse?.color&&(k.diffuseColor=y.diffuse.color instanceof $r?y.diffuse.color:to.fromJSON(y.diffuse.color).toColorDef())),y.specular&&(void 0!==y.specular.weight&&(k.specular=y.specular.weight),void 0!==y.specular.exponent&&(k.specularExponent=y.specular.exponent),y.specular.color&&(k.specularColor=y.specular.color instanceof $r?y.specular.color:to.fromJSON(y.specular.color).toColorDef())),new oc(k)}}function ac(y){return{...y,uniformColor:void 0!==y.uniformColor?$r.fromJSON(y.uniformColor):void 0,qparams:fa.fromJSON(y.qparams),uvParams:y.uvParams?da.fromJSON(y.uvParams):void 0}}function cc(y){return{...y,uniformColor:y.uniformColor?.toJSON(),qparams:y.qparams.toJSON(),uvParams:y.uvParams?.toJSON()}}function lc(y){return{...y,segments:y.segments?{...y.segments,indices:y.segments.indices.data}:void 0,silhouettes:y.silhouettes?{...y.silhouettes,indices:y.silhouettes.indices.data}:void 0,polylines:y.polylines?{...y.polylines,indices:y.polylines.indices.data,prevIndices:y.polylines.prevIndices.data}:void 0,indexed:y.indexed?{indices:y.indexed.indices.data,edges:y.indexed.edges}:void 0}}class hc{constructor(y,k,M,b,E){this._patterns=new Map,this._document=y,this._binaryData=k,this._options=M,this._featureTableInfo=b,this._stream=E,this._timeline=M.timeline}parse(){const y=this.parseFeatureTable();if(!y)return Jo.InvalidFeatureTable;const k=this._document.rtcCenter?{x:this._document.rtcCenter[0]??0,y:this._document.rtcCenter[1]??0,z:this._document.rtcCenter[2]??0}:void 0,M=this.parseNodes(y);return{featureTable:y,nodes:this.groupPrimitiveNodes(M,y),rtcCenter:k,binaryData:this._binaryData,json:this._document,patterns:this._patterns}}parseFeatureTable(){this._stream.curPos=this._featureTableInfo.startPos;const y=ma.readFrom(this._stream);if(!y||0!=y.length%4)return;const k=(y.length-ma.sizeInBytes)/4,M=new Uint32Array(this._stream.nextUint32s(k));if(this._stream.isPastTheEnd)return;let b;if(this._featureTableInfo.multiModel)b={multiModel:!0,data:M,numFeatures:y.count,numSubCategories:y.numSubCategories};else{let k;const E=this._document.animationNodes;if(void 0!==E){const y=Ho.asInt(E.bytesPerId),M=Ho.asString(E.bufferView),b=this._document.bufferViews[M];if(void 0!==b){const M=Ho.asInt(b.byteOffset),E=Ho.asInt(b.byteLength),D=this._binaryData.subarray(M,M+E);switch(y){case 1:k=new Uint8Array(D);break;case 2:k=Uint16Array.from(new Uint16Array(D.buffer,D.byteOffset,D.byteLength/2));break;case 4:k=Uint32Array.from(new Uint32Array(D.buffer,D.byteOffset,D.byteLength/4))}}}b={multiModel:!1,data:M,numFeatures:y.count,animationNodeIds:k}}return this._stream.curPos=this._featureTableInfo.startPos+y.length,b}parseNodes(y){const k=[],M=this._document.nodes,b=this._document.meshes;if(void 0===M.Node_Root)return k;for(const E of Object.keys(M)){const M=this._document.nodes[E];e();const D=b[M],R=D?.primitives;if(!R)continue;const X=D.layer;"Node_Root"===E?this._timeline?this.parseAnimationBranches(k,D,y,this._timeline):this._options.createUntransformedRootNode?k.push({animationNodeId:Tc.Untransformed,primitives:this.parseNodePrimitives(R)}):k.push({primitives:this.parseNodePrimitives(R)}):void 0===X?k.push({animationNodeId:ic(E),animationId:`${this._options.batchModelId}_${E}`,primitives:this.parseNodePrimitives(R)}):k.push({layerId:X,primitives:this.parseNodePrimitives(R)})}return k}parseAnimationBranches(y,k,M,b){const E=k.primitives;if(!E)return;const D=E.map((y=>this.parseNodePrimitive(y))).filter((y=>void 0!==y));if(0===D.length)return;const R=new Map;e(M.animationNodeIds);const X=dc(M,this._options.batchModelId);X.populateAnimationNodeIds((y=>b.getBatchIdForFeature(y)),b.maxBatchId),M.animationNodeIds=X.animationNodeIds;const z=b.discreteBatchIds;this.splitPrimitives(D,X,(y=>{const k=X.getAnimationNodeId(y);return 0!==k&&z.has(k)?k:0}),(k=>{k=k??Tc.Untransformed;let M=R.get(k);return M||(M={animationNodeId:k,animationId:`${this._options.batchModelId}_Node_${k}`,primitives:[]},R.set(k,M),y.push(M)),M}))}splitPrimitives(y,k,M,b){const E={maxDimension:this._options.maxVertexTableSize,computeNodeId:M,featureTable:k},o=y=>{if(!y)return;if(y.isAtlas)return y;const k="string"==typeof y.material?this.materialFromJson(y.material):oc.create(function(y){const k={alpha:y.alpha};return y.diffuse&&(k.diffuse={weight:y.diffuse.weight,color:void 0!==y.diffuse.color?$r.fromJSON(y.diffuse.color):void 0}),y.specular&&(k.specular={weight:y.specular.weight,exponent:y.specular.exponent,color:void 0!==y.specular.color?$r.fromJSON(y.specular.color):void 0}),k}(y.material));return k?{isAtlas:!1,material:k}:void 0};for(const R of y)switch(R.type){case"pattern":b(void 0).primitives.push(R);break;case"mesh":{const y=R.params,k=y.surface.textureMapping,M={vertices:ac(R.params.vertices),surface:{...R.params.surface,indices:new Oa(R.params.surface.indices),material:o(y.surface.material),textureMapping:k?{alwaysDisplayed:k.alwaysDisplayed,texture:"string"==typeof k.texture?new nc(k.texture,la.Type.Normal):new rc(k.texture)}:void 0},edges:R.params.edges?(D=R.params.edges,{...D,segments:D.segments?{...D.segments,indices:new Oa(D.segments.indices)}:void 0,silhouettes:D.silhouettes?{...D.silhouettes,indices:new Oa(D.silhouettes.indices)}:void 0,polylines:D.polylines?{...D.polylines,indices:new Oa(D.polylines.indices),prevIndices:new Oa(D.polylines.prevIndices)}:void 0,indexed:D.indexed?{indices:new Oa(D.indexed.indices),edges:D.indexed.edges}:void 0}):void 0,isPlanar:R.params.isPlanar,auxChannels:R.params.auxChannels?Ma.fromJSON(R.params.auxChannels):void 0},X=Ja({...E,params:M,createMaterial:y=>oc.create(y)});for(const[E,D]of X){let y;D.surface.material&&(D.surface.material.isAtlas?y=D.surface.material:(e(D.surface.material.material),y=D.surface.material.material.toImdl())),e(void 0===D.surface.textureMapping||D.surface.textureMapping.texture),b(E).primitives.push({type:"mesh",modifier:R.modifier,params:{vertices:cc(D.vertices),surface:{...D.surface,indices:D.surface.indices.data,material:y,textureMapping:D.surface.textureMapping?.texture instanceof sc?{texture:D.surface.textureMapping.texture.toImdl(),alwaysDisplayed:D.surface.textureMapping.alwaysDisplayed}:void 0},edges:D.edges?lc(D.edges):void 0,isPlanar:D.isPlanar,auxChannels:D.auxChannels?.toJSON()}})}break}case"point":{const y={vertices:ac(R.params.vertices),indices:new Oa(R.params.indices),weight:R.params.weight},k=qa({...E,params:y});for(const[M,E]of k)b(M).primitives.push({type:"point",modifier:R.modifier,params:{vertices:cc(E.vertices),indices:E.indices.data,weight:E.weight}});break}case"polyline":{const y={...R.params,vertices:ac(R.params.vertices),polyline:{indices:new Oa(R.params.polyline.indices),prevIndices:new Oa(R.params.polyline.prevIndices),nextIndicesAndParams:R.params.polyline.nextIndicesAndParams}},k=Qa({...E,params:y});for(const[M,E]of k)b(M).primitives.push({type:"polyline",modifier:R.modifier,params:{...E,vertices:cc(E.vertices),polyline:{indices:E.polyline.indices.data,prevIndices:E.polyline.prevIndices.data,nextIndicesAndParams:E.polyline.nextIndicesAndParams}}});break}}var D}groupPrimitiveNodes(k,M){const b=this._options.modelGroups;if(!b?.length)return k;const E=[];let D;const o=y=>{if(e(b.length),y===b.length)return D??(D={groupId:y,nodes:[]});let k=E[y];return k||(E[y]=k={groupId:y,nodes:[]}),k},R=dc(M,this._options.batchModelId),X={lower:0,upper:0},l=k=>{R.getModelIdPair(k,X);const M=y.fromUint32PairObject(X);for(let y=0;y<b.length;y++)if(b[y].has(M))return y;return b.length};for(const y of k){const k=[],i=M=>{if(M=M??b.length,!k[M]){const b=k[M]={...y,primitives:[]};o(M).nodes.push(b)}return k[M]};this.splitPrimitives(y.primitives,R,l,i)}return E.filter((y=>void 0!==y))}parseTesselatedPolyline(y){const k=this.findBuffer(y.indices),M=this.findBuffer(y.prevIndices),b=this.findBuffer(y.nextIndicesAndParams);return k&&M&&b?{indices:k,prevIndices:M,nextIndicesAndParams:b}:void 0}parseSegmentEdges(y){const k=this.findBuffer(y.indices),M=this.findBuffer(y.endPointAndQuadIndices);return k&&M?{indices:k,endPointAndQuadIndices:M}:void 0}parseSilhouetteEdges(y){const k=this.parseSegmentEdges(y),M=this.findBuffer(y.normalPairs);return k&&M?{...k,normalPairs:M}:void 0}parseIndexedEdges(y){const k=this.findBuffer(y.indices),M=this.findBuffer(y.edges);if(k&&M)return{indices:k,edges:{data:M,width:y.width,height:y.height,silhouettePadding:y.silhouettePadding,numSegments:y.numSegments}}}parseCompactEdges(y,k){const M=this.findBuffer(y.visibility);if(!M)return;const b=void 0!==y.normalPairs?this.findBuffer(y.normalPairs):void 0;return function(y){const k=y.normalPairs?.length??0,M=y.numVisibleEdges+k;if(M<=0)return;const b=new Oa(new Uint8Array(6*M*3));for(let O=0;O<M;O++)for(let y=0;y<6;y++)b.setNthIndex(6*O+y,O);const{width:E,height:D,silhouettePadding:R,silhouetteStartByteIndex:X}=Na(y.numVisibleEdges,k,y.maxEdgeTableDimension),z=new Uint8Array(E*D*4);let N=0,Y=0;for(const O of function*(y,k,M){let b=0,E=0,D=0;const R={index0:0,index1:1};for(let X=0;X<k.length;X++){const z=y[E]>>b&3;b+=2,8===b&&(b=0,E++),Fc.Hidden!==z&&(R.index0=k.decodeIndex(X),R.index1=k.decodeIndex(X%3==2?X-2:X+1),Fc.Silhouette===z?(e(),R.normals=M[D++]):R.normals=void 0,yield R)}}(y.visibility,y.vertexIndices,y.normalPairs))if(void 0===O.normals){const y=6*N++;$a(z,y,O.index0),$a(z,y+3,O.index1)}else{const y=X+R+10*Y++;$a(z,y,O.index0),$a(z,y+3,O.index1),z[y+6]=255&O.normals,z[y+7]=(65280&O.normals)>>>8,z[y+8]=(16711680&O.normals)>>>16,z[y+9]=(4278190080&O.normals)>>>24}return{indices:b.data,edges:{data:z,width:E,height:D,numSegments:y.numVisibleEdges,silhouettePadding:R}}}({numVisibleEdges:y.numVisible,visibility:M,vertexIndices:k,normalPairs:b?new Uint32Array(b.buffer,b.byteOffset,b.byteLength/4):void 0,maxEdgeTableDimension:this._options.maxVertexTableSize})}parseEdges(y,k,M){if(!y)return;const b=y.segments?this.parseSegmentEdges(y.segments):void 0,E=y.silhouettes?this.parseSilhouetteEdges(y.silhouettes):void 0,D=y.polylines?this.parseTesselatedPolyline(y.polylines):void 0;let R=y.indexed?this.parseIndexedEdges(y.indexed):void 0;return!R&&y.compact&&(R=this.parseCompactEdges(y.compact,new Oa(M))),b||E||R||D?{segments:b,silhouettes:E,polylines:D,indexed:R,weight:k.width,linePixels:k.linePixels}:void 0}getPattern(y){let k=this._patterns.get(y);if(!k){const M=this._document.patternSymbols[y];k=M?this.parsePrimitives(M.primitives):[],this._patterns.set(y,k)}return k.length>0?k:void 0}parseAreaPattern(y){const k=this.getPattern(y.symbolName);if(!k||0===k.length)return;const M=this.findBuffer(y.xyOffsets);return M?{type:"pattern",params:{...y,xyOffsets:new Float32Array(M.buffer,M.byteOffset,M.byteLength/4)}}:void 0}parseNodePrimitives(y){const k=[];for(const M of y){const y=this.parseNodePrimitive(M);y&&k.push(y)}return k}parseNodePrimitive(y){return"areaPattern"===y.type?this.parseAreaPattern(y):this.parsePrimitive(y)}parsePrimitives(y){const k=[];for(const M of y){const y=this.parsePrimitive(M);y&&k.push(y)}return k}parsePrimitive(y){let k=this.parseInstances(y);if(!k&&y.viewIndependentOrigin){const M=j.fromJSON(y.viewIndependentOrigin);k={type:"viewIndependentOrigin",origin:{x:M.x,y:M.y,z:M.z}}}const M=y.material??"",b=M.length?Ho.asObject(this._document.materials[M]):void 0,E=b?this.parseDisplayParams(b):void 0;if(!E)return;const D=this.parseVertexTable(y);if(!D)return;let R;const X=!this._options.is3d||Ho.asBool(y.isPlanar);switch(y.type){case Ic.Mesh:{const k=this.parseSurface(y,E);k&&(R={type:"mesh",params:{vertices:D,surface:k,isPlanar:X,auxChannels:this.parseAuxChannelTable(y),edges:this.parseEdges(y.edges,E,k.indices)}});break}case Ic.Polyline:{const k=this.parseTesselatedPolyline(y);if(k){let y=uc.Normal;va.RegionEdgeType.Outline===E.regionEdgeType&&(y=!E.gradient||E.gradient.isOutlined?uc.Edge:uc.Outline),R={type:"polyline",params:{vertices:D,polyline:k,isPlanar:X,type:y,weight:E.width,linePixels:E.linePixels}}}break}case Ic.Point:{const k=this.findBuffer(y.indices),M=E.width;k&&(R={type:"point",params:{vertices:D,indices:k,weight:M}});break}}return R&&(R.modifier=k),R}parseSurface(y,k){const M=y.surface;if(!M)return;const b=this.findBuffer(M.indices);if(!b)return;const E=M.type;if(!function(y){switch(y){case Sc.Unlit:case Sc.Lit:case Sc.Textured:case Sc.TexturedLit:case Sc.VolumeClassifier:return!0;default:return!1}}(E))return;const D=k.textureMapping?.texture;let R;const X=y.vertices.materialAtlas,z=y.vertices.numColors;let N;return X&&void 0!==z?R={isAtlas:!0,hasTranslucency:Ho.asBool(X.hasTranslucency),overridesAlpha:Ho.asBool(X.overridesAlpha,!1),vertexTableOffset:Ho.asInt(z),numMaterials:Ho.asInt(X.numMaterials)}:k.material&&(e(k.material),R=k.material.toImdl()),D&&(e(),N={texture:D.toImdl(),alwaysDisplayed:Ho.asBool(M.alwaysDisplayTexture)}),{type:E,indices:b,fillFlags:k.fillFlags,hasBakedLighting:!1,material:R,textureMapping:N}}parseAuxChannelTable(y){const k=y.auxChannels;if(void 0===k)return;const M=this.findBuffer(Ho.asString(k.bufferView));return void 0!==M?{data:M,width:k.width,height:k.height,count:k.count,numBytesPerVertex:k.numBytesPerVertex,displacements:k.displacements,normals:k.normals,params:k.params}:void 0}parseVertexTable(y){const k=y.vertices;if(!k)return;const M=this.findBuffer(Ho.asString(k.bufferView));if(!M)return;const b=void 0!==k.featureID?Ho.asInt(k.featureID):void 0,E=Ho.asArray(k.params.decodedMin),D=Ho.asArray(k.params.decodedMax);if(void 0===E||void 0===D)return;const R=fa.fromRange(ut.create(j.create(E[0],E[1],E[2]),j.create(D[0],D[1],D[2]))),X=void 0!==k.uniformColor?$r.fromJSON(k.uniformColor):void 0;let z;if(Ic.Mesh===y.type&&y.surface&&y.surface.uvParams){const k=y.surface.uvParams.decodedMin,M=y.surface.uvParams.decodedMax,b=new gt(k[0],k[1],M[0],M[1]);z=da.fromRange(b)}return{data:M,usesUnquantizedPositions:!0===k.usesUnquantizedPositions,qparams:R.toJSON(),width:k.width,height:k.height,hasTranslucency:k.hasTranslucency,uniformColor:X?.toJSON(),featureIndexType:k.featureIndexType,uniformFeatureID:b,numVertices:k.count,numRgbaPerVertex:k.numRgbaPerVertex,uvParams:z?.toJSON()}}parseInstances(y){const k=y.instances;if(!k)return;const M=Ho.asInt(k.count,0);if(M<=0)return;const b=Ho.asArray(k.transformCenter);if(void 0===b||3!==b.length)return;const E=j.create(b[0],b[1],b[2]),D=this.findBuffer(Ho.asString(k.featureIds));if(void 0===D)return;const R=this.findBuffer(Ho.asString(k.transforms));if(void 0===R)return;const X=R.byteLength/4;e(Math.floor(X)),e();const z=new Float32Array(R.buffer,R.byteOffset,X);let N;return void 0!==k.symbologyOverrides&&(N=this.findBuffer(Ho.asString(k.symbologyOverrides))),{type:"instances",count:M,transforms:z,transformCenter:E,featureIds:D,symbologyOverrides:N}}findBuffer(y){if("string"!=typeof y||0===y.length)return;const k=this._document.bufferViews[y];if(void 0===k)return;const M=Ho.asInt(k.byteOffset),b=Ho.asInt(k.byteLength);return 0!==b?this._binaryData.subarray(M,M+b):void 0}colorDefFromMaterialJson(y){return void 0!==y?$r.from(255*y[0]+.5,255*y[1]+.5,255*y[2]+.5):void 0}materialFromJson(y){const k=this._document.renderMaterials[y];if(!k)return;const M=new ha.Params(y);return M.diffuseColor=this.colorDefFromMaterialJson(k.diffuseColor),void 0!==k.diffuse&&(M.diffuse=Ho.asDouble(k.diffuse)),M.specularColor=this.colorDefFromMaterialJson(k.specularColor),void 0!==k.specular&&(M.specular=Ho.asDouble(k.specular)),M.reflectColor=this.colorDefFromMaterialJson(k.reflectColor),void 0!==k.reflect&&(M.reflect=Ho.asDouble(k.reflect)),void 0!==k.specularExponent&&(M.specularExponent=k.specularExponent),void 0!==k.transparency&&(M.alpha=1-k.transparency),M.refract=Ho.asDouble(k.refract),M.shadows=Ho.asBool(k.shadows),M.ambient=Ho.asDouble(k.ambient),void 0!==k.textureMapping&&(M.textureMapping=this.textureMappingFromJson(k.textureMapping.texture)),new oc(M)}parseNamedTexture(y,k){const M=Ho.asBool(y.isGlyph)?la.Type.Glyph:Ho.asBool(y.isTileSection)?la.Type.TileSection:la.Type.Normal;return new nc(k,M)}parseConstantLodProps(y){if(void 0!==y)return{repetitions:Ho.asDouble(y.repetitions,1),offset:{x:y.offset?Ho.asDouble(y.offset[0]):0,y:y.offset?Ho.asDouble(y.offset[1]):0},minDistClamp:Ho.asDouble(y.minDistClamp,1),maxDistClamp:Ho.asDouble(y.maxDistClamp,4294967296)}}textureMappingFromJson(y){if(!y)return;const k=Ho.asString(y.name),M=0!==k.length?this._document.namedTextures[k]:void 0,b=M?this.parseNamedTexture(M,k):void 0;if(!b)return;const E=y.params,D=E.transform,R={textureMat2x3:new xa.Trans2x3(D[0][0],D[0][1],D[0][2],D[1][0],D[1][1],D[1][2]),textureWeight:Ho.asDouble(E.weight,1),mapMode:Ho.asInt(E.mode),worldMapping:Ho.asBool(E.worldMapping),useConstantLod:Ho.asBool(E.useConstantLod),constantLodProps:this.parseConstantLodProps(E.constantLodParams)},X=new xa(b,new xa.Params(R)),z=y.normalMapParams;if(z){const y=Ho.asString(z.textureName),k=y.length>0?this._document.namedTextures[y]:void 0,M=k?this.parseNamedTexture(k,y):void 0;M&&(X.normalMapParams={normalMap:M,greenUp:Ho.asBool(z.greenUp),scale:Ho.asDouble(z.scale,1),useConstantLod:Ho.asBool(z.useConstantLod)})}return X}parseDisplayParams(y){const k=Ho.asInt(y.type,va.Type.Mesh),M=$r.create(Ho.asInt(y.lineColor)),b=$r.create(Ho.asInt(y.fillColor)),E=Ho.asInt(y.lineWidth),D=Ho.asInt(y.linePixels,fc.Solid),R=Ho.asInt(y.fillFlags,gc.None),X=Ho.asBool(y.ignoreLighting),z=y.materialId,N=void 0!==z?this.materialFromJson(z):void 0;let Y,O;if(!N){const k=y.texture;if(Y=void 0!==k?this.textureMappingFromJson(k):void 0,void 0===Y){const k=y.gradient;if(O=void 0!==k?Ac.Symb.fromJSON(k):void 0,O){e();const y=new rc(k);Y=new xa(y,new xa.Params({textureMat2x3:new xa.Trans2x3(0,1,0,1,0,0)}))}}}return new va(k,M,b,E,D,R,N,O,X,Y)}}function dc(y,k){const M=y.multiModel?xo.create(y.data,k,y.numFeatures,Uo.Primary,y.numSubCategories):new go(y.data,k,y.numFeatures,Uo.Primary);return M.animationNodeIds=y.animationNodeIds,M}let Mc;var bc;bc={parse:y=>{const k=function(y){const k=oa.fromUint8Array(y.data),M=new pa(k);if(!M.isValid)return Jo.InvalidHeader;if(!M.isReadableVersion)return Jo.NewerMajorVersion;const b=k.curPos,E=ma.readFrom(k);if(!E)return Jo.InvalidFeatureTable;k.curPos=b+E.length;const D=new tc(k);if(!D.isValid)return Jo.InvalidTileData;k.curPos=D.scenePosition;const R=(X=k.nextBytes(D.sceneStrLength),new TextDecoder("utf-8").decode(X));var X;if(!R)return Jo.InvalidScene;try{const E=JSON.parse(R),X={scene:Ho.asString(E.scene),scenes:Ho.asArray(E.scenes),animationNodes:Ho.asObject(E.animationNodes),bufferViews:Ho.asObject(E.bufferViews)??{},meshes:Ho.asObject(E.meshes),nodes:Ho.asObject(E.nodes)??{},materials:Ho.asObject(E.materials)??{},renderMaterials:Ho.asObject(E.renderMaterials)??{},namedTextures:Ho.asObject(E.namedTextures)??{},patternSymbols:Ho.asObject(E.patternSymbols)??{},rtcCenter:Ho.asArray(E.rtcCenter)};if(!X.meshes)return Jo.InvalidTileData;const z=new Uint8Array(k.arrayBuffer,D.binaryPosition),N={startPos:b,multiModel:!!(M.flags&Ka.MultiModelFeatureTable)};return new hc(X,z,y,N,k).parse()}catch{return Jo.InvalidTileData}}({...y,data:y.data,timeline:Mc});return"number"==typeof k?k:{result:k,transfer:ra(k)}},setTimeline:y=>{e(),Mc=Array.isArray(y)?Go.Script.fromJSON(y):Go.ModelTimeline.fromJSON(y)}},onmessage=async y=>{const k=y.data,M=k.msgId;try{e();const y=bc[k.operation];e();let b=y(k.payload);b instanceof Promise&&(b=await b),"object"==typeof b&&"transfer"in b?postMessage({result:b.result,msgId:M},{transfer:b.transfer}):postMessage({result:b,msgId:M})}catch(y){const k=y instanceof Error?y:new Error("Unknown worker error");postMessage({error:k,msgId:M})}}})();